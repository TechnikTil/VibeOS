### Session 21
- **Power management overhaul - CPU no longer cooks the host!**
  - Problem: Desktop was redrawing at infinite FPS, QEMU using 150% CPU
  - Root cause: Busy-wait loops everywhere, no sleeping
- **Mouse now interrupt-driven:**
  - Added `mouse_get_irq()` and `mouse_irq_handler()` (like keyboard)
  - Registered mouse IRQ in kernel.c
- **Added sleep functions to kapi:**
  - `wfi()` - ARM Wait For Interrupt instruction
  - `sleep_ms(ms)` - Sleep for at least N milliseconds using timer ticks
- **Kernel-level idle via WFI:**
  - When process yields and it's the only runnable process, scheduler calls WFI
  - CPU sleeps until next interrupt (timer at 100Hz, keyboard, or mouse)
  - This is the RIGHT approach - kernel handles idle, not apps
- **Removed busy-wait delays from games:**
  - Snake and Tetris had `delay()` functions doing NOPs
  - Replaced with `sleep_ms()` for proper game tick timing
- **Fixed recovery shell:**
  - Was busy-looping on `keyboard_getc()` with no sleep
  - Now WFIs when no input available
- **UI apps just yield():**
  - Desktop, calc, files, textedit, term, sysmon - all just call `yield()`
  - Kernel WFIs if nothing else to do, wakes on interrupt
  - Effective frame rate: 100fps (timer is 100Hz)
- **Result:**
  - CPU usage dropped from 150% to ~10% idle
  - UI runs at smooth 100fps
  - Mouse and keyboard remain responsive (interrupt-driven)
- **Achievement**: Proper power management! VibeOS is now a good citizen.

### Session 22
- **FAT32 Long Filename (LFN) Writing - COMPLETE!**
  - Can now create files/directories with any name length (up to 255 chars)
  - Implemented `needs_lfn()` - detects when LFN is required (lowercase, length, special chars)
  - Implemented `generate_basis_name()` - creates 8.3 basis from long name
  - Implemented `generate_short_name()` - creates unique 8.3 name with ~1, ~2, etc. suffix
  - Implemented `build_lfn_entry()` - constructs LFN directory entries with UTF-16LE encoding
  - Implemented `find_free_dir_entries()` - finds N consecutive free slots for LFN + short entry
  - Updated `create_dir_entry()` - writes LFN entries in reverse order followed by 8.3 entry
  - Updated `fat32_rename()` - deletes old entries (including LFN), creates new with LFN support
  - Updated `fat32_delete()`, `fat32_delete_dir()`, `fat32_delete_recursive()` - properly deletes LFN entries
  - Added `delete_dir_entry_with_lfn()` - finds and marks all associated LFN entries as deleted
- **Build fix**: fat32.c requires -O0 (added to Makefile)
  - GCC -O2 generates bad code for LFN byte manipulation
  - Caused translation faults when writing to valid heap memory
- **Achievement**: Full LFN support! `touch "my long filename.txt"` works!

### Session 23
- **Virtio Sound Driver - Audio playback working!**
  - Built complete virtio-sound driver (kernel/virtio_sound.c, kernel/virtio_sound.h)
  - Device ID 25, virtqueues: controlq (0), eventq (1), txq (2), rxq (3)
  - PCM stream lifecycle: set_params → prepare → start → submit data → stop
  - WAV file parsing with format/rate detection
  - Supports 44100Hz, 48000Hz sample rates; 16-bit stereo/mono
- **New files:**
  - `kernel/virtio_sound.c` - Full virtio sound driver (~600 lines)
  - `kernel/virtio_sound.h` - Public API: play_wav, stop, is_playing
  - `user/bin/play.c` - Userspace play command
- **Added to kapi:**
  - `sound_play_wav(data, size)` - Play WAV from memory
  - `sound_stop()` - Stop playback
  - `sound_is_playing()` - Check if playing
- **QEMU flags updated:**
  - Added `-device virtio-sound-device,audiodev=audio0 -audiodev coreaudio,id=audio0`
- **Critical boot fixes:**
  - Stack was at 0x40010000, inside BSS (0x40001000-0x400290d4) - getting overwritten!
  - Moved stack to 0x40100000 (1MB into RAM) in boot.S
  - `_data_load` at 0x1a9bb was NOT 8-byte aligned - caused hang during data copy
  - Added `. = ALIGN(8);` before `_data_load = .;` in linker.ld
- **Build change:**
  - Changed to `-O0` everywhere (both kernel and userspace) to avoid optimization issues
- **Fixed slow file loading:**
  - `play.c` was reading file twice: once to get size, once to load data
  - Added `file_size()` to kapi - returns vfs_node->size directly
  - Now files load instantly instead of 7+ seconds
- **Achievement**: VibeOS can play audio! `play /beep.wav` works!

### Session 24
- **Floating Point Support - COMPLETE!**
  - Enabled FPU in boot.S: `mov x0, #(3 << 20); msr cpacr_el1, x0`
  - Removed `-mgeneral-regs-only` from CFLAGS (was blocking all FP)
  - Added `-mstrict-align` to prevent unaligned SIMD access faults
  - GCC now uses SIMD for memcpy/struct ops, which is fine with strict-align
- **Context switch updated for FP state:**
  - Extended cpu_context_t: added fpcr, fpsr, _pad, fp_regs[64]
  - _pad ensures fp_regs is at offset 0x80 (16-byte aligned for stp/ldp q regs)
  - context.S now saves/restores all 32 Q registers (q0-q31) plus fpcr/fpsr
- **Calculator now uses floating point:**
  - Changed display_value/pending_value from int to double
  - Added decimal point button (replaced C button)
  - Added float_to_str() for display (no printf %f available)
  - Clear via 'c'/'C' keyboard key
  - Can now do: 10 / 3 = 3.333333, 3.14159 * 2, etc.
- **MAJOR BUG FIX: Kernel stack vs heap collision**
  - Symptom: Process exit crashed with `0x00ffffff` in return address
  - Root cause: Kernel stack at 0x40100000 was INSIDE heap range (0x4003c0d4 - 0x41000000)
  - Large heap allocations (backbuffer) overwrote stack with framebuffer data
  - Debug showed local variable `old_pid` corrupted from -1 to 0x00ffffff (COLOR_WHITE)
  - Fix: Moved stack to 0x4F000000, well above heap and program load area
- **Memory layout clarified:**
  ```
  0x40000000 - 0x40200000: DTB (Device Tree Blob, placed by QEMU)
  0x40200000 - 0x40237000: Kernel .data/.bss
  0x40247000 - 0x4E000000: Heap (dynamic, up to stack - 1MB)
  0x4E000000+:             Program load area (after heap)
  0x4F000000:              Kernel stack (grows down, hardcoded)
  RAM end:                 Detected from DTB (256MB-4GB+)
  ```
- **Memory collision issue (MOSTLY FIXED in Session 26)**
  - Was: hardcoded magic numbers everywhere that collided as kernel grew
  - Now: heap and program areas are dynamic based on DTB-detected RAM
  - Stack is still hardcoded at 0x4F000000 (works for 256MB+ systems)
  - Heap is bounded by stack address, so can't overflow into stack anymore
- **Achievement**: Floating point works! Calculator does decimals! Processes exit cleanly!

- **Enabled -O3 optimization!**
  - Changed CFLAGS and USER_CFLAGS from -O0 to -O3
  - Everything works except kernel's `fat32_delete_recursive()` which breaks with -O3
  - Solution: Moved recursive delete logic to userspace (rm.c and files.c)
  - Kernel only needs to delete single files and empty directories
  - Userspace iterates with `readdir()` and deletes children before parent
- **Userspace recursive delete:**
  - `rm -r` now implements recursion in userspace
  - Files app delete action uses same userspace implementation
  - Works correctly with -O3 optimization
- **Achievement**: Full -O3 optimization across kernel and userspace!

### Session 25
- **Desktop modularization - code cleanup!**
  - Extracted icon bitmaps to `user/lib/icons.h` (~500 lines of bitmap data)
  - Created VibeOS logo (stylized "V") to replace Apple logo
  - Created shared graphics library `user/lib/gfx.h` (header-only, ~130 lines)
  - Updated all GUI apps to use gfx.h instead of duplicated drawing code:
    - desktop.c, calc.c, sysmon.c, files.c, textedit.c
  - Removed ~250 lines of duplicated buf_*/bb_* drawing functions across apps
  - desktop.c reduced from ~1500 to ~1200 lines
- **New files:**
  - `user/lib/icons.h` - All 32x32 dock icons + 16x16 VibeOS logo
  - `user/lib/gfx.h` - gfx_ctx_t context, put_pixel, fill_rect, draw_char, draw_string, draw_rect, patterns
- **Architecture note:**
  - gfx.h is header-only with static inline functions - no Makefile changes needed
  - Apps use macros to alias old function names (buf_*, bb_*) to new gfx_* calls
  - Zero runtime overhead, compiler inlines everything
- **Achievement**: Cleaner codebase! Shared graphics primitives!

### Session 26
- **Device Tree Blob (DTB) parsing - RAM detection at runtime!**
  - Built DTB parser (`kernel/dtb.c`, `kernel/dtb.h`)
  - Parses QEMU's device tree to find memory node with base/size
  - Tested with 256MB, 1GB, 4GB - all detected correctly
- **Dynamic memory layout - no more hardcoded heap size!**
  - Linker script now starts RAM at 0x40200000 (preserves DTB at 0x40000000)
  - Heap size computed at runtime: from BSS end to (stack - 1MB buffer)
  - Program load area follows heap_end dynamically
  - Framebuffer now allocated via malloc instead of hardcoded address
- **Memory layout now:**
  - DTB preserved at 0x40000000 (up to 2MB reserved)
  - Kernel .data/.bss at 0x40200000+
  - Heap from BSS end to 0x4E000000 (~238MB on 256MB system)
  - Programs load after heap
  - Stack still hardcoded at 0x4F000000 (works for 256MB+ systems)
- **Key insight:** One shared address space (Win3.1 model)
  - Heap is shared by kernel + all apps
  - App static variables (`int x = 3`) live in ELF's .data section, loaded into program area
  - Only explicit `malloc()` uses the heap
- **Gotcha: DTB unaligned access**
  - Direct pointer casts to read 32/64-bit values cause alignment faults
  - Must read bytes individually and assemble (see `read_be32`/`read_be64`)
- **Achievement**: RAM detected dynamically! No more arbitrary 256MB cap!

### Session 27
- **MP3 Playback - minimp3 ported!**
  - Integrated minimp3 single-header decoder into userspace
  - Created stub headers `user/lib/stdlib.h` and `user/lib/string.h` for freestanding build
  - Added `memcmp`, `memmove` to string.h stub
  - `#define MINIMP3_NO_SIMD` to avoid NEON complexity (can enable later for perf)
- **Refactored sound API:**
  - Moved WAV parsing from kernel to userspace (kernel shouldn't parse file formats)
  - Added `sound_play_pcm(data, samples, channels, rate)` to kapi - flexible raw PCM playback
  - Kernel's `hz_to_rate_index()` converts Hz to virtio rate constants
- **Mono to stereo conversion:**
  - virtio-sound doesn't support mono playback
  - play.c converts mono MP3s to stereo by duplicating samples
- **Async (non-blocking) playback!**
  - Added `sound_play_pcm_async()` - starts playback and returns immediately
  - Added `virtio_sound_pump()` - called from timer interrupt (100Hz) to feed audio chunks
  - Audio plays in background while user continues using the system
  - PCM buffer must stay allocated during playback (memory is "orphaned" but OK for CLI)
- **play command upgraded:**
  - `play /file.wav` - plays WAV files
  - `play /file.mp3` - decodes and plays MP3 files
  - Auto-detects format by extension or magic bytes (RIFF, ID3, MP3 sync)
  - Shows format info: sample rate, channels, duration, bitrate
- **New/modified files:**
  - `vendor/minimp3.h` - Single-header MP3 decoder (already existed)
  - `user/lib/stdlib.h` - Empty stub for minimp3
  - `user/lib/string.h` - memcmp, memmove for minimp3
  - `user/bin/play.c` - WAV/MP3 player with async playback
  - `kernel/virtio_sound.c` - Added async playback, pump function
  - `kernel/irq.c` - Timer calls virtio_sound_pump()
- **Achievement**: MP3 playback with non-blocking audio! Music plays while you work!

### Session 28
- **Built GUI Music Player (`/bin/music`)!**
  - Classic Mac System 7 1-bit B&W aesthetic
  - Two-panel layout: album sidebar (160px) + track list
  - Scans `/home/user/Music/` for album folders containing MP3s
  - Click album to load tracks, double-click track to play
  - Playback controls: |< (back), Play/Pause, >| (next)
  - Progress bar with elapsed/total time display
  - Volume slider (visual only for now)
  - Keyboard shortcuts: Space (play/pause), N/P (next/prev), arrows (select), Enter (play)
  - Auto-advances to next track when song ends
- **Implemented pause/resume in kernel:**
  - Added `virtio_sound_pause()` - stops stream but keeps playback state
  - Added `virtio_sound_resume()` - reconfigures and restarts from paused position
  - Added `virtio_sound_is_paused()` - check pause state
  - New kapi functions: `sound_pause`, `sound_resume`, `sound_is_paused`
  - Pause saves offset, resume continues from where it left off
- **Fixed progress bar duration bug:**
  - `pcm_samples * 1000` was overflowing uint32_t for songs > 71 seconds
  - Changed to `(uint64_t)pcm_samples * 1000` for 64-bit multiplication
  - Added `uint64_t` typedef to `user/lib/vibe.h`
- **Music player icon added to dock:**
  - 32x32 musical note icon in `user/lib/icons.h`
  - Click dock icon to launch music player
- **New/modified files:**
  - `user/bin/music.c` - Full music player application (~800 lines)
  - `user/lib/icons.h` - Added music_icon bitmap
  - `user/bin/desktop.c` - Added Music app to dock
  - `kernel/virtio_sound.c` - Pause/resume support, state tracking
  - `kernel/virtio_sound.h` - New function declarations
  - `kernel/kapi.c`, `kernel/kapi.h` - Exposed pause/resume to userspace
  - `user/lib/vibe.h` - Added uint64_t, pause/resume kapi functions
- **Achievement**: Full-featured music player! Pause, resume, progress tracking all work!

### Session 29
- **Improved Terminal Emulator (`/bin/term`):**
  - 500-line scrollback buffer (ring buffer implementation)
  - Mouse drag scrolling - click and drag to scroll through history
  - Scroll indicator `[N]` in top-right when scrolled back
  - Auto-scroll to bottom on keystroke
  - Input buffer now uses `int` to preserve special keys (0x100+)
  - Form feed (\f) support for clear screen
- **Improved Shell (`/bin/vibesh`) with readline-like editing:**
  - Command history (50 commands) with Up/Down arrow navigation
  - `!!` to repeat last command
  - Ctrl+C - clear current line (prints ^C)
  - Ctrl+U - clear line before cursor
  - Ctrl+D - exit shell (EOF) when line empty
  - Ctrl+L - clear screen
  - Ctrl+R - reverse incremental search through history
  - Tab completion for commands (/bin) and file paths
  - `clear` builtin command
  - Left/Right arrows for cursor movement
  - Home/End to jump to start/end of line
  - Delete key support
- **Added special key constants to vibe.h:**
  - KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_HOME, KEY_END, KEY_DELETE
- **Achievement**: Proper terminal with scrollback and readline-style shell!

### Session 30
- **NETWORKING - VibeOS is on the internet!**
- **Virtio-net driver (`kernel/virtio_net.c`):**
  - Device ID 1, virtqueues: 0=receiveq, 1=transmitq
  - Reads MAC address from config space
  - Pre-populates RX buffers for async receive
  - Interrupt-driven packet notification (IRQ handler just acks, doesn't consume)
- **Network stack (`kernel/net.c`, `kernel/net.h`):**
  - Ethernet frame send/receive
  - ARP table (16 entries) with request/reply handling
  - IP layer with checksum calculation and routing
  - ICMP echo request/reply (ping)
  - Automatic gateway ARP resolution
- **Network configuration (QEMU user-mode NAT):**
  - Our IP: 10.0.2.15
  - Gateway: 10.0.2.2
  - DNS: 10.0.2.3
- **Ping command (`/bin/ping`):**
  - Parses IP addresses from command line
  - Sends 4 ICMP echo requests with 1 second timeout
  - Shows reply/timeout for each, plus statistics
- **QEMU flags updated:**
  - Added `-device virtio-net-device,netdev=net0 -netdev user,id=net0`
- **kapi additions:**
  - `net_ping(ip, seq, timeout_ms)` - Blocking ping
  - `net_poll()` - Process incoming packets
  - `net_get_ip()`, `net_get_mac()` - Get our addresses
- **New files:**
  - `kernel/virtio_net.c` (~400 lines) - Virtio network driver
  - `kernel/virtio_net.h` - Driver header
  - `kernel/net.c` (~450 lines) - Network stack
  - `kernel/net.h` - Network stack header
  - `user/bin/ping.c` - Ping command
- **Bug fixed: main() argument order**
  - crt0.S passes: `main(kapi_t*, argc, argv)`
  - ping.c had wrong order, caused crash on kapi access
- **Achievement**: Can ping 1.1.1.1 (Cloudflare) from VibeOS! Packets traverse the real internet!

### Session 31
- **UDP, DNS, TCP, and HTTP - Full network stack complete!**
- **UDP implementation (`kernel/net.c`):**
  - UDP listener table with callback system (8 ports)
  - `udp_bind(port, callback)` / `udp_unbind(port)` - register listeners
  - `udp_send(ip, src_port, dst_port, data, len)` - send packets
  - Checksum optional (set to 0, valid for IPv4)
- **DNS resolver (`kernel/net.c`):**
  - `dns_resolve(hostname)` - returns IP address or 0
  - Builds DNS query packets with proper QNAME encoding
  - Parses A records from response
  - Uses QEMU's built-in DNS at 10.0.2.3
- **Ping updated:**
  - `ping google.com` now works (resolves hostname first)
  - Auto-detects IP vs hostname input
- **TCP implementation (`kernel/net.c`, ~430 lines):**
  - Full TCP state machine: CLOSED → SYN_SENT → ESTABLISHED → FIN_WAIT → etc.
  - TCP pseudo-header checksum calculation
  - 3-way handshake in `tcp_connect()`
  - 8KB receive ring buffer per socket
  - Proper FIN/ACK handling for graceful close
  - 8 concurrent sockets supported
  - MSS-aware segmentation (1400 byte chunks)
- **TCP API:**
  - `tcp_connect(ip, port)` - connect to server, returns socket handle
  - `tcp_send(sock, data, len)` - send data, returns bytes sent
  - `tcp_recv(sock, buf, maxlen)` - receive data (non-blocking)
  - `tcp_close(sock)` - graceful close with FIN
  - `tcp_is_connected(sock)` - check connection state
- **Fetch command (`/bin/fetch`):**
  - Usage: `fetch <hostname> [path]`
  - Resolves hostname, opens TCP connection to port 80
  - Sends HTTP/1.0 GET request
  - Prints response body
  - Example: `fetch google.com /` → got 301 redirect!
- **kapi additions:**
  - `dns_resolve(hostname)` - DNS resolution
  - `tcp_connect`, `tcp_send`, `tcp_recv`, `tcp_close`, `tcp_is_connected`
- **Achievement**: Made an HTTP request to google.com and got a real response!

### Session 32
- **Web Browser (`/bin/browser`) - GUI web browser!**
- **Improved fetch command:**
  - URL parsing (host, port, path extraction)
  - HTTP header parsing (status code, Content-Length, Location, Content-Type)
  - Redirect following (301, 302, 307, 308) with max 5 redirects
  - Handles both absolute and relative redirect URLs
- **Browser features:**
  - GUI window with address bar
  - Click address bar to edit URL, Enter to navigate
  - HTML parser with tag handling:
    - Strips `<script>`, `<style>`, `<head>` content
    - Handles headings (h1-h6), bold, links, lists, paragraphs
    - Decodes HTML entities (&amp;, &lt;, &gt;, etc.)
  - Text rendering with word wrap
  - Scrolling with Up/Down arrows, j/k keys, Space for page down
  - Scrollbar indicator for long pages
  - Status bar showing loading/ready state
  - Keyboard shortcuts: G (go to URL), R (reload)
- **Browser icon added to dock** (globe icon)
- **HTTP quirks discovered:**
  - Many sites force HTTPS (Wikipedia, YouTube, Amazon, DuckDuckGo)
  - Some sites reject simple User-Agent strings
  - Changed User-Agent to Chrome on Windows for compatibility
  - Works well on: httpforever.com, stallman.org, info.cern.ch
  - HTTPS would require full TLS implementation (~thousands of lines of crypto)
- **Debugging network issues:**
  - `yield()` during HTTP receive caused timing issues with desktop
  - `sleep_ms()` works correctly for polling
  - Different sites have different response timing behaviors
- **New files:**
  - `user/bin/browser.c` (~730 lines) - Full GUI web browser
  - `user/lib/icons.h` - Added browser (globe) icon
- **Achievement**: VibeOS has a web browser! Can browse HTTP sites with HTML rendering!

### Session 34
- **Refactored browser into multi-file structure:**
  - Split 1400-line `user/bin/browser.c` into modular components
  - New directory: `user/bin/browser/`
  - `str.h` - String helper functions (str_len, str_cpy, str_ncpy, str_eqn, str_ieqn, parse_int)
  - `url.h` - URL parsing (url_t struct, parse_url, resolve_url)
  - `http.h` - HTTP client (http_response_t, http_get, parse_headers, is_redirect)
  - `html.h` - HTML parser (text_block_t, style_state_t, parse_html, entity decoding)
  - `main.c` - Browser UI, rendering, and event loop
- **Updated Makefile for multi-file userspace builds:**
  - Added `USER_PROGS_MULTIFILE` list for programs built from directories
  - Browser compiles from `user/bin/browser/main.c` with all headers
  - Pattern supports future multi-file apps
- **Architecture note:** Used header-only libraries (static inline) for simplicity - no separate .c files needed
- **Achievement**: Browser code now organized and maintainable!
