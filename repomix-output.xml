This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
boot/
  boot.S
kernel/
  libc/
    arpa/
      inet.h
    assert.h
    ctype.h
    errno.h
    limits.h
    signal.h
    stdio.h
    stdlib.h
    string.h
    time.h
    unistd.h
    wchar.h
  console.c
  console.h
  context.S
  cursor.c
  cursor.h
  dtb.c
  dtb.h
  elf.c
  elf.h
  fat32.c
  fat32.h
  fb.c
  fb.h
  font.c
  font.h
  initramfs.c
  initramfs.h
  irq.c
  irq.h
  kapi.c
  kapi.h
  kernel.c
  keyboard.c
  keyboard.h
  memory.c
  memory.h
  mouse.c
  mouse.h
  net.c
  net.h
  printf.c
  printf.h
  process.c
  process.h
  rtc.c
  rtc.h
  shell.c
  shell.h
  string.c
  string.h
  tls.c
  tls.h
  vectors.S
  vfs.c
  vfs.h
  virtio_blk.c
  virtio_blk.h
  virtio_net.c
  virtio_net.h
  virtio_sound.c
  virtio_sound.h
user/
  bin/
    browser.c
    calc.c
    cat.c
    date.c
    desktop.c
    echo.c
    fetch.c
    files.c
    hello.c
    ls.c
    mkdir.c
    music.c
    ping.c
    play.c
    pwd.c
    rm.c
    snake.c
    sysmon.c
    term.c
    tetris.c
    textedit.c
    touch.c
    uptime.c
    vibesh.c
  lib/
    crt0.S
    gfx.h
    icons.h
    stdlib.h
    string.h
    vibe.h
  linker.ld
.gitignore
beep.wav
claude.md
linker.ld
LONGTERM.md
Makefile
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(make:*)",
      "WebSearch",
      "WebFetch(domain:brennan.io)",
      "Bash(aarch64-elf-objdump:*)",
      "Bash(hdiutil detach:*)",
      "Bash(hdiutil attach:*)",
      "Bash(aarch64-elf-readelf:*)",
      "Bash(aarch64-elf-nm:*)",
      "WebFetch(domain:www.qemu.org)",
      "WebFetch(domain:www.haiku-os.org)",
      "WebFetch(domain:www.mail-archive.com)",
      "Bash(xxd:*)",
      "Bash(ls:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="kernel/libc/arpa/inet.h">
/* VibeOS arpa/inet.h stub for TLSe */
#ifndef _ARPA_INET_H
#define _ARPA_INET_H

#include <stdint.h>

// ARM is little-endian, network is big-endian
static inline uint16_t htons(uint16_t x) {
    return ((x & 0xFF) << 8) | ((x >> 8) & 0xFF);
}

static inline uint16_t ntohs(uint16_t x) {
    return htons(x);
}

static inline uint32_t htonl(uint32_t x) {
    return ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) |
           ((x >> 8) & 0xFF00) | ((x >> 24) & 0xFF);
}

static inline uint32_t ntohl(uint32_t x) {
    return htonl(x);
}

#endif
</file>

<file path="kernel/libc/assert.h">
/* VibeOS assert.h stub for TLSe */
#ifndef _ASSERT_H
#define _ASSERT_H

#define assert(x) ((void)0)
#define NDEBUG

#endif
</file>

<file path="kernel/libc/ctype.h">
/* VibeOS ctype.h stub for TLSe */
#ifndef _CTYPE_H
#define _CTYPE_H

static inline int isspace(int c) { return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v'; }
static inline int isdigit(int c) { return c >= '0' && c <= '9'; }
static inline int isxdigit(int c) { return isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }
static inline int isalpha(int c) { return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'); }
static inline int isalnum(int c) { return isalpha(c) || isdigit(c); }
static inline int isupper(int c) { return c >= 'A' && c <= 'Z'; }
static inline int islower(int c) { return c >= 'a' && c <= 'z'; }
static inline int tolower(int c) { return isupper(c) ? c + 32 : c; }
static inline int toupper(int c) { return islower(c) ? c - 32 : c; }
static inline int isprint(int c) { return c >= 32 && c < 127; }

#endif
</file>

<file path="kernel/libc/errno.h">
/* VibeOS errno.h stub for TLSe */
#ifndef _ERRNO_H
#define _ERRNO_H

extern int errno;

#define EINTR 4
#define EAGAIN 11
#define EWOULDBLOCK EAGAIN
#define ENOMEM 12
#define ENOENT 2

#endif
</file>

<file path="kernel/libc/limits.h">
/* VibeOS limits.h stub for TLSe */
#ifndef _LIMITS_H
#define _LIMITS_H

#define CHAR_BIT 8
#define INT_MAX  0x7FFFFFFF
#define INT_MIN  (-INT_MAX - 1)
#define UINT_MAX 0xFFFFFFFFU
#define LONG_MAX 0x7FFFFFFFFFFFFFFFLL
#define LONG_MIN (-LONG_MAX - 1)
#define ULONG_MAX 0xFFFFFFFFFFFFFFFFULL

#endif
</file>

<file path="kernel/libc/signal.h">
/* VibeOS signal.h stub for TLSe */
#ifndef _SIGNAL_H
#define _SIGNAL_H

#define SIG_IGN  ((void (*)(int))1)
#define SIG_DFL  ((void (*)(int))0)
#define SIG_ERR  ((void (*)(int))-1)

#define SIGABRT 6
#define SIGFPE  8
#define SIGILL  4
#define SIGINT  2
#define SIGSEGV 11
#define SIGTERM 15
#define SIGPIPE 13

// Stub
static inline void (*signal(int sig, void (*handler)(int)))(int) {
    (void)sig;
    (void)handler;
    return SIG_IGN;
}

static inline int raise(int sig) { (void)sig; return 0; }

#endif
</file>

<file path="kernel/libc/stdio.h">
/* VibeOS stdio.h stub for TLSe */
#ifndef _STDIO_H
#define _STDIO_H

#include <stddef.h>
#include <stdarg.h>

typedef void FILE;
#define stderr ((FILE*)0)
#define stdout ((FILE*)0)
#define stdin  ((FILE*)0)

#define EOF (-1)
#define _IONBF 2
#define _IOLBF 1
#define _IOFBF 0

// Stubs
static inline int setvbuf(FILE *f, char *buf, int mode, size_t size) { (void)f; (void)buf; (void)mode; (void)size; return 0; }
static inline int fprintf(FILE *f, const char *fmt, ...) { (void)f; (void)fmt; return 0; }
static inline int printf(const char *fmt, ...) { (void)fmt; return 0; }
static inline int sprintf(char *buf, const char *fmt, ...) { (void)fmt; buf[0] = '\0'; return 0; }
static inline int snprintf(char *buf, size_t size, const char *fmt, ...) { (void)fmt; if (size > 0) buf[0] = '\0'; return 0; }
static inline int fflush(FILE *f) { (void)f; return 0; }
static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) { (void)ptr; (void)stream; return size * nmemb; }
static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) { (void)ptr; (void)stream; (void)size; (void)nmemb; return 0; }
static inline FILE *fopen(const char *path, const char *mode) { (void)path; (void)mode; return 0; }
static inline int fclose(FILE *f) { (void)f; return 0; }
static inline void perror(const char *s) { (void)s; }
static inline int fgetc(FILE *f) { (void)f; return EOF; }
static inline int fputc(int c, FILE *f) { (void)c; (void)f; return c; }
static inline int fputs(const char *s, FILE *f) { (void)s; (void)f; return 0; }
static inline int getc(FILE *f) { (void)f; return EOF; }
static inline int putc(int c, FILE *f) { (void)c; (void)f; return c; }

#endif
</file>

<file path="kernel/libc/stdlib.h">
/* VibeOS stdlib.h stub for TLSe */
#ifndef _STDLIB_H
#define _STDLIB_H

#include <stddef.h>

// These are provided by our kernel
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
void *calloc(size_t nmemb, size_t size);

// Stubs
static inline int atoi(const char *s) {
    int n = 0, neg = 0;
    while (*s == ' ' || *s == '\t') s++;
    if (*s == '-') { neg = 1; s++; }
    else if (*s == '+') { s++; }
    while (*s >= '0' && *s <= '9') { n = n * 10 + (*s++ - '0'); }
    return neg ? -n : n;
}

static inline long atol(const char *s) {
    return (long)atoi(s);
}

static inline void abort(void) { while (1) {} }
static inline void exit(int code) { (void)code; abort(); }

static inline void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)) {
    (void)base; (void)nmemb; (void)size; (void)compar;
}

static inline int abs(int x) { return x < 0 ? -x : x; }
static inline long labs(long x) { return x < 0 ? -x : x; }

// Basic LCG random - not secure at all
static unsigned int _stdlib_rand_seed = 1;
static inline int rand(void) {
    _stdlib_rand_seed = _stdlib_rand_seed * 1103515245 + 12345;
    return (_stdlib_rand_seed >> 16) & 0x7FFF;
}
static inline void srand(unsigned int seed) { _stdlib_rand_seed = seed; }

#define NULL ((void *)0)
#define RAND_MAX 0x7FFF

#endif
</file>

<file path="kernel/libc/string.h">
/* VibeOS string.h stub for TLSe */
#ifndef _STRING_H
#define _STRING_H

#include <stddef.h>

// These are provided by our kernel (kernel/string.c)
void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
void *memmove(void *dest, const void *src, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
size_t strlen(const char *s);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strcat(char *dest, const char *src);
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
int strcasecmp(const char *s1, const char *s2);
char *strstr(const char *haystack, const char *needle);
void *memchr(const void *s, int c, size_t n);

#endif
</file>

<file path="kernel/libc/time.h">
/* VibeOS time.h stub for TLSe */
#ifndef _TIME_H
#define _TIME_H

#include <stdint.h>
#include <stddef.h>

typedef uint32_t time_t;
typedef uint32_t clock_t;

#define CLOCKS_PER_SEC 1000000

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};

struct timespec {
    time_t tv_sec;
    long tv_nsec;
};

// Will be defined in tls.c
time_t time(time_t *t);
struct tm *gmtime(const time_t *t);

// Stub
static inline clock_t clock(void) { return 0; }
static inline double difftime(time_t t1, time_t t0) { return (double)(t1 - t0); }
static inline time_t mktime(struct tm *tm) { (void)tm; return 0; }
static inline int nanosleep(const struct timespec *req, struct timespec *rem) { (void)req; (void)rem; return 0; }

#endif
</file>

<file path="kernel/libc/unistd.h">
/* VibeOS unistd.h stub for TLSe */
#ifndef _UNISTD_H
#define _UNISTD_H

#include <stddef.h>

// Stub
static inline int close(int fd) { (void)fd; return 0; }

#endif
</file>

<file path="kernel/libc/wchar.h">
/* VibeOS wchar.h stub for TLSe */
#ifndef _WCHAR_H
#define _WCHAR_H

#include <stddef.h>

// wchar_t is already defined in stddef.h from compiler
// Don't redefine it

#endif
</file>

<file path="kernel/tls.c">
/*
 * VibeOS TLS Implementation
 *
 * Wraps TLSe library for HTTPS support.
 * Uses our TCP stack for transport.
 */

// TLSe configuration - must come before includes
#define TLS_AMALGAMATION          // Use bundled libtomcrypt
#define NO_SSL_COMPATIBLE_INTERFACE  // Don't need SSL_* API
// #define NO_TLS_LEGACY_SUPPORT     // Need TLS 1.2 support
#define LTM_DESC                  // Use libtommath

// Provide our own random source - must fill buffer AND return 1
#define TLS_USE_RANDOM_SOURCE(key, len) do { vibe_random(key, len); } while(0); return 1

// ============ Safe unaligned memory access helpers ============
// ARM requires aligned access for multi-byte stores. TLSe does
// things like *(unsigned short *)(buf+1) which crashes on ARM.
// These helpers do byte-by-byte access instead.

static inline void store_u16_unaligned(void *ptr, unsigned short val) {
    unsigned char *p = (unsigned char *)ptr;
    p[0] = (val >> 8) & 0xFF;   // Big endian (network byte order)
    p[1] = val & 0xFF;
}

static inline void store_u16_le_unaligned(void *ptr, unsigned short val) {
    unsigned char *p = (unsigned char *)ptr;
    p[0] = val & 0xFF;          // Little endian
    p[1] = (val >> 8) & 0xFF;
}

static inline void store_u32_unaligned(void *ptr, unsigned int val) {
    unsigned char *p = (unsigned char *)ptr;
    p[0] = (val >> 24) & 0xFF;  // Big endian
    p[1] = (val >> 16) & 0xFF;
    p[2] = (val >> 8) & 0xFF;
    p[3] = val & 0xFF;
}

static inline unsigned short load_u16_unaligned(const void *ptr) {
    const unsigned char *p = (const unsigned char *)ptr;
    return (p[0] << 8) | p[1];  // Big endian
}

static inline unsigned int load_u32_unaligned(const void *ptr) {
    const unsigned char *p = (const unsigned char *)ptr;
    return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];  // Big endian
}

// Standard types (from compiler)
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>

// Libc stubs (in kernel/libc/)
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <signal.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <arpa/inet.h>

// Our kernel headers
#include "memory.h"
#include "rtc.h"
#include "irq.h"
#include "net.h"
#include "tls.h"

// Forward declaration
extern void sleep_ms(uint32_t ms);

// Forward declarations for kernel functions
extern void uart_puts(const char *s);
extern unsigned long timer_get_ticks(void);

// errno global (declared in errno.h)
int errno = 0;

// ============ Implementations for time.h ============

time_t time(time_t *t) {
    uint32_t ts = rtc_get_timestamp();
    if (t) *t = ts;
    return ts;
}

static struct tm _tm_buf;
struct tm *gmtime(const time_t *t) {
    uint32_t ts = t ? *t : 0;
    _tm_buf.tm_sec = ts % 60; ts /= 60;
    _tm_buf.tm_min = ts % 60; ts /= 60;
    _tm_buf.tm_hour = ts % 24; ts /= 24;
    _tm_buf.tm_year = 70 + (ts / 365);
    _tm_buf.tm_mon = 0;
    _tm_buf.tm_mday = 1;
    _tm_buf.tm_wday = 0;
    _tm_buf.tm_yday = 0;
    _tm_buf.tm_isdst = 0;
    return &_tm_buf;
}

// ============ Random number generator for TLS ============

static void vibe_random(unsigned char *key, int len) {
    static uint32_t seed = 0;
    if (seed == 0) {
        seed = rtc_get_timestamp() ^ timer_get_ticks();
    }
    for (int i = 0; i < len; i++) {
        seed = seed * 1103515245 + 12345;
        key[i] = (seed >> 16) & 0xFF;
        if ((i & 0xF) == 0) seed ^= timer_get_ticks();
    }
}

// ============ Now include TLSe ============

// Suppress warnings from third-party code
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#pragma GCC diagnostic ignored "-Wpointer-sign"
#pragma GCC diagnostic ignored "-Wold-style-declaration"
#pragma GCC diagnostic ignored "-Wtype-limits"
#endif

#include "../vendor/tlse/tlse.c"

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

// ============ VibeOS TLS API ============

#define MAX_TLS_SOCKETS 4

typedef struct {
    int tcp_sock;
    struct TLSContext *ctx;
    int connected;
    int closed;
} tls_socket_internal_t;

static tls_socket_internal_t tls_sockets[MAX_TLS_SOCKETS];
static int tls_initialized = 0;

void tls_init_lib(void) {
    if (!tls_initialized) {
        tls_init();
        memset(tls_sockets, 0, sizeof(tls_sockets));
        tls_initialized = 1;
        uart_puts("TLS: Initialized\r\n");
    }
}

int tls_connect(uint32_t ip, uint16_t port, const char *hostname) {
    if (!tls_initialized) tls_init_lib();

    // Find free slot
    int slot = -1;
    for (int i = 0; i < MAX_TLS_SOCKETS; i++) {
        if (tls_sockets[i].ctx == NULL) { slot = i; break; }
    }
    if (slot < 0) return -1;

    // TCP connect
    int tcp = tcp_connect(ip, port);
    if (tcp < 0) return -1;

    // Create TLS context
    struct TLSContext *ctx = tls_create_context(0, TLS_V12);
    if (!ctx) { tcp_close(tcp); return -1; }

    if (hostname && hostname[0]) {
        tls_sni_set(ctx, hostname);
    }

    tls_sockets[slot].tcp_sock = tcp;
    tls_sockets[slot].ctx = ctx;
    tls_sockets[slot].connected = 0;
    tls_sockets[slot].closed = 0;

    // Start handshake
    tls_client_connect(ctx);

    // Send ClientHello
    unsigned int out_len = 0;
    const unsigned char *out_buf = tls_get_write_buffer(ctx, &out_len);
    if (out_buf && out_len > 0) {
        uart_puts("[TLS] Sending ClientHello (");
        // Print length
        char lenbuf[16];
        int i = 0;
        unsigned int tmp = out_len;
        if (tmp == 0) lenbuf[i++] = '0';
        else {
            char rev[16];
            int j = 0;
            while (tmp > 0) { rev[j++] = '0' + (tmp % 10); tmp /= 10; }
            while (j > 0) lenbuf[i++] = rev[--j];
        }
        lenbuf[i] = 0;
        uart_puts(lenbuf);
        uart_puts(" bytes)\r\n");

        int sent = tcp_send(tcp, out_buf, out_len);
        if (sent < 0) {
            uart_puts("[TLS] Failed to send ClientHello!\r\n");
        }
        tls_buffer_clear(ctx);
    } else {
        uart_puts("[TLS] No ClientHello generated!\r\n");
    }

    // Handshake loop
    unsigned char recv_buf[4096];
    int max_rounds = 50;

    uart_puts("[TLS] Starting handshake...\r\n");

    while (!tls_established(ctx) && max_rounds-- > 0) {
        net_poll();

        int recv_len = tcp_recv(tcp, recv_buf, sizeof(recv_buf));
        if (recv_len > 0) {
            // Print received length
            uart_puts("[TLS] Got ");
            char lbuf[16];
            int v = recv_len; int i = 0;
            if (v == 0) lbuf[i++] = '0';
            else { char r[16]; int j=0; while(v>0){r[j++]='0'+(v%10);v/=10;} while(j>0)lbuf[i++]=r[--j]; }
            lbuf[i] = 0;
            uart_puts(lbuf);
            uart_puts(" bytes, consuming...\r\n");

            // Dump first 16 bytes of received data
            uart_puts("[TLS] First 16 bytes: ");
            for (int d = 0; d < 16 && d < recv_len; d++) {
                char hex[4];
                hex[0] = "0123456789ABCDEF"[(recv_buf[d] >> 4) & 0xF];
                hex[1] = "0123456789ABCDEF"[recv_buf[d] & 0xF];
                hex[2] = ' ';
                hex[3] = 0;
                uart_puts(hex);
            }
            uart_puts("\r\n");

            int consumed = tls_consume_stream(ctx, recv_buf, recv_len, NULL);

            // Print consume result and error code if any
            if (consumed < 0) {
                uart_puts("[TLS] ERROR! critical_error=");
                char eb[8];
                eb[0] = '0' + (ctx->critical_error % 10);
                eb[1] = 0;
                uart_puts(eb);
                uart_puts(" error_code=");
                int ec = ctx->error_code;
                eb[0] = '0' + (ec / 100) % 10;
                eb[1] = '0' + (ec / 10) % 10;
                eb[2] = '0' + ec % 10;
                eb[3] = 0;
                uart_puts(eb);
                uart_puts(" conn_status=");
                eb[0] = '0' + (ctx->connection_status / 100) % 10;
                eb[1] = '0' + (ctx->connection_status / 10) % 10;
                eb[2] = '0' + ctx->connection_status % 10;
                eb[3] = 0;
                uart_puts(eb);
                uart_puts("\r\n");
            }
            uart_puts("[TLS] consume returned: ");
            v = consumed < 0 ? -consumed : consumed; i = 0;
            if (v == 0) lbuf[i++] = '0';
            else { char r[16]; int j=0; while(v>0){r[j++]='0'+(v%10);v/=10;} while(j>0)lbuf[i++]=r[--j]; }
            lbuf[i] = 0;
            if (consumed < 0) uart_puts("-");
            uart_puts(lbuf);
            uart_puts("\r\n");

            if (consumed < 0) {
                tls_destroy_context(ctx);
                tcp_close(tcp);
                tls_sockets[slot].ctx = NULL;
                return -1;
            }

            out_buf = tls_get_write_buffer(ctx, &out_len);
            if (out_buf && out_len > 0) {
                uart_puts("[TLS] Sending handshake response...\r\n");
                tcp_send(tcp, out_buf, out_len);
                tls_buffer_clear(ctx);
            }

            // Print handshake state
            if (tls_established(ctx)) {
                uart_puts("[TLS] Connection established!\r\n");
            }
        } else if (recv_len < 0) {
            uart_puts("[TLS] TCP recv failed during handshake\r\n");
            tls_destroy_context(ctx);
            tcp_close(tcp);
            tls_sockets[slot].ctx = NULL;
            return -1;
        }

        // Small delay
        sleep_ms(10);
    }

    if (!tls_established(ctx)) {
        uart_puts("[TLS] Handshake timed out\r\n");
        tls_destroy_context(ctx);
        tcp_close(tcp);
        tls_sockets[slot].ctx = NULL;
        return -1;
    }

    uart_puts("[TLS] Handshake complete!\r\n");

    tls_sockets[slot].connected = 1;
    return slot;
}

int tls_send(int sock, const void *data, uint32_t len) {
    if (sock < 0 || sock >= MAX_TLS_SOCKETS) return -1;
    tls_socket_internal_t *s = &tls_sockets[sock];
    if (!s->ctx || !s->connected || s->closed) return -1;

    tls_write(s->ctx, data, len);

    unsigned int out_len = 0;
    const unsigned char *out_buf = tls_get_write_buffer(s->ctx, &out_len);
    if (out_buf && out_len > 0) {
        int sent = tcp_send(s->tcp_sock, out_buf, out_len);
        tls_buffer_clear(s->ctx);
        if (sent < 0) return -1;
    }

    return len;
}

int tls_recv(int sock, void *buf, uint32_t maxlen) {
    if (sock < 0 || sock >= MAX_TLS_SOCKETS) return -1;
    tls_socket_internal_t *s = &tls_sockets[sock];
    if (!s->ctx || s->closed) return -1;

    // Check for buffered data
    int decrypted = tls_read(s->ctx, buf, maxlen);
    if (decrypted > 0) return decrypted;

    net_poll();

    unsigned char recv_buf[4096];
    int recv_len = tcp_recv(s->tcp_sock, recv_buf, sizeof(recv_buf));

    if (recv_len > 0) {
        int consumed = tls_consume_stream(s->ctx, recv_buf, recv_len, NULL);
        if (consumed < 0) { s->closed = 1; return -1; }

        unsigned int out_len = 0;
        const unsigned char *out_buf = tls_get_write_buffer(s->ctx, &out_len);
        if (out_buf && out_len > 0) {
            tcp_send(s->tcp_sock, out_buf, out_len);
            tls_buffer_clear(s->ctx);
        }

        decrypted = tls_read(s->ctx, buf, maxlen);
        if (decrypted > 0) return decrypted;
    } else if (recv_len < 0) {
        s->closed = 1;
        return -1;
    }

    return 0;
}

void tls_close(int sock) {
    if (sock < 0 || sock >= MAX_TLS_SOCKETS) return;
    tls_socket_internal_t *s = &tls_sockets[sock];
    if (!s->ctx) return;

    if (s->connected && !s->closed) {
        tls_close_notify(s->ctx);
        unsigned int out_len = 0;
        const unsigned char *out_buf = tls_get_write_buffer(s->ctx, &out_len);
        if (out_buf && out_len > 0) {
            tcp_send(s->tcp_sock, out_buf, out_len);
            tls_buffer_clear(s->ctx);
        }
    }

    tcp_close(s->tcp_sock);
    tls_destroy_context(s->ctx);
    memset(s, 0, sizeof(*s));
}

int tls_is_connected(int sock) {
    if (sock < 0 || sock >= MAX_TLS_SOCKETS) return 0;
    tls_socket_internal_t *s = &tls_sockets[sock];
    return s->ctx && s->connected && !s->closed && tcp_is_connected(s->tcp_sock);
}
</file>

<file path="kernel/tls.h">
/*
 * VibeOS TLS
 *
 * Simple TLS client API wrapping TLSe
 */

#ifndef TLS_H
#define TLS_H

#include <stdint.h>
#include <stddef.h>

// Initialize TLS library
void tls_init_lib(void);

// Connect to a TLS server
// ip: destination IP address (network byte order handled internally)
// port: destination port (443 for HTTPS)
// hostname: server name for SNI (can be NULL)
// Returns: socket handle (>=0) or -1 on error
int tls_connect(uint32_t ip, uint16_t port, const char *hostname);

// Send data over TLS connection
// Returns: bytes sent, or -1 on error
int tls_send(int sock, const void *data, uint32_t len);

// Receive data over TLS connection
// Returns: bytes received, 0 if no data yet, -1 on error/closed
int tls_recv(int sock, void *buf, uint32_t maxlen);

// Close TLS connection
void tls_close(int sock);

// Check if TLS socket is connected
int tls_is_connected(int sock);

#endif
</file>

<file path="kernel/console.h">
/*
 * VibeOS Text Console
 *
 * Terminal-like text output on framebuffer
 */

#ifndef CONSOLE_H
#define CONSOLE_H

#include <stdint.h>

// Initialize console
void console_init(void);

// Output
void console_putc(char c);
void console_puts(const char *s);
void console_clear(void);

// Cursor
void console_set_cursor(int row, int col);
void console_get_cursor(int *row, int *col);

// Colors
void console_set_color(uint32_t fg, uint32_t bg);

// Console dimensions (in characters)
int console_rows(void);
int console_cols(void);

#endif
</file>

<file path="kernel/cursor.c">
/*
 * VibeOS Mouse Cursor
 *
 * Classic Mac-style arrow cursor with save/restore of background
 */

#include "cursor.h"
#include "mouse.h"
#include "fb.h"

// Cursor dimensions
#define CURSOR_WIDTH 12
#define CURSOR_HEIGHT 19

// Classic Mac arrow cursor (1 = black, 2 = white, 0 = transparent)
static const uint8_t cursor_data[CURSOR_HEIGHT][CURSOR_WIDTH] = {
    {1,0,0,0,0,0,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0,0,0,0,0},
    {1,2,1,0,0,0,0,0,0,0,0,0},
    {1,2,2,1,0,0,0,0,0,0,0,0},
    {1,2,2,2,1,0,0,0,0,0,0,0},
    {1,2,2,2,2,1,0,0,0,0,0,0},
    {1,2,2,2,2,2,1,0,0,0,0,0},
    {1,2,2,2,2,2,2,1,0,0,0,0},
    {1,2,2,2,2,2,2,2,1,0,0,0},
    {1,2,2,2,2,2,2,2,2,1,0,0},
    {1,2,2,2,2,2,2,2,2,2,1,0},
    {1,2,2,2,2,2,2,1,1,1,1,1},
    {1,2,2,2,1,2,2,1,0,0,0,0},
    {1,2,2,1,0,1,2,2,1,0,0,0},
    {1,2,1,0,0,1,2,2,1,0,0,0},
    {1,1,0,0,0,0,1,2,2,1,0,0},
    {1,0,0,0,0,0,1,2,2,1,0,0},
    {0,0,0,0,0,0,0,1,2,1,0,0},
    {0,0,0,0,0,0,0,1,1,0,0,0},
};

// Saved background under cursor
static uint32_t saved_bg[CURSOR_HEIGHT][CURSOR_WIDTH];
static int saved_x = -1;
static int saved_y = -1;
static int cursor_visible = 0;

// Current cursor position
static int cursor_x = 0;
static int cursor_y = 0;

// Access framebuffer
extern uint32_t fb_width, fb_height;
extern uint32_t *fb_base;

// Save the background pixels under cursor
static void save_background(int x, int y) {
    for (int row = 0; row < CURSOR_HEIGHT; row++) {
        for (int col = 0; col < CURSOR_WIDTH; col++) {
            int px = x + col;
            int py = y + row;
            if (px >= 0 && px < (int)fb_width && py >= 0 && py < (int)fb_height) {
                saved_bg[row][col] = fb_base[py * fb_width + px];
            }
        }
    }
    saved_x = x;
    saved_y = y;
}

// Restore the background pixels
static void restore_background(void) {
    if (saved_x < 0) return;

    for (int row = 0; row < CURSOR_HEIGHT; row++) {
        for (int col = 0; col < CURSOR_WIDTH; col++) {
            int px = saved_x + col;
            int py = saved_y + row;
            if (px >= 0 && px < (int)fb_width && py >= 0 && py < (int)fb_height) {
                fb_base[py * fb_width + px] = saved_bg[row][col];
            }
        }
    }
    saved_x = -1;
}

// Draw the cursor at position
static void draw_cursor_at(int x, int y) {
    for (int row = 0; row < CURSOR_HEIGHT; row++) {
        for (int col = 0; col < CURSOR_WIDTH; col++) {
            uint8_t pixel = cursor_data[row][col];
            if (pixel == 0) continue;  // Transparent

            int px = x + col;
            int py = y + row;
            if (px >= 0 && px < (int)fb_width && py >= 0 && py < (int)fb_height) {
                uint32_t color = (pixel == 1) ? 0x00000000 : 0x00FFFFFF;  // Black or white
                fb_base[py * fb_width + px] = color;
            }
        }
    }
}

void cursor_init(void) {
    cursor_x = fb_width / 2;
    cursor_y = fb_height / 2;
    cursor_visible = 0;
    saved_x = -1;
}

void cursor_show(void) {
    if (!cursor_visible) {
        save_background(cursor_x, cursor_y);
        draw_cursor_at(cursor_x, cursor_y);
        cursor_visible = 1;
    }
}

void cursor_hide(void) {
    if (cursor_visible) {
        restore_background();
        cursor_visible = 0;
    }
}

void cursor_update(void) {
    int new_x, new_y;
    mouse_get_screen_pos(&new_x, &new_y);

    // Only update if position changed
    if (new_x == cursor_x && new_y == cursor_y) {
        return;
    }

    // Hide old cursor (restore background)
    if (cursor_visible) {
        restore_background();
    }

    // Update position
    cursor_x = new_x;
    cursor_y = new_y;

    // Draw new cursor
    if (cursor_visible) {
        save_background(cursor_x, cursor_y);
        draw_cursor_at(cursor_x, cursor_y);
    }
}

void cursor_draw(int x, int y) {
    cursor_x = x;
    cursor_y = y;
    if (cursor_visible) {
        restore_background();
    }
    save_background(x, y);
    draw_cursor_at(x, y);
    cursor_visible = 1;
}

void cursor_get_pos(int *x, int *y) {
    if (x) *x = cursor_x;
    if (y) *y = cursor_y;
}
</file>

<file path="kernel/cursor.h">
/*
 * VibeOS Mouse Cursor
 *
 * Handles drawing and updating the mouse cursor
 */

#ifndef CURSOR_H
#define CURSOR_H

#include <stdint.h>

// Initialize cursor system
void cursor_init(void);

// Show/hide cursor
void cursor_show(void);
void cursor_hide(void);

// Update cursor position and redraw
void cursor_update(void);

// Draw cursor at specific position (for direct control)
void cursor_draw(int x, int y);

// Get cursor position
void cursor_get_pos(int *x, int *y);

#endif
</file>

<file path="kernel/dtb.c">
/*
 * VibeOS Device Tree Blob (DTB) Parser
 *
 * Minimal DTB parser to detect RAM size at boot.
 * Reference: https://devicetree-specification.readthedocs.io/en/stable/flattened-format.html
 */

#include "dtb.h"
#include "string.h"
#include "printf.h"

static const char *dtb_error = "No error";

// Read big-endian 32-bit from potentially unaligned address
static uint32_t read_be32(const uint8_t *p) {
    return ((uint32_t)p[0] << 24) | ((uint32_t)p[1] << 16) |
           ((uint32_t)p[2] << 8) | (uint32_t)p[3];
}

// Read big-endian 64-bit from potentially unaligned address
static uint64_t read_be64(const uint8_t *p) {
    return ((uint64_t)p[0] << 56) | ((uint64_t)p[1] << 48) |
           ((uint64_t)p[2] << 40) | ((uint64_t)p[3] << 32) |
           ((uint64_t)p[4] << 24) | ((uint64_t)p[5] << 16) |
           ((uint64_t)p[6] << 8) | (uint64_t)p[7];
}

// Align up to 4-byte boundary
static uint32_t align4(uint32_t offset) {
    return (offset + 3) & ~3;
}

// Compare strings (for property/node name matching)
static int str_eq(const char *a, const char *b) {
    while (*a && *b) {
        if (*a != *b) return 0;
        a++;
        b++;
    }
    return *a == *b;
}

// Check if string starts with prefix
static int str_starts_with(const char *str, const char *prefix) {
    while (*prefix) {
        if (*str != *prefix) return 0;
        str++;
        prefix++;
    }
    return 1;
}

const char *dtb_get_error(void) {
    return dtb_error;
}

int dtb_parse(void *dtb_addr, struct dtb_memory_info *mem_info) {
    uint8_t *hdr = (uint8_t *)dtb_addr;

    // Initialize output
    mem_info->base = 0;
    mem_info->size = 0;

    // Validate magic (offset 0x00)
    uint32_t magic = read_be32(hdr + 0x00);
    if (magic != DTB_MAGIC) {
        dtb_error = "Invalid DTB magic";
        printf("[DTB] Invalid magic: 0x%x (expected 0x%x)\n", magic, DTB_MAGIC);
        return -1;
    }

    // Read header fields (all at known offsets)
    uint32_t totalsize = read_be32(hdr + 0x04);
    uint32_t off_struct = read_be32(hdr + 0x08);
    uint32_t off_strings = read_be32(hdr + 0x0C);
    uint32_t version = read_be32(hdr + 0x14);

    printf("[DTB] Found valid DTB at %p\n", dtb_addr);
    printf("[DTB] Version: %d, Size: %d bytes\n", version, totalsize);

    uint8_t *base = (uint8_t *)dtb_addr;
    uint8_t *struct_block = base + off_struct;
    char *strings_block = (char *)(base + off_strings);

    // Parse structure block
    uint32_t offset = 0;
    int depth = 0;
    int in_memory_node = 0;
    int in_root = 0;
    uint32_t root_addr_cells = 2;  // Default for 64-bit
    uint32_t root_size_cells = 1;  // Default

    while (1) {
        uint32_t token = read_be32(struct_block + offset);
        offset += 4;

        if (token == FDT_END) {
            break;
        }

        switch (token) {
            case FDT_BEGIN_NODE: {
                // Node name follows (null-terminated, then padded to 4 bytes)
                char *name = (char *)(struct_block + offset);
                uint32_t name_len = strlen(name) + 1;  // Include null terminator
                offset = align4(offset + name_len);

                depth++;

                // Root node has empty name
                if (depth == 1 && name[0] == '\0') {
                    in_root = 1;
                }

                // Check for memory node (could be "memory" or "memory@...")
                if (depth == 2 && (str_eq(name, "memory") || str_starts_with(name, "memory@"))) {
                    in_memory_node = 1;
                    printf("[DTB] Found memory node: %s\n", name[0] ? name : "(root)");
                }
                break;
            }

            case FDT_END_NODE: {
                if (depth == 2) {
                    in_memory_node = 0;
                }
                if (depth == 1) {
                    in_root = 0;
                }
                depth--;
                break;
            }

            case FDT_PROP: {
                // Property: len (4 bytes), nameoff (4 bytes), value (len bytes, padded)
                uint32_t len = read_be32(struct_block + offset);
                offset += 4;
                uint32_t nameoff = read_be32(struct_block + offset);
                offset += 4;

                char *prop_name = strings_block + nameoff;
                uint8_t *prop_value = struct_block + offset;

                // Check for #address-cells and #size-cells in root node
                if (in_root && depth == 1) {
                    if (str_eq(prop_name, "#address-cells") && len == 4) {
                        root_addr_cells = read_be32(prop_value);
                    } else if (str_eq(prop_name, "#size-cells") && len == 4) {
                        root_size_cells = read_be32(prop_value);
                    }
                }

                // Check for reg property in memory node
                if (in_memory_node && str_eq(prop_name, "reg")) {
                    printf("[DTB] Memory reg: addr_cells=%d, size_cells=%d, len=%d\n",
                           root_addr_cells, root_size_cells, len);

                    // Extract base address
                    if (root_addr_cells == 2) {
                        mem_info->base = read_be64(prop_value);
                        prop_value += 8;
                    } else {
                        mem_info->base = read_be32(prop_value);
                        prop_value += 4;
                    }

                    // Extract size
                    if (root_size_cells == 2) {
                        mem_info->size = read_be64(prop_value);
                    } else {
                        mem_info->size = read_be32(prop_value);
                    }

                    printf("[DTB] Memory: base=0x%lx, size=0x%lx (%lu MB)\n",
                           mem_info->base, mem_info->size, mem_info->size / (1024 * 1024));
                }

                offset = align4(offset + len);
                break;
            }

            case FDT_NOP: {
                // Skip NOP tokens
                break;
            }

            default: {
                dtb_error = "Unknown token in DTB";
                printf("[DTB] Unknown token: 0x%x at offset %d\n", token, offset - 4);
                return -1;
            }
        }
    }

    if (mem_info->size == 0) {
        dtb_error = "No memory node found";
        return -1;
    }

    dtb_error = "Success";
    return 0;
}
</file>

<file path="kernel/dtb.h">
/*
 * VibeOS Device Tree Blob (DTB) Parser
 *
 * Parses the flattened device tree to detect hardware configuration,
 * most importantly RAM size.
 */

#ifndef DTB_H
#define DTB_H

#include <stdint.h>

// DTB location - QEMU places it at start of RAM (0x40000000)
// Our linker script starts data/BSS at 0x40010000 to avoid overwriting it
#define DTB_ADDR 0x40000000

// DTB magic number (big-endian: 0xd00dfeed)
#define DTB_MAGIC 0xd00dfeed

// DTB tokens
#define FDT_BEGIN_NODE  0x00000001
#define FDT_END_NODE    0x00000002
#define FDT_PROP        0x00000003
#define FDT_NOP         0x00000004
#define FDT_END         0x00000009

// DTB header structure (all fields are big-endian)
struct fdt_header {
    uint32_t magic;
    uint32_t totalsize;
    uint32_t off_dt_struct;
    uint32_t off_dt_strings;
    uint32_t off_mem_rsvmap;
    uint32_t version;
    uint32_t last_comp_version;
    uint32_t boot_cpuid_phys;
    uint32_t size_dt_strings;
    uint32_t size_dt_struct;
};

// Memory region info
struct dtb_memory_info {
    uint64_t base;
    uint64_t size;
};

// Parse DTB and extract memory information
// Returns 0 on success, -1 on failure
int dtb_parse(void *dtb_addr, struct dtb_memory_info *mem_info);

// Get a human-readable description of parsing result
const char *dtb_get_error(void);

#endif
</file>

<file path="kernel/font.c">
/*
 * VibeOS Bitmap Font
 *
 * 8x16 VGA-style font. Each character is 8 pixels wide, 16 pixels tall.
 * Each byte represents one row, MSB is leftmost pixel.
 */

#include "font.h"

const uint8_t font_data[256][16] = {
    // 0x00 - NULL (blank)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x01-0x1F - Control characters (blank)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x20 - Space
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x21 - !
    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x22 - "
    {0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x23 - #
    {0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00},
    // 0x24 - $
    {0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00},
    // 0x25 - %
    {0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00},
    // 0x26 - &
    {0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 0x27 - '
    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x28 - (
    {0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00},
    // 0x29 - )
    {0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00},
    // 0x2A - *
    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x2B - +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x2C - ,
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00},
    // 0x2D - -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x2E - .
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x2F - /
    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},
    // 0x30 - 0
    {0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x31 - 1
    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00},
    // 0x32 - 2
    {0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 0x33 - 3
    {0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x34 - 4
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},
    // 0x35 - 5
    {0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x36 - 6
    {0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x37 - 7
    {0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00},
    // 0x38 - 8
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x39 - 9
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00},
    // 0x3A - :
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x3B - ;
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // 0x3C - <
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},
    // 0x3D - =
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x3E - >
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},
    // 0x3F - ?
    {0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x40 - @
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00},
    // 0x41 - A
    {0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 0x42 - B
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00},
    // 0x43 - C
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 0x44 - D
    {0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00},
    // 0x45 - E
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00},
    // 0x46 - F
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 0x47 - G
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00},
    // 0x48 - H
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 0x49 - I
    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 0x4A - J
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00},
    // 0x4B - K
    {0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 0x4C - L
    {0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00},
    // 0x4D - M
    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 0x4E - N
    {0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 0x4F - O
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x50 - P
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 0x51 - Q
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00},
    // 0x52 - R
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 0x53 - S
    {0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x54 - T
    {0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 0x55 - U
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x56 - V
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00},
    // 0x57 - W
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00},
    // 0x58 - X
    {0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 0x59 - Y
    {0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 0x5A - Z
    {0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 0x5B - [
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00},
    // 0x5C - backslash
    {0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00},
    // 0x5D - ]
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00},
    // 0x5E - ^
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x5F - _
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
    // 0x60 - `
    {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x61 - a
    {0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 0x62 - b
    {0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // 0x63 - c
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x64 - d
    {0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 0x65 - e
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x66 - f
    {0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 0x67 - g
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00},
    // 0x68 - h
    {0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 0x69 - i
    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 0x6A - j
    {0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00},
    // 0x6B - k
    {0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 0x6C - l
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 0x6D - m
    {0x00,0x00,0x00,0x00,0x00,0xE6,0xFF,0xDB,0xDB,0xDB,0xDB,0xDB,0x00,0x00,0x00,0x00},
    // 0x6E - n
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // 0x6F - o
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x70 - p
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00},
    // 0x71 - q
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00},
    // 0x72 - r
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 0x73 - s
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 0x74 - t
    {0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00},
    // 0x75 - u
    {0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 0x76 - v
    {0x00,0x00,0x00,0x00,0x00,0xC3,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x00,0x00,0x00,0x00},
    // 0x77 - w
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00},
    // 0x78 - x
    {0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00},
    // 0x79 - y
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00},
    // 0x7A - z
    {0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 0x7B - {
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00},
    // 0x7C - |
    {0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x7D - }
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00},
    // 0x7E - ~
    {0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x7F-0xFF - Extended (fill with blank for now)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};
</file>

<file path="kernel/font.h">
/*
 * VibeOS Bitmap Font
 *
 * 8x16 monospace font for console display
 */

#ifndef FONT_H
#define FONT_H

#include <stdint.h>

#define FONT_WIDTH  8
#define FONT_HEIGHT 16

// Font data - 256 characters, 16 bytes each (one byte per row)
extern const uint8_t font_data[256][16];

#endif
</file>

<file path="kernel/initramfs.c">
/*
 * VibeOS Initramfs
 *
 * Monolith kernel - no external programs to load!
 * Everything is built into the shell.
 */

#include "initramfs.h"
#include "printf.h"

void initramfs_init(void) {
    printf("[INITRAMFS] Monolith kernel - all commands built-in!\n");
}
</file>

<file path="kernel/initramfs.h">
/*
 * VibeOS Initramfs - Embedded binaries
 */

#ifndef INITRAMFS_H
#define INITRAMFS_H

// Initialize embedded binaries into VFS
void initramfs_init(void);

#endif
</file>

<file path="kernel/printf.c">
/*
 * VibeOS Printf Implementation
 *
 * Supports: %d, %u, %x, %X, %s, %c, %p, %%
 * Supports: width, zero-padding, left-justify
 */

#include "printf.h"
#include <stdint.h>
#include <stddef.h>

// External UART function from kernel.c
extern void uart_putc(char c);

// Local strlen to avoid circular deps
static int local_strlen(const char *s) {
    int len = 0;
    while (s[len]) len++;
    return len;
}

// Output function type
typedef void (*putchar_fn)(char c, void *ctx);

// Context for sprintf
typedef struct {
    char *buf;
    int pos;
    int max;
} sprintf_ctx_t;

static void uart_putchar(char c, void *ctx) {
    (void)ctx;
    if (c == '\n') {
        uart_putc('\r');
    }
    uart_putc(c);
}

static void sprintf_putchar(char c, void *ctx) {
    sprintf_ctx_t *s = (sprintf_ctx_t *)ctx;
    if (s->pos < s->max - 1) {
        s->buf[s->pos++] = c;
    }
}

static int print_num(putchar_fn put, void *ctx, uint64_t num, int base, int width, int pad_zero, int uppercase) {
    char buf[20];
    const char *digits = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";
    int i = 0;
    int count = 0;

    if (num == 0) {
        buf[i++] = '0';
    } else {
        while (num > 0) {
            buf[i++] = digits[num % base];
            num /= base;
        }
    }

    // Padding
    int pad = width - i;
    if (pad > 0 && pad_zero) {
        while (pad-- > 0) {
            put('0', ctx);
            count++;
        }
    } else if (pad > 0) {
        while (pad-- > 0) {
            put(' ', ctx);
            count++;
        }
    }

    // Print digits in reverse
    while (i > 0) {
        put(buf[--i], ctx);
        count++;
    }

    return count;
}

static int print_signed(putchar_fn put, void *ctx, int64_t num, int width, int pad_zero) {
    int count = 0;

    if (num < 0) {
        put('-', ctx);
        count++;
        num = -num;
        width--;
    }

    count += print_num(put, ctx, (uint64_t)num, 10, width, pad_zero, 0);
    return count;
}

static int vprintf_internal(putchar_fn put, void *ctx, const char *fmt, va_list args) {
    int count = 0;

    while (*fmt) {
        if (*fmt != '%') {
            put(*fmt++, ctx);
            count++;
            continue;
        }

        fmt++;  // Skip '%'

        // Parse flags
        int pad_zero = 0;
        int left_justify = 0;

        while (*fmt == '0' || *fmt == '-') {
            if (*fmt == '0') pad_zero = 1;
            if (*fmt == '-') left_justify = 1;
            fmt++;
        }

        // Parse width
        int width = 0;
        while (*fmt >= '0' && *fmt <= '9') {
            width = width * 10 + (*fmt - '0');
            fmt++;
        }

        // Parse length modifier
        int is_long = 0;
        if (*fmt == 'l') {
            is_long = 1;
            fmt++;
            if (*fmt == 'l') {
                fmt++;  // ll
            }
        }

        // Format specifier
        switch (*fmt) {
            case 'd':
            case 'i': {
                int64_t val = is_long ? va_arg(args, int64_t) : va_arg(args, int);
                count += print_signed(put, ctx, val, width, pad_zero);
                break;
            }
            case 'u': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(put, ctx, val, 10, width, pad_zero, 0);
                break;
            }
            case 'x': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(put, ctx, val, 16, width, pad_zero, 0);
                break;
            }
            case 'X': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(put, ctx, val, 16, width, pad_zero, 1);
                break;
            }
            case 'p': {
                uint64_t val = (uint64_t)va_arg(args, void *);
                put('0', ctx);
                put('x', ctx);
                count += 2;
                count += print_num(put, ctx, val, 16, 16, 1, 0);
                break;
            }
            case 's': {
                const char *s = va_arg(args, const char *);
                if (!s) s = "(null)";
                int len = local_strlen(s);
                int pad = width - len;

                if (!left_justify && pad > 0) {
                    while (pad-- > 0) {
                        put(' ', ctx);
                        count++;
                    }
                }
                while (*s) {
                    put(*s++, ctx);
                    count++;
                }
                if (left_justify && pad > 0) {
                    while (pad-- > 0) {
                        put(' ', ctx);
                        count++;
                    }
                }
                break;
            }
            case 'c': {
                char c = (char)va_arg(args, int);
                put(c, ctx);
                count++;
                break;
            }
            case '%':
                put('%', ctx);
                count++;
                break;
            default:
                put('%', ctx);
                put(*fmt, ctx);
                count += 2;
                break;
        }
        fmt++;
    }

    return count;
}

int printf(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int count = 0;

    while (*fmt) {
        if (*fmt != '%') {
            if (*fmt == '\n') uart_putc('\r');
            uart_putc(*fmt++);
            count++;
            continue;
        }

        fmt++;  // Skip '%'

        // Parse flags
        int pad_zero = 0;
        while (*fmt == '0' || *fmt == '-') {
            if (*fmt == '0') pad_zero = 1;
            fmt++;
        }

        // Parse width
        int width = 0;
        while (*fmt >= '0' && *fmt <= '9') {
            width = width * 10 + (*fmt - '0');
            fmt++;
        }

        // Parse length modifier
        int is_long = 0;
        if (*fmt == 'l') {
            is_long = 1;
            fmt++;
            if (*fmt == 'l') fmt++;
        }

        // Format specifier
        switch (*fmt) {
            case 'd':
            case 'i': {
                int64_t val = is_long ? va_arg(args, int64_t) : va_arg(args, int);
                count += print_signed(uart_putchar, NULL, val, width, pad_zero);
                break;
            }
            case 'u': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(uart_putchar, NULL, val, 10, width, pad_zero, 0);
                break;
            }
            case 'x': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(uart_putchar, NULL, val, 16, width, pad_zero, 0);
                break;
            }
            case 'X': {
                uint64_t val = is_long ? va_arg(args, uint64_t) : va_arg(args, unsigned int);
                count += print_num(uart_putchar, NULL, val, 16, width, pad_zero, 1);
                break;
            }
            case 'p': {
                uint64_t val = (uint64_t)va_arg(args, void *);
                uart_putc('0');
                uart_putc('x');
                count += 2;
                count += print_num(uart_putchar, NULL, val, 16, 16, 1, 0);
                break;
            }
            case 's': {
                const char *s = va_arg(args, const char *);
                if (!s) s = "(null)";
                while (*s) {
                    uart_putc(*s++);
                    count++;
                }
                break;
            }
            case 'c': {
                char c = (char)va_arg(args, int);
                uart_putc(c);
                count++;
                break;
            }
            case '%':
                uart_putc('%');
                count++;
                break;
            default:
                uart_putc('%');
                uart_putc(*fmt);
                count += 2;
                break;
        }
        fmt++;
    }

    va_end(args);
    return count;
}

int sprintf(char *buf, const char *fmt, ...) {
    sprintf_ctx_t ctx = { buf, 0, 0x7FFFFFFF };
    va_list args;
    va_start(args, fmt);
    int count = vprintf_internal(sprintf_putchar, &ctx, fmt, args);
    va_end(args);
    buf[ctx.pos] = '\0';
    return count;
}

int snprintf(char *buf, int size, const char *fmt, ...) {
    sprintf_ctx_t ctx = { buf, 0, size };
    va_list args;
    va_start(args, fmt);
    int count = vprintf_internal(sprintf_putchar, &ctx, fmt, args);
    va_end(args);
    if (size > 0) {
        buf[ctx.pos] = '\0';
    }
    return count;
}
</file>

<file path="kernel/printf.h">
/*
 * VibeOS Printf
 */

#ifndef PRINTF_H
#define PRINTF_H

#include <stdarg.h>

// Printf to UART console
int printf(const char *fmt, ...);

// Sprintf to buffer
int sprintf(char *buf, const char *fmt, ...);

// Snprintf with length limit
int snprintf(char *buf, int size, const char *fmt, ...);

#endif
</file>

<file path="kernel/rtc.c">
/*
 * VibeOS RTC Driver
 *
 * PL031 Real Time Clock driver for QEMU virt machine.
 * Address: 0x0A000000
 */

#include "rtc.h"
#include "printf.h"

// PL031 RTC registers (QEMU virt machine)
// RTC is at 0x09010000, NOT 0x0A000000 (that's something else!)
#define RTC_BASE    0x09010000UL
#define RTC_DR      (*(volatile uint32_t *)(RTC_BASE + 0x000))  // Data Register (read = current time)
#define RTC_MR      (*(volatile uint32_t *)(RTC_BASE + 0x004))  // Match Register
#define RTC_LR      (*(volatile uint32_t *)(RTC_BASE + 0x008))  // Load Register (write to set time)
#define RTC_CR      (*(volatile uint32_t *)(RTC_BASE + 0x00C))  // Control Register
#define RTC_IMSC    (*(volatile uint32_t *)(RTC_BASE + 0x010))  // Interrupt Mask
#define RTC_RIS     (*(volatile uint32_t *)(RTC_BASE + 0x014))  // Raw Interrupt Status
#define RTC_MIS     (*(volatile uint32_t *)(RTC_BASE + 0x018))  // Masked Interrupt Status
#define RTC_ICR     (*(volatile uint32_t *)(RTC_BASE + 0x01C))  // Interrupt Clear

// Days in each month (non-leap year)
static const int days_in_month[] = {
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

// Check if year is a leap year
static int is_leap_year(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

// Get days in a given month
static int get_days_in_month(int year, int month) {
    if (month == 2 && is_leap_year(year)) {
        return 29;
    }
    return days_in_month[month - 1];
}

void rtc_init(void) {
    // PL031 is simple - just enable it
    RTC_CR = 1;  // Enable RTC

    uint32_t ts = RTC_DR;
    printf("[RTC] Initialized, timestamp: %u\n", ts);
}

uint32_t rtc_get_timestamp(void) {
    return RTC_DR;
}

void rtc_timestamp_to_datetime(uint32_t timestamp, datetime_t *dt) {
    // Calculate days since Unix epoch (Jan 1, 1970)
    uint32_t days = timestamp / 86400;
    uint32_t remaining_secs = timestamp % 86400;

    // Time of day
    dt->hour = remaining_secs / 3600;
    dt->minute = (remaining_secs % 3600) / 60;
    dt->second = remaining_secs % 60;

    // Day of week (Jan 1, 1970 was Thursday = 4)
    dt->weekday = (days + 4) % 7;

    // Calculate year
    int year = 1970;
    while (1) {
        int days_in_year = is_leap_year(year) ? 366 : 365;
        if (days < (uint32_t)days_in_year) break;
        days -= days_in_year;
        year++;
    }
    dt->year = year;

    // Calculate month and day
    int month = 1;
    while (1) {
        int dim = get_days_in_month(year, month);
        if (days < (uint32_t)dim) break;
        days -= dim;
        month++;
    }
    dt->month = month;
    dt->day = days + 1;  // Days are 1-indexed
}

void rtc_get_datetime(datetime_t *dt) {
    uint32_t ts = rtc_get_timestamp();
    rtc_timestamp_to_datetime(ts, dt);
}
</file>

<file path="kernel/rtc.h">
/*
 * VibeOS RTC Driver
 *
 * PL031 Real Time Clock on QEMU virt machine.
 * Provides wall-clock time from the host system.
 */

#ifndef RTC_H
#define RTC_H

#include <stdint.h>

// Date/time structure
typedef struct {
    int year;    // e.g., 2025
    int month;   // 1-12
    int day;     // 1-31
    int hour;    // 0-23
    int minute;  // 0-59
    int second;  // 0-59
    int weekday; // 0-6 (Sunday = 0)
} datetime_t;

// Initialize RTC
void rtc_init(void);

// Get Unix timestamp (seconds since Jan 1, 1970)
uint32_t rtc_get_timestamp(void);

// Convert timestamp to date/time structure
void rtc_timestamp_to_datetime(uint32_t timestamp, datetime_t *dt);

// Get current date/time
void rtc_get_datetime(datetime_t *dt);

#endif
</file>

<file path="kernel/shell.h">
/*
 * VibeOS Shell
 *
 * Command line interface
 */

#ifndef SHELL_H
#define SHELL_H

// Initialize and run the shell
void shell_init(void);
void shell_run(void);

#endif
</file>

<file path="kernel/vectors.S">
/*
 * VibeOS Exception Vector Table
 *
 * AArch64 exception vectors must be 2KB aligned, with each entry 128 bytes.
 * There are 16 entries total (4 exception types x 4 exception sources).
 */

.section .text

// Each vector entry is 128 bytes (32 instructions max)
.macro VECTOR_ENTRY label
.align 7
\label:
.endm

// Save all general-purpose registers
.macro SAVE_REGS
    sub     sp, sp, #256
    stp     x0, x1, [sp, #0]
    stp     x2, x3, [sp, #16]
    stp     x4, x5, [sp, #32]
    stp     x6, x7, [sp, #48]
    stp     x8, x9, [sp, #64]
    stp     x10, x11, [sp, #80]
    stp     x12, x13, [sp, #96]
    stp     x14, x15, [sp, #112]
    stp     x16, x17, [sp, #128]
    stp     x18, x19, [sp, #144]
    stp     x20, x21, [sp, #160]
    stp     x22, x23, [sp, #176]
    stp     x24, x25, [sp, #192]
    stp     x26, x27, [sp, #208]
    stp     x28, x29, [sp, #224]
    str     x30, [sp, #240]
.endm

// Restore all general-purpose registers
.macro RESTORE_REGS
    ldp     x0, x1, [sp, #0]
    ldp     x2, x3, [sp, #16]
    ldp     x4, x5, [sp, #32]
    ldp     x6, x7, [sp, #48]
    ldp     x8, x9, [sp, #64]
    ldp     x10, x11, [sp, #80]
    ldp     x12, x13, [sp, #96]
    ldp     x14, x15, [sp, #112]
    ldp     x16, x17, [sp, #128]
    ldp     x18, x19, [sp, #144]
    ldp     x20, x21, [sp, #160]
    ldp     x22, x23, [sp, #176]
    ldp     x24, x25, [sp, #192]
    ldp     x26, x27, [sp, #208]
    ldp     x28, x29, [sp, #224]
    ldr     x30, [sp, #240]
    add     sp, sp, #256
.endm

/*
 * Exception Vector Table
 * Must be 2KB (0x800) aligned
 *
 * Vector offsets:
 *   0x000 - Synchronous, Current EL with SP0
 *   0x080 - IRQ, Current EL with SP0
 *   0x100 - FIQ, Current EL with SP0
 *   0x180 - SError, Current EL with SP0
 *   0x200 - Synchronous, Current EL with SPx
 *   0x280 - IRQ, Current EL with SPx
 *   0x300 - FIQ, Current EL with SPx
 *   0x380 - SError, Current EL with SPx
 *   0x400 - Synchronous, Lower EL using AArch64
 *   0x480 - IRQ, Lower EL using AArch64
 *   0x500 - FIQ, Lower EL using AArch64
 *   0x580 - SError, Lower EL using AArch64
 *   0x600 - Synchronous, Lower EL using AArch32
 *   0x680 - IRQ, Lower EL using AArch32
 *   0x700 - FIQ, Lower EL using AArch32
 *   0x780 - SError, Lower EL using AArch32
 */

.align 11   // 2KB aligned
.global exception_vectors
exception_vectors:

// Current EL with SP0 (not used - we use SPx)
VECTOR_ENTRY vec_sync_sp0
    b       sync_handler

VECTOR_ENTRY vec_irq_sp0
    b       irq_handler_entry

VECTOR_ENTRY vec_fiq_sp0
    b       fiq_handler

VECTOR_ENTRY vec_serror_sp0
    b       serror_handler

// Current EL with SPx (this is what we use)
VECTOR_ENTRY vec_sync_spx
    b       sync_handler

VECTOR_ENTRY vec_irq_spx
    b       irq_handler_entry

VECTOR_ENTRY vec_fiq_spx
    b       fiq_handler

VECTOR_ENTRY vec_serror_spx
    b       serror_handler

// Lower EL using AArch64 (userspace)
VECTOR_ENTRY vec_sync_a64
    b       sync_handler

VECTOR_ENTRY vec_irq_a64
    b       irq_handler_entry

VECTOR_ENTRY vec_fiq_a64
    b       fiq_handler

VECTOR_ENTRY vec_serror_a64
    b       serror_handler

// Lower EL using AArch32 (not supported)
VECTOR_ENTRY vec_sync_a32
    b       sync_handler

VECTOR_ENTRY vec_irq_a32
    b       irq_handler_entry

VECTOR_ENTRY vec_fiq_a32
    b       fiq_handler

VECTOR_ENTRY vec_serror_a32
    b       serror_handler

/*
 * Exception Handlers
 */

// Synchronous exception (data abort, instruction abort, SVC, etc.)
sync_handler:
    SAVE_REGS

    // Get exception info
    mrs     x0, esr_el1     // Exception Syndrome Register
    mrs     x1, elr_el1     // Exception Link Register (return address)
    mrs     x2, far_el1     // Fault Address Register

    // Call C handler
    bl      handle_sync_exception

    RESTORE_REGS
    eret

// IRQ handler
irq_handler_entry:
    SAVE_REGS

    // Call C handler
    bl      handle_irq

    RESTORE_REGS
    eret

// FIQ handler (not used)
fiq_handler:
    SAVE_REGS
    bl      handle_fiq
    RESTORE_REGS
    eret

// SError handler (asynchronous abort)
serror_handler:
    SAVE_REGS
    mrs     x0, esr_el1
    bl      handle_serror
    RESTORE_REGS
    eret
</file>

<file path="kernel/virtio_blk.h">
/*
 * VibeOS Virtio Block Driver
 *
 * Implements virtio-blk for block device access on QEMU virt machine.
 */

#ifndef VIRTIO_BLK_H
#define VIRTIO_BLK_H

#include <stdint.h>
#include <stddef.h>

// Initialize the virtio-blk device
int virtio_blk_init(void);

// Read sectors from the block device
// sector: starting sector number (512 bytes each)
// count: number of sectors to read
// buf: buffer to read into (must be at least count * 512 bytes)
// Returns 0 on success, -1 on error
int virtio_blk_read(uint64_t sector, uint32_t count, void *buf);

// Write sectors to the block device
// sector: starting sector number (512 bytes each)
// count: number of sectors to write
// buf: buffer to write from (must be at least count * 512 bytes)
// Returns 0 on success, -1 on error
int virtio_blk_write(uint64_t sector, uint32_t count, const void *buf);

// Get the total number of sectors on the device
uint64_t virtio_blk_get_capacity(void);

#endif
</file>

<file path="kernel/virtio_net.c">
/*
 * VibeOS Virtio Network Driver
 *
 * Implements virtio-net for network access on QEMU virt machine.
 * Based on virtio 1.0 spec (modern mode).
 */

#include "virtio_net.h"
#include "printf.h"
#include "string.h"

// Virtio MMIO registers
#define VIRTIO_MMIO_BASE        0x0a000000
#define VIRTIO_MMIO_STRIDE      0x200

// Virtio MMIO register offsets
#define VIRTIO_MMIO_MAGIC           0x000
#define VIRTIO_MMIO_VERSION         0x004
#define VIRTIO_MMIO_DEVICE_ID       0x008
#define VIRTIO_MMIO_VENDOR_ID       0x00c
#define VIRTIO_MMIO_DEVICE_FEATURES 0x010
#define VIRTIO_MMIO_DEVICE_FEATURES_SEL 0x014
#define VIRTIO_MMIO_DRIVER_FEATURES 0x020
#define VIRTIO_MMIO_DRIVER_FEATURES_SEL 0x024
#define VIRTIO_MMIO_QUEUE_SEL       0x030
#define VIRTIO_MMIO_QUEUE_NUM_MAX   0x034
#define VIRTIO_MMIO_QUEUE_NUM       0x038
#define VIRTIO_MMIO_QUEUE_READY     0x044
#define VIRTIO_MMIO_QUEUE_NOTIFY    0x050
#define VIRTIO_MMIO_INTERRUPT_STATUS 0x060
#define VIRTIO_MMIO_INTERRUPT_ACK   0x064
#define VIRTIO_MMIO_STATUS          0x070
#define VIRTIO_MMIO_QUEUE_DESC_LOW  0x080
#define VIRTIO_MMIO_QUEUE_DESC_HIGH 0x084
#define VIRTIO_MMIO_QUEUE_AVAIL_LOW 0x090
#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH 0x094
#define VIRTIO_MMIO_QUEUE_USED_LOW  0x0a0
#define VIRTIO_MMIO_QUEUE_USED_HIGH 0x0a4
#define VIRTIO_MMIO_CONFIG          0x100

// Virtio status bits
#define VIRTIO_STATUS_ACK         1
#define VIRTIO_STATUS_DRIVER      2
#define VIRTIO_STATUS_DRIVER_OK   4
#define VIRTIO_STATUS_FEATURES_OK 8

// Virtio device types
#define VIRTIO_DEV_NET  1

// Virtio net feature bits
#define VIRTIO_NET_F_MAC        (1 << 5)   // Device has given MAC address

// Virtio net header (prepended to every packet)
typedef struct __attribute__((packed)) {
    uint8_t flags;
    uint8_t gso_type;
    uint16_t hdr_len;
    uint16_t gso_size;
    uint16_t csum_start;
    uint16_t csum_offset;
    // uint16_t num_buffers;  // Only present if VIRTIO_NET_F_MRG_RXBUF
} virtio_net_hdr_t;

// Virtqueue structures
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} virtq_desc_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} virtq_avail_t;

typedef struct __attribute__((packed)) {
    uint32_t id;
    uint32_t len;
} virtq_used_elem_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    virtq_used_elem_t ring[];
} virtq_used_t;

// Driver state
static volatile uint32_t *net_base = NULL;
static int net_device_index = -1;

// MAC address
static uint8_t mac_addr[6];

// Receive queue (queue 0)
static virtq_desc_t *rx_desc = NULL;
static virtq_avail_t *rx_avail = NULL;
static virtq_used_t *rx_used = NULL;
static uint16_t rx_last_used_idx = 0;

// Transmit queue (queue 1)
static virtq_desc_t *tx_desc = NULL;
static virtq_avail_t *tx_avail = NULL;
static virtq_used_t *tx_used = NULL;

#define QUEUE_SIZE 16
#define DESC_F_NEXT  1
#define DESC_F_WRITE 2

// Virtio IRQ base (same as other virtio devices)
#define VIRTIO_IRQ_BASE 48

// Queue memory (4KB aligned)
static uint8_t rx_queue_mem[4096] __attribute__((aligned(4096)));
static uint8_t tx_queue_mem[4096] __attribute__((aligned(4096)));

// Receive buffers: virtio header + ethernet frame
typedef struct __attribute__((aligned(16))) {
    virtio_net_hdr_t hdr;
    uint8_t data[NET_MTU];
} rx_buffer_t;

static rx_buffer_t rx_buffers[QUEUE_SIZE] __attribute__((aligned(16)));

// Transmit buffer (single, reused)
typedef struct __attribute__((aligned(16))) {
    virtio_net_hdr_t hdr;
    uint8_t data[NET_MTU];
} tx_buffer_t;

static tx_buffer_t tx_buffer __attribute__((aligned(16)));

// Memory barriers for device communication
static inline void mb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline uint32_t read32(volatile uint32_t *addr) {
    uint32_t val = *addr;
    mb();
    return val;
}

static inline void write32(volatile uint32_t *addr, uint32_t val) {
    mb();
    *addr = val;
    mb();
}

// Find virtio-net device
static volatile uint32_t *find_virtio_net(void) {
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic == 0x74726976 && device_id == VIRTIO_DEV_NET) {
            net_device_index = i;
            return base;
        }
    }
    return NULL;
}

// Setup a virtqueue
static int setup_queue(int queue_idx, uint8_t *queue_mem,
                       virtq_desc_t **desc_out, virtq_avail_t **avail_out, virtq_used_t **used_out) {
    write32(net_base + VIRTIO_MMIO_QUEUE_SEL/4, queue_idx);

    uint32_t max_queue = read32(net_base + VIRTIO_MMIO_QUEUE_NUM_MAX/4);
    if (max_queue < QUEUE_SIZE) {
        printf("[NET] Queue %d too small (max=%d)\n", queue_idx, max_queue);
        return -1;
    }

    write32(net_base + VIRTIO_MMIO_QUEUE_NUM/4, QUEUE_SIZE);

    // Setup queue memory layout
    *desc_out = (virtq_desc_t *)queue_mem;
    *avail_out = (virtq_avail_t *)(queue_mem + QUEUE_SIZE * sizeof(virtq_desc_t));
    *used_out = (virtq_used_t *)(queue_mem + 2048);

    uint64_t desc_addr = (uint64_t)*desc_out;
    uint64_t avail_addr = (uint64_t)*avail_out;
    uint64_t used_addr = (uint64_t)*used_out;

    write32(net_base + VIRTIO_MMIO_QUEUE_DESC_LOW/4, (uint32_t)desc_addr);
    write32(net_base + VIRTIO_MMIO_QUEUE_DESC_HIGH/4, (uint32_t)(desc_addr >> 32));
    write32(net_base + VIRTIO_MMIO_QUEUE_AVAIL_LOW/4, (uint32_t)avail_addr);
    write32(net_base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH/4, (uint32_t)(avail_addr >> 32));
    write32(net_base + VIRTIO_MMIO_QUEUE_USED_LOW/4, (uint32_t)used_addr);
    write32(net_base + VIRTIO_MMIO_QUEUE_USED_HIGH/4, (uint32_t)(used_addr >> 32));

    (*avail_out)->flags = 0;
    (*avail_out)->idx = 0;

    write32(net_base + VIRTIO_MMIO_QUEUE_READY/4, 1);

    return 0;
}

int virtio_net_init(void) {
    net_base = find_virtio_net();
    if (!net_base) {
        printf("[NET] No virtio-net device found\n");
        return -1;
    }

    printf("[NET] Found virtio-net at device slot %d\n", net_device_index);

    // Reset device
    write32(net_base + VIRTIO_MMIO_STATUS/4, 0);
    while (read32(net_base + VIRTIO_MMIO_STATUS/4) != 0) {
        asm volatile("nop");
    }

    // Acknowledge and set driver
    write32(net_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK);
    write32(net_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER);

    // Read device features
    write32(net_base + VIRTIO_MMIO_DEVICE_FEATURES_SEL/4, 0);
    uint32_t features = read32(net_base + VIRTIO_MMIO_DEVICE_FEATURES/4);
    printf("[NET] Device features: 0x%x\n", features);

    // Accept MAC feature only (don't need checksums, GSO, etc)
    write32(net_base + VIRTIO_MMIO_DRIVER_FEATURES_SEL/4, 0);
    write32(net_base + VIRTIO_MMIO_DRIVER_FEATURES/4, VIRTIO_NET_F_MAC);

    write32(net_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK);

    uint32_t status = read32(net_base + VIRTIO_MMIO_STATUS/4);
    if (!(status & VIRTIO_STATUS_FEATURES_OK)) {
        printf("[NET] Feature negotiation failed\n");
        return -1;
    }

    // Read MAC address from config space
    volatile uint8_t *config = (volatile uint8_t *)net_base + VIRTIO_MMIO_CONFIG;
    for (int i = 0; i < 6; i++) {
        mac_addr[i] = config[i];
    }
    printf("[NET] MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
           mac_addr[0], mac_addr[1], mac_addr[2],
           mac_addr[3], mac_addr[4], mac_addr[5]);

    // Setup receive queue (queue 0)
    if (setup_queue(0, rx_queue_mem, &rx_desc, &rx_avail, &rx_used) < 0) {
        return -1;
    }

    // Setup transmit queue (queue 1)
    if (setup_queue(1, tx_queue_mem, &tx_desc, &tx_avail, &tx_used) < 0) {
        return -1;
    }

    // Pre-populate receive queue with buffers
    for (int i = 0; i < QUEUE_SIZE; i++) {
        rx_desc[i].addr = (uint64_t)&rx_buffers[i];
        rx_desc[i].len = sizeof(rx_buffer_t);
        rx_desc[i].flags = DESC_F_WRITE;  // Device writes to this buffer
        rx_desc[i].next = 0;

        rx_avail->ring[i] = i;
    }
    rx_avail->idx = QUEUE_SIZE;
    mb();

    // Set driver OK
    write32(net_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER |
            VIRTIO_STATUS_FEATURES_OK | VIRTIO_STATUS_DRIVER_OK);

    status = read32(net_base + VIRTIO_MMIO_STATUS/4);
    if (status & 0x40) {
        printf("[NET] Device reported failure\n");
        return -1;
    }

    // Notify device that receive buffers are available
    write32(net_base + VIRTIO_MMIO_QUEUE_SEL/4, 0);
    write32(net_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    printf("[NET] Ready\n");
    return 0;
}

void virtio_net_get_mac(uint8_t *mac) {
    for (int i = 0; i < 6; i++) {
        mac[i] = mac_addr[i];
    }
}

int virtio_net_send(const void *data, uint32_t len) {
    if (!net_base) return -1;
    if (len > NET_MTU) return -1;

    // Prepare virtio header (all zeros - no offloads)
    memset(&tx_buffer.hdr, 0, sizeof(virtio_net_hdr_t));

    // Copy data
    memcpy(tx_buffer.data, data, len);

    // Setup descriptor chain: header + data in one buffer
    tx_desc[0].addr = (uint64_t)&tx_buffer;
    tx_desc[0].len = sizeof(virtio_net_hdr_t) + len;
    tx_desc[0].flags = 0;  // Device reads from this buffer
    tx_desc[0].next = 0;

    // Add to available ring
    mb();
    uint16_t avail_idx = tx_avail->idx % QUEUE_SIZE;
    tx_avail->ring[avail_idx] = 0;
    mb();
    tx_avail->idx++;
    mb();

    // Save used index for polling
    uint16_t old_used = tx_used->idx;

    // Notify device (select queue 1 first)
    write32(net_base + VIRTIO_MMIO_QUEUE_SEL/4, 1);
    write32(net_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 1);

    // Poll for completion
    int timeout = 1000000;
    while (tx_used->idx == old_used && timeout > 0) {
        mb();
        timeout--;
    }

    if (timeout == 0) {
        printf("[NET] TX timeout\n");
        return -1;
    }

    // Ack interrupt
    write32(net_base + VIRTIO_MMIO_INTERRUPT_ACK/4,
            read32(net_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    return 0;
}

int virtio_net_has_packet(void) {
    if (!net_base) return 0;
    mb();
    return rx_used->idx != rx_last_used_idx;
}

int virtio_net_recv(void *buf, uint32_t maxlen) {
    if (!net_base) return -1;

    mb();
    if (rx_used->idx == rx_last_used_idx) {
        return 0;  // No packet
    }

    // Get the completed descriptor
    uint16_t used_idx = rx_last_used_idx % QUEUE_SIZE;
    uint32_t desc_idx = rx_used->ring[used_idx].id;
    uint32_t total_len = rx_used->ring[used_idx].len;

    rx_last_used_idx++;

    // Skip virtio header, copy ethernet frame
    rx_buffer_t *rxbuf = &rx_buffers[desc_idx];
    uint32_t frame_len = total_len - sizeof(virtio_net_hdr_t);

    if (frame_len > maxlen) {
        frame_len = maxlen;
    }

    memcpy(buf, rxbuf->data, frame_len);

    // Re-add buffer to available ring
    uint16_t avail_idx = rx_avail->idx % QUEUE_SIZE;
    rx_avail->ring[avail_idx] = desc_idx;
    mb();
    rx_avail->idx++;
    mb();

    // Notify device
    write32(net_base + VIRTIO_MMIO_QUEUE_SEL/4, 0);
    write32(net_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    // Ack interrupt
    write32(net_base + VIRTIO_MMIO_INTERRUPT_ACK/4,
            read32(net_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    return frame_len;
}

uint32_t virtio_net_get_irq(void) {
    if (net_device_index < 0) return 0;
    return VIRTIO_IRQ_BASE + net_device_index;
}

void virtio_net_irq_handler(void) {
    if (!net_base) return;

    // Just ack the interrupt - don't consume packets here!
    // Packets will be processed by net_poll() in the network stack.
    write32(net_base + VIRTIO_MMIO_INTERRUPT_ACK/4,
            read32(net_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));
}
</file>

<file path="kernel/virtio_net.h">
/*
 * VibeOS Virtio Network Driver
 *
 * Implements virtio-net for network access on QEMU virt machine.
 */

#ifndef VIRTIO_NET_H
#define VIRTIO_NET_H

#include <stdint.h>
#include <stddef.h>

// Maximum ethernet frame size (without virtio header)
#define NET_MTU 1514

// Initialize the virtio-net device
// Returns 0 on success, -1 on error
int virtio_net_init(void);

// Get MAC address (6 bytes)
void virtio_net_get_mac(uint8_t *mac);

// Send a raw ethernet frame
// data: pointer to ethernet frame (dst mac, src mac, ethertype, payload)
// len: length of frame in bytes
// Returns 0 on success, -1 on error
int virtio_net_send(const void *data, uint32_t len);

// Receive a raw ethernet frame (polling)
// buf: buffer to receive into
// maxlen: maximum bytes to receive
// Returns number of bytes received, 0 if no packet, -1 on error
int virtio_net_recv(void *buf, uint32_t maxlen);

// Check if a packet is available
int virtio_net_has_packet(void);

// IRQ handler (called from irq.c)
void virtio_net_irq_handler(void);

// Get the network device's IRQ number
uint32_t virtio_net_get_irq(void);

#endif
</file>

<file path="user/bin/date.c">
/*
 * date - display the current date and time
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

static void print_num(int n, int width) {
    // Print number with leading zeros
    char buf[12];
    int i = 0;
    int neg = 0;

    if (n < 0) {
        neg = 1;
        n = -n;
    }

    if (n == 0) {
        buf[i++] = '0';
    } else {
        while (n > 0) {
            buf[i++] = '0' + (n % 10);
            n /= 10;
        }
    }

    if (neg) out_putc('-');

    // Pad with leading zeros
    while (i < width) {
        out_putc('0');
        width--;
    }

    // Print digits in reverse
    while (i > 0) {
        out_putc(buf[--i]);
    }
}

static const char *day_names[] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

static const char *month_names[] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

int main(kapi_t *k, int argc, char **argv) {
    (void)argc;
    (void)argv;
    api = k;

    int year, month, day, hour, minute, second, weekday;
    k->get_datetime(&year, &month, &day, &hour, &minute, &second, &weekday);

    // Format: "Mon Dec  8 14:30:45 2025"
    out_puts(day_names[weekday]);
    out_putc(' ');
    out_puts(month_names[month - 1]);
    out_putc(' ');
    if (day < 10) out_putc(' ');
    print_num(day, 1);
    out_putc(' ');
    print_num(hour, 2);
    out_putc(':');
    print_num(minute, 2);
    out_putc(':');
    print_num(second, 2);
    out_putc(' ');
    print_num(year, 4);
    out_putc('\n');

    return 0;
}
</file>

<file path="user/bin/hello.c">
/*
 * Hello World - First VibeOS userspace program!
 */

#include "../lib/vibe.h"

int main(kapi_t *k, int argc, char **argv) {
    (void)argc; (void)argv;  // unused
    k->set_color(COLOR_GREEN, COLOR_BLACK);
    k->puts("Hello from userspace!\n");
    k->set_color(COLOR_WHITE, COLOR_BLACK);
    k->puts("The vibes are immaculate.\n");
    return 0;
}
</file>

<file path="user/bin/uptime.c">
/*
 * uptime - show system uptime
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

static void print_num(unsigned long n) {
    if (n == 0) {
        out_putc('0');
        return;
    }
    char buf[20];
    int i = 0;
    while (n > 0) {
        buf[i++] = '0' + (n % 10);
        n /= 10;
    }
    while (i > 0) {
        out_putc(buf[--i]);
    }
}

int main(kapi_t *k, int argc, char **argv) {
    (void)argc;
    (void)argv;
    api = k;

    // Get ticks (100 ticks/second with 10ms timer)
    unsigned long ticks = k->get_uptime_ticks();

    // Convert to time units
    unsigned long total_seconds = ticks / 100;
    unsigned long hours = total_seconds / 3600;
    unsigned long minutes = (total_seconds % 3600) / 60;
    unsigned long seconds = total_seconds % 60;

    out_puts("up ");

    if (hours > 0) {
        print_num(hours);
        out_puts("h ");
    }

    if (hours > 0 || minutes > 0) {
        print_num(minutes);
        out_puts("m ");
    }

    print_num(seconds);
    out_puts("s (");
    print_num(ticks);
    out_puts(" ticks)\n");

    return 0;
}
</file>

<file path="user/lib/crt0.S">
/*
 * VibeOS C Runtime Startup
 *
 * Entry point for all userspace programs.
 * Receives: x0=kapi_t*, x1=argc, x2=argv
 */

.section ".text.start"
.global _start

_start:
    // x0 = kapi_t*, x1 = argc, x2 = argv
    // x30 contains return address to kernel - save it!

    // Save x30 (return address) and x29 (frame pointer)
    stp     x29, x30, [sp, #-16]!
    mov     x29, sp

    // Call main(kapi_t *api, int argc, char **argv)
    // x0, x1, x2 already set by kernel
    bl      main

    // Restore x29 and x30, then return to kernel
    ldp     x29, x30, [sp], #16
    ret
</file>

<file path="user/lib/gfx.h">
/*
 * VibeOS Graphics Library
 *
 * Common drawing primitives for GUI applications.
 * Works with any buffer - desktop backbuffer, window buffers, etc.
 */

#ifndef GFX_H
#define GFX_H

#include "vibe.h"

// Graphics context - describes a drawing target
typedef struct {
    uint32_t *buffer;      // Pixel buffer
    int width;             // Buffer width in pixels
    int height;            // Buffer height in pixels
    const uint8_t *font;   // Font data (from kapi->font_data)
} gfx_ctx_t;

// Initialize a graphics context
static inline void gfx_init(gfx_ctx_t *ctx, uint32_t *buffer, int w, int h, const uint8_t *font) {
    ctx->buffer = buffer;
    ctx->width = w;
    ctx->height = h;
    ctx->font = font;
}

// ============ Basic Drawing Primitives ============

// Put a single pixel
static inline void gfx_put_pixel(gfx_ctx_t *ctx, int x, int y, uint32_t color) {
    if (x >= 0 && x < ctx->width && y >= 0 && y < ctx->height) {
        ctx->buffer[y * ctx->width + x] = color;
    }
}

// Fill a rectangle with solid color
static inline void gfx_fill_rect(gfx_ctx_t *ctx, int x, int y, int w, int h, uint32_t color) {
    for (int py = y; py < y + h && py < ctx->height; py++) {
        if (py < 0) continue;
        for (int px = x; px < x + w && px < ctx->width; px++) {
            if (px < 0) continue;
            ctx->buffer[py * ctx->width + px] = color;
        }
    }
}

// Draw a horizontal line
static inline void gfx_draw_hline(gfx_ctx_t *ctx, int x, int y, int w, uint32_t color) {
    if (y < 0 || y >= ctx->height) return;
    for (int i = 0; i < w; i++) {
        int px = x + i;
        if (px >= 0 && px < ctx->width) {
            ctx->buffer[y * ctx->width + px] = color;
        }
    }
}

// Draw a vertical line
static inline void gfx_draw_vline(gfx_ctx_t *ctx, int x, int y, int h, uint32_t color) {
    if (x < 0 || x >= ctx->width) return;
    for (int i = 0; i < h; i++) {
        int py = y + i;
        if (py >= 0 && py < ctx->height) {
            ctx->buffer[py * ctx->width + x] = color;
        }
    }
}

// Draw a rectangle outline
static inline void gfx_draw_rect(gfx_ctx_t *ctx, int x, int y, int w, int h, uint32_t color) {
    gfx_draw_hline(ctx, x, y, w, color);
    gfx_draw_hline(ctx, x, y + h - 1, w, color);
    gfx_draw_vline(ctx, x, y, h, color);
    gfx_draw_vline(ctx, x + w - 1, y, h, color);
}

// ============ Text Drawing ============

// Draw a single character (8x16 font)
static inline void gfx_draw_char(gfx_ctx_t *ctx, int x, int y, char c, uint32_t fg, uint32_t bg) {
    const uint8_t *glyph = &ctx->font[(unsigned char)c * 16];
    for (int row = 0; row < 16; row++) {
        for (int col = 0; col < 8; col++) {
            uint32_t color = (glyph[row] & (0x80 >> col)) ? fg : bg;
            int px = x + col;
            int py = y + row;
            if (px >= 0 && px < ctx->width && py >= 0 && py < ctx->height) {
                ctx->buffer[py * ctx->width + px] = color;
            }
        }
    }
}

// Draw a string
static inline void gfx_draw_string(gfx_ctx_t *ctx, int x, int y, const char *s, uint32_t fg, uint32_t bg) {
    while (*s) {
        gfx_draw_char(ctx, x, y, *s, fg, bg);
        x += 8;
        s++;
    }
}

// Draw a string with clipping (max width in pixels)
static inline void gfx_draw_string_clip(gfx_ctx_t *ctx, int x, int y, const char *s, uint32_t fg, uint32_t bg, int max_w) {
    int drawn = 0;
    while (*s && drawn + 8 <= max_w) {
        gfx_draw_char(ctx, x, y, *s, fg, bg);
        x += 8;
        drawn += 8;
        s++;
    }
}

// ============ Patterns (for desktop background, etc.) ============

// Classic Mac diagonal checkerboard pattern
static inline void gfx_fill_pattern(gfx_ctx_t *ctx, int x, int y, int w, int h, uint32_t c1, uint32_t c2) {
    for (int py = y; py < y + h && py < ctx->height; py++) {
        if (py < 0) continue;
        for (int px = x; px < x + w && px < ctx->width; px++) {
            if (px < 0) continue;
            int pattern = ((px + py) % 2 == 0) ? 1 : 0;
            ctx->buffer[py * ctx->width + px] = pattern ? c1 : c2;
        }
    }
}

// 25% dither pattern (sparse dots)
static inline void gfx_fill_dither25(gfx_ctx_t *ctx, int x, int y, int w, int h, uint32_t c1, uint32_t c2) {
    for (int py = y; py < y + h && py < ctx->height; py++) {
        if (py < 0) continue;
        for (int px = x; px < x + w && px < ctx->width; px++) {
            if (px < 0) continue;
            int pattern = ((px % 2 == 0) && (py % 2 == 0)) ? 1 : 0;
            ctx->buffer[py * ctx->width + px] = pattern ? c1 : c2;
        }
    }
}

#endif // GFX_H
</file>

<file path="user/lib/stdlib.h">
/* Minimal stdlib.h stub for freestanding userspace */
#ifndef _STDLIB_H
#define _STDLIB_H

/* minimp3 doesn't actually use anything from stdlib.h */

#endif
</file>

<file path="user/lib/string.h">
/* Minimal string.h stub for freestanding userspace */
#ifndef _STRING_H
#define _STRING_H

#include "vibe.h"

/* memcpy and memset are defined in vibe.h */

/* memcmp - compare memory regions */
static inline int memcmp(const void *s1, const void *s2, unsigned long n) {
    const unsigned char *p1 = s1, *p2 = s2;
    while (n--) {
        if (*p1 != *p2) return *p1 - *p2;
        p1++; p2++;
    }
    return 0;
}

/* memmove - copy memory with overlap handling */
static inline void *memmove(void *dst, const void *src, unsigned long n) {
    unsigned char *d = dst;
    const unsigned char *s = src;
    if (d < s) {
        while (n--) *d++ = *s++;
    } else {
        d += n;
        s += n;
        while (n--) *--d = *--s;
    }
    return dst;
}

#endif
</file>

<file path="LONGTERM.md">
# VibeOS Long-term Roadmap

The dream: A usable retro computer you could run on a Raspberry Pi. Classic Mac vibes, self-hosting capability, maybe even networking.

## Phase 1: Desktop Apps (Current)

Build real GUI applications into the desktop:

- [ ] Terminal emulator (shell in a window - biggest unlock)
- [ ] File explorer (navigate filesystem, launch programs)
- [ ] Notepad (simple text editor, non-modal unlike vi)
- [ ] Calculator (classic Mac style)

**Architecture:** Apps are compiled into desktop.c (Approach 2). Simpler than IPC between processes. External programs (games) still take over fullscreen.

## Phase 1.5: Fun Stuff

- [ ] Paint (draw pixels, save as BMP)
- [ ] Image viewer (BMP first, maybe PNG later)
- [ ] Clock widget

## Phase 2: Pick Your Adventure

### Music Path
- [ ] virtio-sound or Intel HDA audio driver
- [ ] WAV playback (trivial format)
- [ ] MP3 playback (port minimp3)
- [ ] Music player app with playlist

### Compiler Path (Self-Hosting!)
- [ ] Port TCC (Tiny C Compiler, ~30k lines)
- [ ] Port or write simple assembler
- [ ] VibeOS can compile C code for itself
- [ ] THE DREAM: write VibeOS code from within VibeOS

### Network Path
- [ ] virtio-net driver
- [ ] IP/UDP (stateless, easier)
- [ ] TCP (state machine, retransmits)
- [ ] DNS resolver
- [ ] HTTP client (no TLS - plaintext only)
- [ ] Simple "browser" (HTML only, no CSS/JS)
- [ ] Email send (SMTP is just text)

### DOOM Path
- [ ] Implement missing libc functions DOOM needs
- [ ] Port DOOM source code
- [ ] Flex on everyone

## Phase 3: Hardware

### Raspberry Pi Port
Same architecture (aarch64), different peripherals:
- [ ] Pi-specific UART addresses
- [ ] Mailbox framebuffer interface
- [ ] SD card driver (replaces virtio-blk)
- [ ] USB keyboard (this is the hard part)

Estimate: 2-3 focused sessions

### x86 ThinkPad Port
This is basically a rewrite:
- [ ] x86 boot code (BIOS/GRUB nightmare)
- [ ] x86 assembly (context switch, etc)
- [ ] VGA/VESA framebuffer
- [ ] PS/2 or USB keyboard
- [ ] ATA/IDE disk driver

Estimate: Many weeks. Different project really.

## Wild Ideas (Probably Not Happening)

| Idea | Verdict | Why |
|------|---------|-----|
| Python | No | CPython is 500k+ lines, needs full libc |
| Vulkan | No | We have dumb framebuffer, no GPU |
| Node.js | No | V8 is millions of lines of C++ |
| Full web browser | Probably no | HTML+CSS+JS rendering is insane |
| HTTPS/TLS | Maybe | Need to port crypto library (mbedTLS) |
| SSH | Maybe | Same crypto problem |
| Claude API | Maybe | Need HTTPS, or use a local proxy |

## The Self-Hosting Dream

The ultimate goal: VibeOS can build itself.

Requirements:
- C compiler (TCC)
- Text editor (vi or notepad)
- Assembler
- Linker
- Shell with basic commands

Then someone could theoretically:
1. Boot VibeOS
2. Write new code in notepad
3. Compile it in terminal
4. Run it
5. Infinite capability expansion

## Desktop Environment Vision

Classic Mac System 7 / Apple Lisa aesthetic:
- 1-bit or limited color icons
- Chicago-style bitmap font
- Striped title bars (already have)
- Menu bar at top (already have)
- Apple logo () in menu bar
- Finder-style file browser
- "About This Mac" dialog
- Desktop pattern/wallpaper
- Trash can icon

## What's NOT the Goal

- Linux compatibility
- POSIX compliance
- Modern security
- Production readiness
- Performance

This is a vibes-first operating system. It should feel like 1987, not 2024.
</file>

<file path="kernel/console.c">
/*
 * VibeOS Text Console
 *
 * Provides terminal-like text output on the framebuffer.
 * Handles cursor positioning, scrolling, and basic escape sequences.
 */

#include "console.h"
#include "fb.h"
#include "font.h"
#include "string.h"
#include "printf.h"

// Console state
static int cursor_row = 0;
static int cursor_col = 0;
static int num_rows = 0;
static int num_cols = 0;
static uint32_t fg_color = COLOR_WHITE;
static uint32_t bg_color = COLOR_BLACK;

// Text buffer for scrolling
static char *text_buffer = NULL;
static uint32_t *fg_buffer = NULL;
static uint32_t *bg_buffer = NULL;

void console_init(void) {
    if (fb_base == NULL) return;

    // Calculate dimensions
    num_cols = fb_width / FONT_WIDTH;
    num_rows = fb_height / FONT_HEIGHT;

    // Allocate text buffer for scrollback
    // We'll just use static allocation for simplicity
    // In a real OS we'd use malloc

    cursor_row = 0;
    cursor_col = 0;

    // Clear screen
    console_clear();
}

static void draw_char_at(int row, int col, char c) {
    uint32_t x = col * FONT_WIDTH;
    uint32_t y = row * FONT_HEIGHT;
    fb_draw_char(x, y, c, fg_color, bg_color);
}

static void scroll_up(void) {
    // Move all pixels up by one line
    uint32_t line_pixels = fb_width * FONT_HEIGHT;
    uint32_t total_pixels = fb_width * fb_height;

    // Copy pixels up
    for (uint32_t i = 0; i < total_pixels - line_pixels; i++) {
        fb_base[i] = fb_base[i + line_pixels];
    }

    // Clear the bottom line
    for (uint32_t i = total_pixels - line_pixels; i < total_pixels; i++) {
        fb_base[i] = bg_color;
    }
}

static void newline(void) {
    cursor_col = 0;
    cursor_row++;

    if (cursor_row >= num_rows) {
        scroll_up();
        cursor_row = num_rows - 1;
    }
}

void console_putc(char c) {
    // If no framebuffer, fall back to UART
    if (fb_base == NULL) {
        extern void uart_putc(char c);
        uart_putc(c);
        return;
    }

    switch (c) {
        case '\n':
            newline();
            break;

        case '\r':
            cursor_col = 0;
            break;

        case '\t':
            // Tab to next 8-column boundary
            cursor_col = (cursor_col + 8) & ~7;
            if (cursor_col >= num_cols) {
                newline();
            }
            break;

        case '\b':
            // Backspace
            if (cursor_col > 0) {
                cursor_col--;
                draw_char_at(cursor_row, cursor_col, ' ');
            }
            break;

        default:
            if (c >= 32 && c < 127) {
                draw_char_at(cursor_row, cursor_col, c);
                cursor_col++;

                if (cursor_col >= num_cols) {
                    newline();
                }
            }
            break;
    }
}

void console_puts(const char *s) {
    // If no framebuffer, fall back to UART
    if (fb_base == NULL) {
        printf("%s", s);
        return;
    }
    while (*s) {
        console_putc(*s++);
    }
}

void console_clear(void) {
    fb_clear(bg_color);
    cursor_row = 0;
    cursor_col = 0;
}

void console_set_cursor(int row, int col) {
    if (row >= 0 && row < num_rows) cursor_row = row;
    if (col >= 0 && col < num_cols) cursor_col = col;
}

void console_get_cursor(int *row, int *col) {
    if (row) *row = cursor_row;
    if (col) *col = cursor_col;
}

void console_set_color(uint32_t fg, uint32_t bg) {
    fg_color = fg;
    bg_color = bg;
}

int console_rows(void) {
    return num_rows;
}

int console_cols(void) {
    return num_cols;
}
</file>

<file path="kernel/context.S">
/*
 * VibeOS Context Switch
 *
 * Saves callee-saved registers and switches stacks between processes.
 * AArch64 calling convention: x19-x28 are callee-saved, x29 is FP, x30 is LR
 * Also saves/restores all FPU state (q0-q31, fpcr, fpsr)
 */

.global context_switch

/*
 * void context_switch(cpu_context_t *old_ctx, cpu_context_t *new_ctx)
 *
 * old_ctx: x0 - where to save current context
 * new_ctx: x1 - context to restore
 *
 * cpu_context_t layout:
 *   0x00: x19
 *   0x08: x20
 *   0x10: x21
 *   0x18: x22
 *   0x20: x23
 *   0x28: x24
 *   0x30: x25
 *   0x38: x26
 *   0x40: x27
 *   0x48: x28
 *   0x50: x29 (FP)
 *   0x58: x30 (LR - return address)
 *   0x60: sp
 *   0x68: fpcr
 *   0x70: fpsr
 *   0x78: _pad (alignment padding)
 *   0x80: fp_regs[0-63] (q0-q31, 512 bytes) - 16-byte aligned!
 */

context_switch:
    // Save current context to old_ctx (x0)
    // If old_ctx is NULL, skip saving
    cbz     x0, 1f

    // Save general purpose registers
    stp     x19, x20, [x0, #0x00]
    stp     x21, x22, [x0, #0x10]
    stp     x23, x24, [x0, #0x20]
    stp     x25, x26, [x0, #0x30]
    stp     x27, x28, [x0, #0x40]
    stp     x29, x30, [x0, #0x50]
    mov     x2, sp
    str     x2, [x0, #0x60]

    // Save FPU control/status registers
    mrs     x2, fpcr
    str     x2, [x0, #0x68]
    mrs     x2, fpsr
    str     x2, [x0, #0x70]

    // Save FP registers q0-q31 (each is 128-bit)
    add     x2, x0, #0x80
    stp     q0,  q1,  [x2, #0x00]
    stp     q2,  q3,  [x2, #0x20]
    stp     q4,  q5,  [x2, #0x40]
    stp     q6,  q7,  [x2, #0x60]
    stp     q8,  q9,  [x2, #0x80]
    stp     q10, q11, [x2, #0xa0]
    stp     q12, q13, [x2, #0xc0]
    stp     q14, q15, [x2, #0xe0]
    stp     q16, q17, [x2, #0x100]
    stp     q18, q19, [x2, #0x120]
    stp     q20, q21, [x2, #0x140]
    stp     q22, q23, [x2, #0x160]
    stp     q24, q25, [x2, #0x180]
    stp     q26, q27, [x2, #0x1a0]
    stp     q28, q29, [x2, #0x1c0]
    stp     q30, q31, [x2, #0x1e0]

1:
    // Restore context from new_ctx (x1)

    // Restore FP registers first (use x2 as temp)
    add     x2, x1, #0x80
    ldp     q0,  q1,  [x2, #0x00]
    ldp     q2,  q3,  [x2, #0x20]
    ldp     q4,  q5,  [x2, #0x40]
    ldp     q6,  q7,  [x2, #0x60]
    ldp     q8,  q9,  [x2, #0x80]
    ldp     q10, q11, [x2, #0xa0]
    ldp     q12, q13, [x2, #0xc0]
    ldp     q14, q15, [x2, #0xe0]
    ldp     q16, q17, [x2, #0x100]
    ldp     q18, q19, [x2, #0x120]
    ldp     q20, q21, [x2, #0x140]
    ldp     q22, q23, [x2, #0x160]
    ldp     q24, q25, [x2, #0x180]
    ldp     q26, q27, [x2, #0x1a0]
    ldp     q28, q29, [x2, #0x1c0]
    ldp     q30, q31, [x2, #0x1e0]

    // Restore FPU control/status registers
    ldr     x2, [x1, #0x68]
    msr     fpcr, x2
    ldr     x2, [x1, #0x70]
    msr     fpsr, x2

    // Restore general purpose registers
    ldp     x19, x20, [x1, #0x00]
    ldp     x21, x22, [x1, #0x10]
    ldp     x23, x24, [x1, #0x20]
    ldp     x25, x26, [x1, #0x30]
    ldp     x27, x28, [x1, #0x40]
    ldp     x29, x30, [x1, #0x50]
    ldr     x2, [x1, #0x60]
    mov     sp, x2

    // Return to new process (x30 has return address)
    ret
</file>

<file path="kernel/fb.h">
/*
 * VibeOS Framebuffer Driver
 */

#ifndef FB_H
#define FB_H

#include <stdint.h>

// Framebuffer info
extern uint32_t fb_width;
extern uint32_t fb_height;
extern uint32_t fb_pitch;  // Bytes per row
extern uint32_t *fb_base;  // Pointer to pixel memory

// Initialize framebuffer
int fb_init(void);

// Basic drawing
void fb_put_pixel(uint32_t x, uint32_t y, uint32_t color);
void fb_fill_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
void fb_clear(uint32_t color);

// Colors (32-bit XRGB)
#define COLOR_BLACK   0x00000000
#define COLOR_WHITE   0x00FFFFFF
#define COLOR_GREEN   0x0000FF00
#define COLOR_AMBER   0x00FFBF00
#define COLOR_RED     0x00FF0000
#define COLOR_BLUE    0x000000FF
#define COLOR_CYAN    0x0000FFFF

// Text drawing
void fb_draw_char(uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg);
void fb_draw_string(uint32_t x, uint32_t y, const char *s, uint32_t fg, uint32_t bg);

#endif
</file>

<file path="kernel/irq.h">
/*
 * VibeOS Interrupt Handling
 */

#ifndef IRQ_H
#define IRQ_H

#include <stdint.h>

// Initialize GIC and enable interrupts
void irq_init(void);

// Enable/disable all interrupts (modifies DAIF)
void irq_enable(void);
void irq_disable(void);

// Enable/disable specific IRQ in GIC
void irq_enable_irq(uint32_t irq);
void irq_disable_irq(uint32_t irq);

// Register an IRQ handler
typedef void (*irq_handler_t)(void);
void irq_register_handler(uint32_t irq, irq_handler_t handler);

// Called from vectors.S
void handle_irq(void);
void handle_sync_exception(uint64_t esr, uint64_t elr, uint64_t far);
void handle_fiq(void);
void handle_serror(uint64_t esr);

// Timer functions
void timer_init(uint32_t interval_ms);
void timer_set_interval(uint32_t interval_ms);

// Get timer interrupt count (for debugging)
uint64_t timer_get_ticks(void);

// Wait for interrupt (low power sleep until next interrupt)
void wfi(void);

// Sleep for at least the specified number of milliseconds
// Uses timer ticks (10ms resolution with 100Hz timer)
void sleep_ms(uint32_t ms);

#endif // IRQ_H
</file>

<file path="kernel/memory.h">
/*
 * VibeOS Memory Management
 */

#ifndef MEMORY_H
#define MEMORY_H

#include <stdint.h>
#include <stddef.h>

// Detected RAM (set by memory_init from DTB)
extern uint64_t ram_base;
extern uint64_t ram_size;

// Heap bounds (set at runtime)
extern uint64_t heap_start;
extern uint64_t heap_end;

// Initialize memory management (parses DTB to detect RAM)
void memory_init(void);

// Simple heap allocator
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);

// Memory stats
size_t memory_used(void);
size_t memory_free(void);

#endif
</file>

<file path="kernel/mouse.h">
/*
 * VibeOS Mouse Driver
 *
 * Virtio tablet/mouse input for GUI
 */

#ifndef MOUSE_H
#define MOUSE_H

#include <stdint.h>

// Mouse button states
#define MOUSE_BTN_LEFT   0x01
#define MOUSE_BTN_RIGHT  0x02
#define MOUSE_BTN_MIDDLE 0x04

// Initialize mouse
int mouse_init(void);

// Get current mouse position (absolute, 0-32767 range from device)
void mouse_get_pos(int *x, int *y);

// Get current mouse position scaled to screen
void mouse_get_screen_pos(int *x, int *y);

// Get button state (bitmask of MOUSE_BTN_*)
uint8_t mouse_get_buttons(void);

// Check if mouse has new events
int mouse_has_event(void);

// Poll for mouse events (call regularly)
void mouse_poll(void);

// Get the mouse's IRQ number
uint32_t mouse_get_irq(void);

// IRQ handler - called from irq.c
void mouse_irq_handler(void);

#endif
</file>

<file path="kernel/net.c">
/*
 * VibeOS Network Stack
 *
 * Ethernet, ARP, IP, ICMP implementation
 */

#include "net.h"
#include "virtio_net.h"
#include "printf.h"
#include "string.h"

// Our MAC and IP
static uint8_t our_mac[6];
static uint32_t our_ip = NET_IP;

// ARP table
#define ARP_TABLE_SIZE 16
static arp_entry_t arp_table[ARP_TABLE_SIZE];

// Packet buffer
static uint8_t pkt_buf[1600];

// Broadcast MAC
static const uint8_t broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

// Ping state (for tracking echo replies)
static volatile int ping_received = 0;
static volatile uint16_t ping_id = 0;
static volatile uint16_t ping_seq = 0;

// UDP listener table
#define UDP_MAX_LISTENERS 8
typedef struct {
    uint16_t port;
    udp_recv_callback_t callback;
} udp_listener_t;
static udp_listener_t udp_listeners[UDP_MAX_LISTENERS];

// Byte order helpers (network = big endian)
static inline uint16_t htons(uint16_t x) {
    return (x >> 8) | (x << 8);
}

static inline uint16_t ntohs(uint16_t x) {
    return htons(x);
}

static inline uint32_t htonl(uint32_t x) {
    return ((x >> 24) & 0xff) |
           ((x >> 8) & 0xff00) |
           ((x << 8) & 0xff0000) |
           ((x << 24) & 0xff000000);
}

static inline uint32_t ntohl(uint32_t x) {
    return htonl(x);
}

// IP to string (static buffer - not thread safe, but we're single-threaded)
static char ip_str_buf[16];
const char *ip_to_str(uint32_t ip) {
    uint8_t *b = (uint8_t *)&ip;
    // IP is stored in network order (big endian), so first byte is most significant
    int len = 0;
    for (int i = 0; i < 4; i++) {
        int val = b[3-i];  // Reverse for our MAKE_IP macro (host order)
        if (val >= 100) {
            ip_str_buf[len++] = '0' + val / 100;
            ip_str_buf[len++] = '0' + (val / 10) % 10;
            ip_str_buf[len++] = '0' + val % 10;
        } else if (val >= 10) {
            ip_str_buf[len++] = '0' + val / 10;
            ip_str_buf[len++] = '0' + val % 10;
        } else {
            ip_str_buf[len++] = '0' + val;
        }
        if (i < 3) ip_str_buf[len++] = '.';
    }
    ip_str_buf[len] = '\0';
    return ip_str_buf;
}

void net_init(void) {
    // Get our MAC from the driver
    virtio_net_get_mac(our_mac);

    // Clear ARP table
    memset(arp_table, 0, sizeof(arp_table));

    printf("[NET] Stack initialized, IP=%s\n", ip_to_str(our_ip));
}

uint32_t net_get_ip(void) {
    return our_ip;
}

void net_get_mac(uint8_t *mac) {
    memcpy(mac, our_mac, 6);
}

// Send ethernet frame
int eth_send(const uint8_t *dst_mac, uint16_t ethertype, const void *data, uint32_t len) {
    if (len > NET_MTU - sizeof(eth_header_t)) {
        return -1;
    }

    // Build frame
    eth_header_t *eth = (eth_header_t *)pkt_buf;
    memcpy(eth->dst, dst_mac, 6);
    memcpy(eth->src, our_mac, 6);
    eth->ethertype = htons(ethertype);

    memcpy(pkt_buf + sizeof(eth_header_t), data, len);

    return virtio_net_send(pkt_buf, sizeof(eth_header_t) + len);
}

// ARP table lookup
const uint8_t *arp_lookup(uint32_t ip) {
    for (int i = 0; i < ARP_TABLE_SIZE; i++) {
        if (arp_table[i].valid && arp_table[i].ip == ip) {
            return arp_table[i].mac;
        }
    }
    return NULL;
}

// Add/update ARP entry
static void arp_add(uint32_t ip, const uint8_t *mac) {
    // Check if already exists
    for (int i = 0; i < ARP_TABLE_SIZE; i++) {
        if (arp_table[i].valid && arp_table[i].ip == ip) {
            memcpy(arp_table[i].mac, mac, 6);
            return;
        }
    }

    // Find free slot
    for (int i = 0; i < ARP_TABLE_SIZE; i++) {
        if (!arp_table[i].valid) {
            arp_table[i].ip = ip;
            memcpy(arp_table[i].mac, mac, 6);
            arp_table[i].valid = 1;
            printf("[ARP] Added %s -> %02x:%02x:%02x:%02x:%02x:%02x\n",
                   ip_to_str(ip), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
            return;
        }
    }

    // Table full - overwrite first entry (simple LRU)
    arp_table[0].ip = ip;
    memcpy(arp_table[0].mac, mac, 6);
    arp_table[0].valid = 1;
}

// Send ARP request
void arp_request(uint32_t ip) {
    arp_packet_t arp;
    arp.htype = htons(1);        // Ethernet
    arp.ptype = htons(0x0800);   // IPv4
    arp.hlen = 6;
    arp.plen = 4;
    arp.oper = htons(ARP_OP_REQUEST);
    memcpy(arp.sha, our_mac, 6);

    // Convert our IP to network byte order
    uint32_t our_ip_net = htonl(our_ip);
    memcpy(arp.spa, &our_ip_net, 4);

    memset(arp.tha, 0, 6);       // Unknown
    uint32_t ip_net = htonl(ip);
    memcpy(arp.tpa, &ip_net, 4);

    printf("[ARP] Requesting %s\n", ip_to_str(ip));
    eth_send(broadcast_mac, ETH_TYPE_ARP, &arp, sizeof(arp));
}

// Handle incoming ARP packet
static void arp_handle(const uint8_t *pkt, uint32_t len) {
    if (len < sizeof(arp_packet_t)) return;

    const arp_packet_t *arp = (const arp_packet_t *)pkt;

    // Only handle Ethernet/IPv4
    if (ntohs(arp->htype) != 1 || ntohs(arp->ptype) != 0x0800) return;
    if (arp->hlen != 6 || arp->plen != 4) return;

    uint32_t sender_ip, target_ip;
    memcpy(&sender_ip, arp->spa, 4);
    memcpy(&target_ip, arp->tpa, 4);
    sender_ip = ntohl(sender_ip);
    target_ip = ntohl(target_ip);

    uint16_t op = ntohs(arp->oper);

    // Learn sender's MAC (even if not for us)
    arp_add(sender_ip, arp->sha);

    if (op == ARP_OP_REQUEST) {
        // Is this asking for our MAC?
        if (target_ip == our_ip) {
            printf("[ARP] Request for our IP from %s\n", ip_to_str(sender_ip));

            // Send reply
            arp_packet_t reply;
            reply.htype = htons(1);
            reply.ptype = htons(0x0800);
            reply.hlen = 6;
            reply.plen = 4;
            reply.oper = htons(ARP_OP_REPLY);
            memcpy(reply.sha, our_mac, 6);
            uint32_t our_ip_net = htonl(our_ip);
            memcpy(reply.spa, &our_ip_net, 4);
            memcpy(reply.tha, arp->sha, 6);
            memcpy(reply.tpa, arp->spa, 4);

            eth_send(arp->sha, ETH_TYPE_ARP, &reply, sizeof(reply));
            printf("[ARP] Sent reply\n");
        }
    } else if (op == ARP_OP_REPLY) {
        printf("[ARP] Reply from %s\n", ip_to_str(sender_ip));
        // Already added to table above
    }
}

// IP checksum
uint16_t ip_checksum(const void *data, uint32_t len) {
    const uint16_t *ptr = (const uint16_t *)data;
    uint32_t sum = 0;

    while (len > 1) {
        sum += *ptr++;
        len -= 2;
    }

    if (len == 1) {
        sum += *(const uint8_t *)ptr;
    }

    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    return ~sum;
}

// Handle incoming ICMP packet
static void icmp_handle(const uint8_t *pkt, uint32_t len, uint32_t src_ip) {
    if (len < sizeof(icmp_header_t)) return;

    const icmp_header_t *icmp = (const icmp_header_t *)pkt;

    if (icmp->type == ICMP_ECHO_REQUEST) {
        printf("[ICMP] Echo request from %s\n", ip_to_str(src_ip));

        // Send echo reply
        uint8_t reply_buf[1500];
        icmp_header_t *reply = (icmp_header_t *)reply_buf;

        reply->type = ICMP_ECHO_REPLY;
        reply->code = 0;
        reply->checksum = 0;
        reply->id = icmp->id;
        reply->seq = icmp->seq;

        // Copy data portion
        uint32_t data_len = len - sizeof(icmp_header_t);
        if (data_len > sizeof(reply_buf) - sizeof(icmp_header_t)) {
            data_len = sizeof(reply_buf) - sizeof(icmp_header_t);
        }
        memcpy(reply_buf + sizeof(icmp_header_t), pkt + sizeof(icmp_header_t), data_len);

        // Calculate checksum
        reply->checksum = ip_checksum(reply_buf, sizeof(icmp_header_t) + data_len);

        ip_send(src_ip, IP_PROTO_ICMP, reply_buf, sizeof(icmp_header_t) + data_len);
        printf("[ICMP] Sent echo reply\n");
    }
    else if (icmp->type == ICMP_ECHO_REPLY) {
        printf("[ICMP] Echo reply from %s id=%d seq=%d\n",
               ip_to_str(src_ip), ntohs(icmp->id), ntohs(icmp->seq));

        // Check if this matches our pending ping
        if (ntohs(icmp->id) == ping_id && ntohs(icmp->seq) == ping_seq) {
            ping_received = 1;
        }
    }
}

// Handle incoming UDP packet
static void udp_handle(const uint8_t *pkt, uint32_t len, uint32_t src_ip) {
    if (len < sizeof(udp_header_t)) return;

    const udp_header_t *udp = (const udp_header_t *)pkt;
    uint16_t src_port = ntohs(udp->src_port);
    uint16_t dst_port = ntohs(udp->dst_port);
    uint16_t udp_len = ntohs(udp->length);

    if (udp_len < sizeof(udp_header_t) || udp_len > len) return;

    const uint8_t *data = pkt + sizeof(udp_header_t);
    uint32_t data_len = udp_len - sizeof(udp_header_t);

    // Find listener for this port
    for (int i = 0; i < UDP_MAX_LISTENERS; i++) {
        if (udp_listeners[i].callback && udp_listeners[i].port == dst_port) {
            udp_listeners[i].callback(src_ip, src_port, dst_port, data, data_len);
            return;
        }
    }

    // No listener - silently drop (don't spam debug output)
}

// Forward declaration for TCP handler
static void tcp_handle(const uint8_t *pkt, uint32_t len, uint32_t src_ip);

// Handle incoming IP packet
static void ip_handle(const uint8_t *pkt, uint32_t len) {
    if (len < sizeof(ip_header_t)) return;

    const ip_header_t *ip = (const ip_header_t *)pkt;

    // Check version
    if ((ip->version_ihl >> 4) != 4) return;

    // Get header length
    uint32_t ihl = (ip->version_ihl & 0x0f) * 4;
    if (ihl < 20 || ihl > len) return;

    // Check if it's for us
    uint32_t dst_ip = ntohl(ip->dst_ip);
    if (dst_ip != our_ip && dst_ip != 0xffffffff) return;

    uint32_t src_ip = ntohl(ip->src_ip);
    uint32_t payload_len = ntohs(ip->total_len) - ihl;
    const uint8_t *payload = pkt + ihl;

    switch (ip->protocol) {
        case IP_PROTO_ICMP:
            icmp_handle(payload, payload_len, src_ip);
            break;
        case IP_PROTO_UDP:
            udp_handle(payload, payload_len, src_ip);
            break;
        case IP_PROTO_TCP:
            tcp_handle(payload, payload_len, src_ip);
            break;
        default:
            printf("[IP] Unknown protocol %d from %s\n", ip->protocol, ip_to_str(src_ip));
            break;
    }
}

// Send IP packet
int ip_send(uint32_t dst_ip, uint8_t protocol, const void *data, uint32_t len) {
    if (len > NET_MTU - sizeof(eth_header_t) - sizeof(ip_header_t)) {
        return -1;
    }

    // Determine next hop MAC
    const uint8_t *dst_mac;
    uint32_t next_hop = dst_ip;

    // If destination is not on local network, use gateway
    if ((dst_ip & NET_NETMASK) != (our_ip & NET_NETMASK)) {
        next_hop = NET_GATEWAY;
    }

    dst_mac = arp_lookup(next_hop);
    if (!dst_mac) {
        // Need to ARP first
        printf("[IP] No ARP entry for %s, sending request\n", ip_to_str(next_hop));
        arp_request(next_hop);
        return -1;  // Caller should retry
    }

    // Build IP packet
    static uint8_t ip_buf[1600];
    ip_header_t *ip = (ip_header_t *)ip_buf;

    ip->version_ihl = 0x45;  // IPv4, 20 byte header
    ip->tos = 0;
    ip->total_len = htons(sizeof(ip_header_t) + len);
    ip->id = htons(0);  // TODO: track ID
    ip->flags_frag = 0;
    ip->ttl = 64;
    ip->protocol = protocol;
    ip->checksum = 0;
    ip->src_ip = htonl(our_ip);
    ip->dst_ip = htonl(dst_ip);

    // Calculate header checksum
    ip->checksum = ip_checksum(ip, sizeof(ip_header_t));

    // Copy payload
    memcpy(ip_buf + sizeof(ip_header_t), data, len);

    return eth_send(dst_mac, ETH_TYPE_IP, ip_buf, sizeof(ip_header_t) + len);
}

// Send ICMP echo request
int icmp_send_echo_request(uint32_t dst_ip, uint16_t id, uint16_t seq, const void *data, uint32_t len) {
    uint8_t icmp_buf[1500];
    icmp_header_t *icmp = (icmp_header_t *)icmp_buf;

    icmp->type = ICMP_ECHO_REQUEST;
    icmp->code = 0;
    icmp->checksum = 0;
    icmp->id = htons(id);
    icmp->seq = htons(seq);

    // Copy data
    if (len > sizeof(icmp_buf) - sizeof(icmp_header_t)) {
        len = sizeof(icmp_buf) - sizeof(icmp_header_t);
    }
    if (data && len > 0) {
        memcpy(icmp_buf + sizeof(icmp_header_t), data, len);
    }

    // Calculate checksum
    icmp->checksum = ip_checksum(icmp_buf, sizeof(icmp_header_t) + len);

    return ip_send(dst_ip, IP_PROTO_ICMP, icmp_buf, sizeof(icmp_header_t) + len);
}

// Process incoming packets
void net_poll(void) {
    static uint8_t rx_buf[1600];

    while (virtio_net_has_packet()) {
        int len = virtio_net_recv(rx_buf, sizeof(rx_buf));
        if (len <= 0) break;

        if (len < (int)sizeof(eth_header_t)) continue;

        eth_header_t *eth = (eth_header_t *)rx_buf;
        uint16_t ethertype = ntohs(eth->ethertype);

        const uint8_t *payload = rx_buf + sizeof(eth_header_t);
        uint32_t payload_len = len - sizeof(eth_header_t);

        switch (ethertype) {
            case ETH_TYPE_ARP:
                arp_handle(payload, payload_len);
                break;
            case ETH_TYPE_IP:
                ip_handle(payload, payload_len);
                break;
            default:
                // Ignore unknown ethertypes
                break;
        }
    }
}

// Blocking ping with timeout
int net_ping(uint32_t ip, uint16_t seq, uint32_t timeout_ms) {
    // First, make sure we have ARP entry for the target (or gateway)
    uint32_t next_hop = ip;
    if ((ip & NET_NETMASK) != (our_ip & NET_NETMASK)) {
        next_hop = NET_GATEWAY;
    }

    // Try to get ARP entry, send request if needed
    if (!arp_lookup(next_hop)) {
        arp_request(next_hop);

        // Wait for ARP reply (up to 1 second)
        for (int i = 0; i < 100 && !arp_lookup(next_hop); i++) {
            net_poll();
            // Simple delay (~10ms)
            for (volatile int j = 0; j < 100000; j++);
        }

        if (!arp_lookup(next_hop)) {
            printf("[PING] ARP timeout for %s\n", ip_to_str(next_hop));
            return -1;
        }
    }

    // Set up ping tracking
    ping_id = 0x1234;
    ping_seq = seq;
    ping_received = 0;

    // Send echo request
    uint8_t ping_data[56];
    memset(ping_data, 0xAB, sizeof(ping_data));

    if (icmp_send_echo_request(ip, ping_id, seq, ping_data, sizeof(ping_data)) < 0) {
        return -1;
    }

    // Wait for reply
    for (uint32_t i = 0; i < timeout_ms / 10 && !ping_received; i++) {
        net_poll();
        // Simple delay (~10ms)
        for (volatile int j = 0; j < 100000; j++);
    }

    if (ping_received) {
        return 0;  // TODO: return actual RTT
    }

    return -1;  // Timeout
}

// UDP bind - register a listener for a port
void udp_bind(uint16_t port, udp_recv_callback_t callback) {
    // Check if already bound
    for (int i = 0; i < UDP_MAX_LISTENERS; i++) {
        if (udp_listeners[i].port == port && udp_listeners[i].callback) {
            // Replace existing listener
            udp_listeners[i].callback = callback;
            return;
        }
    }

    // Find free slot
    for (int i = 0; i < UDP_MAX_LISTENERS; i++) {
        if (!udp_listeners[i].callback) {
            udp_listeners[i].port = port;
            udp_listeners[i].callback = callback;
            return;
        }
    }

    printf("[UDP] No free listener slots!\n");
}

// UDP unbind - remove a listener
void udp_unbind(uint16_t port) {
    for (int i = 0; i < UDP_MAX_LISTENERS; i++) {
        if (udp_listeners[i].port == port) {
            udp_listeners[i].callback = NULL;
            udp_listeners[i].port = 0;
            return;
        }
    }
}

// Send UDP packet
int udp_send(uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, const void *data, uint32_t len) {
    if (len > NET_MTU - sizeof(eth_header_t) - sizeof(ip_header_t) - sizeof(udp_header_t)) {
        return -1;
    }

    // Build UDP packet
    uint8_t udp_buf[1500];
    udp_header_t *udp = (udp_header_t *)udp_buf;

    udp->src_port = htons(src_port);
    udp->dst_port = htons(dst_port);
    udp->length = htons(sizeof(udp_header_t) + len);
    udp->checksum = 0;  // Checksum optional for IPv4

    // Copy data
    memcpy(udp_buf + sizeof(udp_header_t), data, len);

    return ip_send(dst_ip, IP_PROTO_UDP, udp_buf, sizeof(udp_header_t) + len);
}

// DNS resolver
// Simple implementation - sends query to NET_DNS and waits for response

// DNS header
typedef struct __attribute__((packed)) {
    uint16_t id;
    uint16_t flags;
    uint16_t qdcount;
    uint16_t ancount;
    uint16_t nscount;
    uint16_t arcount;
} dns_header_t;

// DNS response state
static volatile int dns_response_received = 0;
static volatile uint32_t dns_resolved_ip = 0;
static volatile uint16_t dns_query_id = 0;

// DNS response handler
static void dns_recv_handler(uint32_t src_ip, uint16_t src_port, uint16_t dst_port, const void *data, uint32_t len) {
    (void)src_ip; (void)src_port; (void)dst_port;

    if (len < sizeof(dns_header_t)) return;

    const dns_header_t *dns = (const dns_header_t *)data;

    // Check if this is response to our query
    if (ntohs(dns->id) != dns_query_id) return;

    // Check flags: QR=1 (response), RCODE=0 (no error)
    uint16_t flags = ntohs(dns->flags);
    if (!(flags & 0x8000)) return;  // Not a response
    if (flags & 0x000f) return;     // Error code set

    uint16_t ancount = ntohs(dns->ancount);
    if (ancount == 0) return;  // No answers

    // Skip header and question section
    const uint8_t *ptr = (const uint8_t *)data + sizeof(dns_header_t);
    const uint8_t *end = (const uint8_t *)data + len;

    // Skip question (QNAME + QTYPE + QCLASS)
    // QNAME is a sequence of labels ending with 0
    while (ptr < end && *ptr != 0) {
        if ((*ptr & 0xc0) == 0xc0) {
            // Pointer - skip 2 bytes
            ptr += 2;
            goto parse_answer;
        }
        ptr += 1 + *ptr;  // Skip length byte + label
    }
    if (ptr < end) ptr++;  // Skip null terminator
    ptr += 4;  // Skip QTYPE (2) + QCLASS (2)

parse_answer:
    // Parse answer records
    for (int i = 0; i < ancount && ptr + 12 <= end; i++) {
        // Skip NAME (may be pointer)
        if ((*ptr & 0xc0) == 0xc0) {
            ptr += 2;  // Pointer
        } else {
            while (ptr < end && *ptr != 0) {
                ptr += 1 + *ptr;
            }
            if (ptr < end) ptr++;
        }

        if (ptr + 10 > end) break;

        uint16_t type = (ptr[0] << 8) | ptr[1];
        // uint16_t class = (ptr[2] << 8) | ptr[3];
        // uint32_t ttl = (ptr[4] << 24) | (ptr[5] << 16) | (ptr[6] << 8) | ptr[7];
        uint16_t rdlength = (ptr[8] << 8) | ptr[9];
        ptr += 10;

        if (ptr + rdlength > end) break;

        // Type A = 1 (IPv4 address)
        if (type == 1 && rdlength == 4) {
            // Found an A record!
            dns_resolved_ip = MAKE_IP(ptr[0], ptr[1], ptr[2], ptr[3]);
            dns_response_received = 1;
            return;
        }

        ptr += rdlength;
    }
}

// Resolve hostname to IP
uint32_t dns_resolve(const char *hostname) {
    // Build DNS query
    uint8_t query[512];
    dns_header_t *dns = (dns_header_t *)query;

    // Use a simple incrementing ID
    static uint16_t next_id = 1;
    dns_query_id = next_id++;

    dns->id = htons(dns_query_id);
    dns->flags = htons(0x0100);  // RD (recursion desired)
    dns->qdcount = htons(1);
    dns->ancount = 0;
    dns->nscount = 0;
    dns->arcount = 0;

    // Build QNAME from hostname
    uint8_t *ptr = query + sizeof(dns_header_t);
    const char *src = hostname;

    while (*src) {
        // Find next dot or end
        const char *dot = src;
        while (*dot && *dot != '.') dot++;

        uint8_t label_len = dot - src;
        if (label_len > 63) return 0;  // Label too long

        *ptr++ = label_len;
        while (src < dot) {
            *ptr++ = *src++;
        }
        if (*src == '.') src++;
    }
    *ptr++ = 0;  // Null terminator

    // QTYPE = A (1), QCLASS = IN (1)
    *ptr++ = 0; *ptr++ = 1;  // QTYPE
    *ptr++ = 0; *ptr++ = 1;  // QCLASS

    uint32_t query_len = ptr - query;

    // Bind to receive DNS responses on port 53 (we're the client, but use same port for simplicity)
    // Actually, use ephemeral port
    uint16_t local_port = 10053 + (dns_query_id % 100);
    dns_response_received = 0;
    dns_resolved_ip = 0;

    udp_bind(local_port, dns_recv_handler);

    // First, make sure we can reach DNS server (ARP)
    uint32_t dns_server = NET_DNS;
    uint32_t next_hop = dns_server;
    if ((dns_server & NET_NETMASK) != (our_ip & NET_NETMASK)) {
        next_hop = NET_GATEWAY;
    }

    if (!arp_lookup(next_hop)) {
        arp_request(next_hop);
        for (int i = 0; i < 100 && !arp_lookup(next_hop); i++) {
            net_poll();
            for (volatile int j = 0; j < 100000; j++);
        }
        if (!arp_lookup(next_hop)) {
            udp_unbind(local_port);
            return 0;
        }
    }

    // Send DNS query
    if (udp_send(dns_server, local_port, 53, query, query_len) < 0) {
        udp_unbind(local_port);
        return 0;
    }

    // Wait for response (up to 5 seconds)
    for (int i = 0; i < 500 && !dns_response_received; i++) {
        net_poll();
        for (volatile int j = 0; j < 100000; j++);
    }

    udp_unbind(local_port);

    if (dns_response_received) {
        printf("[DNS] Resolved %s -> %s\n", hostname, ip_to_str(dns_resolved_ip));
        return dns_resolved_ip;
    }

    printf("[DNS] Failed to resolve %s\n", hostname);
    return 0;
}

// ============ TCP Implementation ============

// TCP socket structure
#define TCP_MAX_SOCKETS 8
#define TCP_RX_BUF_SIZE 8192
#define TCP_TX_BUF_SIZE 4096

typedef struct {
    int state;
    uint32_t local_ip;
    uint32_t remote_ip;
    uint16_t local_port;
    uint16_t remote_port;

    // Sequence numbers
    uint32_t send_seq;      // Next byte we'll send
    uint32_t send_ack;      // Last ACK we sent (next byte we expect)
    uint32_t recv_seq;      // For tracking incoming data

    // Receive buffer (ring buffer)
    uint8_t rx_buf[TCP_RX_BUF_SIZE];
    uint32_t rx_head;       // Write position
    uint32_t rx_tail;       // Read position

    // Flags
    uint8_t fin_received;   // Remote sent FIN
    uint8_t fin_sent;       // We sent FIN
} tcp_socket_internal_t;

static tcp_socket_internal_t tcp_sockets[TCP_MAX_SOCKETS];
static uint16_t tcp_next_port = 49152;  // Ephemeral port range

// TCP pseudo-header for checksum
typedef struct __attribute__((packed)) {
    uint32_t src_ip;
    uint32_t dst_ip;
    uint8_t zero;
    uint8_t protocol;
    uint16_t tcp_len;
} tcp_pseudo_header_t;

// Calculate TCP checksum (includes pseudo-header)
static uint16_t tcp_checksum(uint32_t src_ip, uint32_t dst_ip,
                              const tcp_header_t *tcp, const void *data, uint32_t data_len) {
    uint32_t sum = 0;

    // Pseudo-header
    sum += (src_ip >> 16) & 0xffff;
    sum += src_ip & 0xffff;
    sum += (dst_ip >> 16) & 0xffff;
    sum += dst_ip & 0xffff;
    sum += htons(IP_PROTO_TCP);
    sum += htons(sizeof(tcp_header_t) + data_len);

    // TCP header
    const uint16_t *ptr = (const uint16_t *)tcp;
    for (int i = 0; i < (int)(sizeof(tcp_header_t) / 2); i++) {
        sum += ptr[i];
    }

    // Data
    ptr = (const uint16_t *)data;
    while (data_len > 1) {
        sum += *ptr++;
        data_len -= 2;
    }
    if (data_len == 1) {
        sum += *(const uint8_t *)ptr;
    }

    // Fold 32-bit sum to 16 bits
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    return ~sum;
}

// Send a TCP segment
static int tcp_send_segment(tcp_socket_internal_t *sock, uint8_t flags,
                            const void *data, uint32_t len) {
    uint8_t pkt[1500];
    tcp_header_t *tcp = (tcp_header_t *)pkt;

    tcp->src_port = htons(sock->local_port);
    tcp->dst_port = htons(sock->remote_port);
    tcp->seq = htonl(sock->send_seq);
    tcp->ack = htonl(sock->send_ack);
    tcp->data_off = (5 << 4);  // 20 bytes, no options
    tcp->flags = flags;
    tcp->window = htons(TCP_RX_BUF_SIZE);
    tcp->checksum = 0;
    tcp->urgent = 0;

    // Copy data
    if (data && len > 0) {
        memcpy(pkt + sizeof(tcp_header_t), data, len);
    }

    // Calculate checksum
    tcp->checksum = tcp_checksum(htonl(sock->local_ip), htonl(sock->remote_ip),
                                  tcp, data, len);

    return ip_send(sock->remote_ip, IP_PROTO_TCP, pkt, sizeof(tcp_header_t) + len);
}

// Find socket by connection tuple
static tcp_socket_internal_t *tcp_find_socket(uint32_t remote_ip, uint16_t remote_port,
                                               uint16_t local_port) {
    for (int i = 0; i < TCP_MAX_SOCKETS; i++) {
        tcp_socket_internal_t *s = &tcp_sockets[i];
        if (s->state != TCP_STATE_CLOSED &&
            s->remote_ip == remote_ip &&
            s->remote_port == remote_port &&
            s->local_port == local_port) {
            return s;
        }
    }
    return NULL;
}

// Get socket index
static int tcp_socket_index(tcp_socket_internal_t *sock) {
    return sock - tcp_sockets;
}

// Handle incoming TCP packet
static void tcp_handle(const uint8_t *pkt, uint32_t len, uint32_t src_ip) {
    if (len < sizeof(tcp_header_t)) return;

    const tcp_header_t *tcp = (const tcp_header_t *)pkt;
    uint16_t src_port = ntohs(tcp->src_port);
    uint16_t dst_port = ntohs(tcp->dst_port);
    uint32_t seq = ntohl(tcp->seq);
    uint32_t ack = ntohl(tcp->ack);
    uint8_t flags = tcp->flags;

    // Calculate data offset and length
    uint32_t data_off = (tcp->data_off >> 4) * 4;
    if (data_off < sizeof(tcp_header_t) || data_off > len) return;

    const uint8_t *data = pkt + data_off;
    uint32_t data_len = len - data_off;

    // Find matching socket
    tcp_socket_internal_t *sock = tcp_find_socket(src_ip, src_port, dst_port);
    if (!sock) {
        // No socket - send RST if not a RST
        if (!(flags & TCP_RST)) {
            // TODO: send RST
        }
        return;
    }

    // Handle RST
    if (flags & TCP_RST) {
        printf("[TCP] Connection reset by peer\n");
        sock->state = TCP_STATE_CLOSED;
        return;
    }

    // State machine
    switch (sock->state) {
        case TCP_STATE_SYN_SENT:
            // Expecting SYN+ACK
            if ((flags & (TCP_SYN | TCP_ACK)) == (TCP_SYN | TCP_ACK)) {
                if (ack == sock->send_seq + 1) {
                    sock->send_seq = ack;
                    sock->send_ack = seq + 1;
                    sock->recv_seq = seq + 1;

                    // Send ACK
                    tcp_send_segment(sock, TCP_ACK, NULL, 0);
                    sock->state = TCP_STATE_ESTABLISHED;
                    printf("[TCP] Connection established\n");
                }
            }
            break;

        case TCP_STATE_ESTABLISHED:
            // Check if ACK is valid
            if (flags & TCP_ACK) {
                // Update send_seq if this ACKs new data
                if (ack > sock->send_seq - 1000 && ack <= sock->send_seq + 10000) {
                    // Valid ACK range (rough check)
                }
            }

            // Handle incoming data
            if (data_len > 0) {
                // Check if this is the next expected segment
                if (seq == sock->send_ack) {
                    // Copy data to receive buffer
                    for (uint32_t i = 0; i < data_len; i++) {
                        uint32_t next_head = (sock->rx_head + 1) % TCP_RX_BUF_SIZE;
                        if (next_head == sock->rx_tail) {
                            // Buffer full
                            break;
                        }
                        sock->rx_buf[sock->rx_head] = data[i];
                        sock->rx_head = next_head;
                    }

                    // Update ACK
                    sock->send_ack = seq + data_len;

                    // Send ACK
                    tcp_send_segment(sock, TCP_ACK, NULL, 0);
                }
            }

            // Handle FIN
            if (flags & TCP_FIN) {
                sock->fin_received = 1;
                sock->send_ack = seq + data_len + 1;
                tcp_send_segment(sock, TCP_ACK, NULL, 0);
                sock->state = TCP_STATE_CLOSE_WAIT;
                printf("[TCP] Received FIN, connection closing\n");
            }
            break;

        case TCP_STATE_FIN_WAIT_1:
            if (flags & TCP_ACK) {
                if (flags & TCP_FIN) {
                    // Simultaneous close
                    sock->send_ack = seq + 1;
                    tcp_send_segment(sock, TCP_ACK, NULL, 0);
                    sock->state = TCP_STATE_TIME_WAIT;
                } else {
                    sock->state = TCP_STATE_FIN_WAIT_2;
                }
            }
            break;

        case TCP_STATE_FIN_WAIT_2:
            if (flags & TCP_FIN) {
                sock->send_ack = seq + 1;
                tcp_send_segment(sock, TCP_ACK, NULL, 0);
                sock->state = TCP_STATE_TIME_WAIT;
            }
            break;

        case TCP_STATE_CLOSE_WAIT:
            // Waiting for application to close
            break;

        case TCP_STATE_LAST_ACK:
            if (flags & TCP_ACK) {
                sock->state = TCP_STATE_CLOSED;
                printf("[TCP] Connection closed\n");
            }
            break;

        case TCP_STATE_TIME_WAIT:
            // Should wait 2*MSL, but we just close immediately
            sock->state = TCP_STATE_CLOSED;
            break;

        default:
            break;
    }
}

// Public API

tcp_socket_t tcp_connect(uint32_t ip, uint16_t port) {
    // Find free socket
    int idx = -1;
    for (int i = 0; i < TCP_MAX_SOCKETS; i++) {
        if (tcp_sockets[i].state == TCP_STATE_CLOSED) {
            idx = i;
            break;
        }
    }
    if (idx < 0) {
        printf("[TCP] No free sockets\n");
        return -1;
    }

    tcp_socket_internal_t *sock = &tcp_sockets[idx];
    memset(sock, 0, sizeof(*sock));

    sock->local_ip = our_ip;
    sock->remote_ip = ip;
    sock->local_port = tcp_next_port++;
    sock->remote_port = port;
    sock->send_seq = 1000 + (tcp_next_port * 1234);  // Simple ISN
    sock->send_ack = 0;
    sock->state = TCP_STATE_SYN_SENT;

    // ARP resolve first
    uint32_t next_hop = ip;
    if ((ip & NET_NETMASK) != (our_ip & NET_NETMASK)) {
        next_hop = NET_GATEWAY;
    }

    if (!arp_lookup(next_hop)) {
        arp_request(next_hop);
        for (int i = 0; i < 100 && !arp_lookup(next_hop); i++) {
            net_poll();
            for (volatile int j = 0; j < 100000; j++);
        }
        if (!arp_lookup(next_hop)) {
            printf("[TCP] ARP failed for %s\n", ip_to_str(next_hop));
            sock->state = TCP_STATE_CLOSED;
            return -1;
        }
    }

    // Send SYN
    printf("[TCP] Connecting to %s:%d\n", ip_to_str(ip), port);
    if (tcp_send_segment(sock, TCP_SYN, NULL, 0) < 0) {
        sock->state = TCP_STATE_CLOSED;
        return -1;
    }

    // Wait for SYN+ACK (up to 10 seconds)
    for (int i = 0; i < 1000 && sock->state == TCP_STATE_SYN_SENT; i++) {
        net_poll();
        for (volatile int j = 0; j < 100000; j++);
    }

    if (sock->state != TCP_STATE_ESTABLISHED) {
        printf("[TCP] Connection timeout\n");
        sock->state = TCP_STATE_CLOSED;
        return -1;
    }

    return idx;
}

int tcp_send(tcp_socket_t sock_id, const void *data, uint32_t len) {
    if (sock_id < 0 || sock_id >= TCP_MAX_SOCKETS) return -1;

    tcp_socket_internal_t *sock = &tcp_sockets[sock_id];
    if (sock->state != TCP_STATE_ESTABLISHED) return -1;

    // Send data in chunks (MSS ~1460, use 1400 to be safe)
    const uint8_t *ptr = (const uint8_t *)data;
    uint32_t sent = 0;

    while (sent < len) {
        uint32_t chunk = len - sent;
        if (chunk > 1400) chunk = 1400;

        if (tcp_send_segment(sock, TCP_ACK | TCP_PSH, ptr + sent, chunk) < 0) {
            return sent > 0 ? (int)sent : -1;
        }

        sock->send_seq += chunk;
        sent += chunk;

        // Small delay between segments
        for (volatile int j = 0; j < 10000; j++);
    }

    return (int)sent;
}

int tcp_recv(tcp_socket_t sock_id, void *buf, uint32_t maxlen) {
    if (sock_id < 0 || sock_id >= TCP_MAX_SOCKETS) return -1;

    tcp_socket_internal_t *sock = &tcp_sockets[sock_id];

    // Poll for incoming data
    net_poll();

    // Check for data in receive buffer
    uint8_t *dst = (uint8_t *)buf;
    uint32_t received = 0;

    while (received < maxlen && sock->rx_tail != sock->rx_head) {
        dst[received++] = sock->rx_buf[sock->rx_tail];
        sock->rx_tail = (sock->rx_tail + 1) % TCP_RX_BUF_SIZE;
    }

    // If no data and connection closed, return -1
    if (received == 0) {
        if (sock->state == TCP_STATE_CLOSE_WAIT ||
            sock->state == TCP_STATE_CLOSED) {
            return -1;
        }
        return 0;  // No data yet
    }

    return (int)received;
}

void tcp_close(tcp_socket_t sock_id) {
    if (sock_id < 0 || sock_id >= TCP_MAX_SOCKETS) return;

    tcp_socket_internal_t *sock = &tcp_sockets[sock_id];

    if (sock->state == TCP_STATE_ESTABLISHED) {
        // Send FIN
        tcp_send_segment(sock, TCP_FIN | TCP_ACK, NULL, 0);
        sock->send_seq++;
        sock->fin_sent = 1;
        sock->state = TCP_STATE_FIN_WAIT_1;

        // Wait for close to complete (up to 5 seconds)
        for (int i = 0; i < 500 && sock->state != TCP_STATE_CLOSED &&
                                   sock->state != TCP_STATE_TIME_WAIT; i++) {
            net_poll();
            for (volatile int j = 0; j < 100000; j++);
        }
    } else if (sock->state == TCP_STATE_CLOSE_WAIT) {
        // Send FIN
        tcp_send_segment(sock, TCP_FIN | TCP_ACK, NULL, 0);
        sock->send_seq++;
        sock->state = TCP_STATE_LAST_ACK;

        // Wait for ACK
        for (int i = 0; i < 500 && sock->state != TCP_STATE_CLOSED; i++) {
            net_poll();
            for (volatile int j = 0; j < 100000; j++);
        }
    }

    sock->state = TCP_STATE_CLOSED;
}

int tcp_is_connected(tcp_socket_t sock_id) {
    if (sock_id < 0 || sock_id >= TCP_MAX_SOCKETS) return 0;
    return tcp_sockets[sock_id].state == TCP_STATE_ESTABLISHED;
}

int tcp_get_state(tcp_socket_t sock_id) {
    if (sock_id < 0 || sock_id >= TCP_MAX_SOCKETS) return TCP_STATE_CLOSED;
    return tcp_sockets[sock_id].state;
}
</file>

<file path="kernel/net.h">
/*
 * VibeOS Network Stack
 *
 * Ethernet, ARP, IP, ICMP handling
 */

#ifndef NET_H
#define NET_H

#include <stdint.h>
#include <stddef.h>

// Ethernet frame header
typedef struct __attribute__((packed)) {
    uint8_t dst[6];
    uint8_t src[6];
    uint16_t ethertype;
} eth_header_t;

// Ethertypes (big-endian on wire)
#define ETH_TYPE_IP   0x0800
#define ETH_TYPE_ARP  0x0806

// ARP packet
typedef struct __attribute__((packed)) {
    uint16_t htype;      // Hardware type (1 = Ethernet)
    uint16_t ptype;      // Protocol type (0x0800 = IPv4)
    uint8_t hlen;        // Hardware address length (6 for Ethernet)
    uint8_t plen;        // Protocol address length (4 for IPv4)
    uint16_t oper;       // Operation (1 = request, 2 = reply)
    uint8_t sha[6];      // Sender hardware address
    uint8_t spa[4];      // Sender protocol address
    uint8_t tha[6];      // Target hardware address
    uint8_t tpa[4];      // Target protocol address
} arp_packet_t;

#define ARP_OP_REQUEST  1
#define ARP_OP_REPLY    2

// IP header
typedef struct __attribute__((packed)) {
    uint8_t version_ihl;    // Version (4 bits) + IHL (4 bits)
    uint8_t tos;            // Type of service
    uint16_t total_len;     // Total length
    uint16_t id;            // Identification
    uint16_t flags_frag;    // Flags (3 bits) + Fragment offset (13 bits)
    uint8_t ttl;            // Time to live
    uint8_t protocol;       // Protocol (1=ICMP, 6=TCP, 17=UDP)
    uint16_t checksum;      // Header checksum
    uint32_t src_ip;        // Source IP
    uint32_t dst_ip;        // Destination IP
} ip_header_t;

// IP protocols
#define IP_PROTO_ICMP  1
#define IP_PROTO_TCP   6
#define IP_PROTO_UDP   17

// ICMP header
typedef struct __attribute__((packed)) {
    uint8_t type;
    uint8_t code;
    uint16_t checksum;
    uint16_t id;
    uint16_t seq;
} icmp_header_t;

// ICMP types
#define ICMP_ECHO_REPLY    0
#define ICMP_ECHO_REQUEST  8

// UDP header
typedef struct __attribute__((packed)) {
    uint16_t src_port;
    uint16_t dst_port;
    uint16_t length;
    uint16_t checksum;
} udp_header_t;

// ARP table entry
typedef struct {
    uint32_t ip;
    uint8_t mac[6];
    uint8_t valid;
    uint32_t timestamp;  // For expiry (future)
} arp_entry_t;

// Network configuration (QEMU user-mode defaults)
#define NET_IP          0x0a00020f  // 10.0.2.15
#define NET_GATEWAY     0x0a000202  // 10.0.2.2
#define NET_DNS         0x0a000203  // 10.0.2.3
#define NET_NETMASK     0xffffff00  // 255.255.255.0

// Initialize network stack
void net_init(void);

// Process incoming packets (call from main loop or IRQ)
void net_poll(void);

// Send raw ethernet frame
int eth_send(const uint8_t *dst_mac, uint16_t ethertype, const void *data, uint32_t len);

// ARP functions
void arp_request(uint32_t ip);
const uint8_t *arp_lookup(uint32_t ip);

// IP functions
int ip_send(uint32_t dst_ip, uint8_t protocol, const void *data, uint32_t len);
uint16_t ip_checksum(const void *data, uint32_t len);

// ICMP functions
int icmp_send_echo_request(uint32_t dst_ip, uint16_t id, uint16_t seq, const void *data, uint32_t len);

// Ping interface (blocking, with timeout)
// Returns round-trip time in ms, or -1 on timeout
int net_ping(uint32_t ip, uint16_t seq, uint32_t timeout_ms);

// Get our IP/MAC
uint32_t net_get_ip(void);
void net_get_mac(uint8_t *mac);

// Helper: convert IP to string (uses static buffer)
const char *ip_to_str(uint32_t ip);

// Helper: make IP from bytes
#define MAKE_IP(a,b,c,d) (((uint32_t)(a)<<24)|((uint32_t)(b)<<16)|((uint32_t)(c)<<8)|(uint32_t)(d))

// UDP functions
int udp_send(uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, const void *data, uint32_t len);

// UDP receive callback type
typedef void (*udp_recv_callback_t)(uint32_t src_ip, uint16_t src_port, uint16_t dst_port, const void *data, uint32_t len);

// Register a UDP listener on a port
void udp_bind(uint16_t port, udp_recv_callback_t callback);

// Unregister a UDP listener
void udp_unbind(uint16_t port);

// DNS resolver (uses UDP)
// Returns IP address, or 0 on failure
uint32_t dns_resolve(const char *hostname);

// ============ TCP ============

// TCP header
typedef struct __attribute__((packed)) {
    uint16_t src_port;
    uint16_t dst_port;
    uint32_t seq;
    uint32_t ack;
    uint8_t data_off;    // Data offset (4 bits) + reserved (4 bits)
    uint8_t flags;
    uint16_t window;
    uint16_t checksum;
    uint16_t urgent;
} tcp_header_t;

// TCP flags
#define TCP_FIN  0x01
#define TCP_SYN  0x02
#define TCP_RST  0x04
#define TCP_PSH  0x08
#define TCP_ACK  0x10
#define TCP_URG  0x20

// TCP states
#define TCP_STATE_CLOSED      0
#define TCP_STATE_SYN_SENT    1
#define TCP_STATE_ESTABLISHED 2
#define TCP_STATE_FIN_WAIT_1  3
#define TCP_STATE_FIN_WAIT_2  4
#define TCP_STATE_CLOSE_WAIT  5
#define TCP_STATE_LAST_ACK    6
#define TCP_STATE_TIME_WAIT   7

// TCP socket handle (opaque)
typedef int tcp_socket_t;

// TCP API
// Returns socket handle (>=0) or -1 on error
tcp_socket_t tcp_connect(uint32_t ip, uint16_t port);

// Send data on connected socket
// Returns bytes sent or -1 on error
int tcp_send(tcp_socket_t sock, const void *data, uint32_t len);

// Receive data from connected socket
// Returns bytes received, 0 if no data, -1 on error/closed
int tcp_recv(tcp_socket_t sock, void *buf, uint32_t maxlen);

// Close socket
void tcp_close(tcp_socket_t sock);

// Check if socket is connected
int tcp_is_connected(tcp_socket_t sock);

// Get socket state (for debugging)
int tcp_get_state(tcp_socket_t sock);

#endif
</file>

<file path="kernel/string.c">
/*
 * VibeOS String Functions
 */

#include "string.h"
#include "memory.h"

void *memcpy(void *dest, const void *src, size_t n) {
    uint8_t *d = (uint8_t *)dest;
    const uint8_t *s = (const uint8_t *)src;
    for (size_t i = 0; i < n; i++) {
        d[i] = s[i];
    }
    return dest;
}

void *memset(void *s, int c, size_t n) {
    uint8_t *p = (uint8_t *)s;
    for (size_t i = 0; i < n; i++) {
        p[i] = (uint8_t)c;
    }
    return s;
}

void *memmove(void *dest, const void *src, size_t n) {
    uint8_t *d = (uint8_t *)dest;
    const uint8_t *s = (const uint8_t *)src;

    if (d < s) {
        // Copy forwards
        for (size_t i = 0; i < n; i++) {
            d[i] = s[i];
        }
    } else if (d > s) {
        // Copy backwards to handle overlap
        for (size_t i = n; i > 0; i--) {
            d[i - 1] = s[i - 1];
        }
    }
    return dest;
}

int memcmp(const void *s1, const void *s2, size_t n) {
    const uint8_t *p1 = (const uint8_t *)s1;
    const uint8_t *p2 = (const uint8_t *)s2;
    for (size_t i = 0; i < n; i++) {
        if (p1[i] != p2[i]) {
            return p1[i] - p2[i];
        }
    }
    return 0;
}

size_t strlen(const char *s) {
    size_t len = 0;
    while (s[len]) {
        len++;
    }
    return len;
}

char *strcpy(char *dest, const char *src) {
    char *d = dest;
    while ((*d++ = *src++));
    return dest;
}

char *strncpy(char *dest, const char *src, size_t n) {
    size_t i;
    for (i = 0; i < n && src[i]; i++) {
        dest[i] = src[i];
    }
    for (; i < n; i++) {
        dest[i] = '\0';
    }
    return dest;
}

int strcmp(const char *s1, const char *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}

int strncmp(const char *s1, const char *s2, size_t n) {
    for (size_t i = 0; i < n; i++) {
        if (s1[i] != s2[i]) {
            return (unsigned char)s1[i] - (unsigned char)s2[i];
        }
        if (s1[i] == '\0') {
            return 0;
        }
    }
    return 0;
}

char *strcat(char *dest, const char *src) {
    char *d = dest;
    while (*d) d++;
    while ((*d++ = *src++));
    return dest;
}

char *strchr(const char *s, int c) {
    while (*s) {
        if (*s == (char)c) {
            return (char *)s;
        }
        s++;
    }
    return (c == '\0') ? (char *)s : NULL;
}

char *strrchr(const char *s, int c) {
    const char *last = NULL;
    while (*s) {
        if (*s == (char)c) {
            last = s;
        }
        s++;
    }
    return (c == '\0') ? (char *)s : (char *)last;
}

char *strdup(const char *s) {
    size_t len = strlen(s) + 1;
    char *new = malloc(len);
    if (new) {
        memcpy(new, s, len);
    }
    return new;
}

static char tolower(char c) {
    if (c >= 'A' && c <= 'Z') {
        return c + ('a' - 'A');
    }
    return c;
}

int strcasecmp(const char *s1, const char *s2) {
    while (*s1 && *s2) {
        char c1 = tolower(*s1);
        char c2 = tolower(*s2);
        if (c1 != c2) {
            return c1 - c2;
        }
        s1++;
        s2++;
    }
    return tolower(*s1) - tolower(*s2);
}

// Check if character is in delimiter string
static int is_delim(char c, const char *delim) {
    while (*delim) {
        if (c == *delim) return 1;
        delim++;
    }
    return 0;
}

char *strtok_r(char *str, const char *delim, char **saveptr) {
    char *start;
    char *end;

    if (str) {
        start = str;
    } else {
        start = *saveptr;
    }

    if (!start) return NULL;

    // Skip leading delimiters
    while (*start && is_delim(*start, delim)) {
        start++;
    }

    if (*start == '\0') {
        *saveptr = NULL;
        return NULL;
    }

    // Find end of token
    end = start;
    while (*end && !is_delim(*end, delim)) {
        end++;
    }

    if (*end) {
        *end = '\0';
        *saveptr = end + 1;
    } else {
        *saveptr = NULL;
    }

    return start;
}

char *strstr(const char *haystack, const char *needle) {
    if (!*needle) return (char *)haystack;

    for (; *haystack; haystack++) {
        const char *h = haystack;
        const char *n = needle;
        while (*h && *n && *h == *n) {
            h++;
            n++;
        }
        if (!*n) return (char *)haystack;
    }
    return NULL;
}

void *memchr(const void *s, int c, size_t n) {
    const unsigned char *p = (const unsigned char *)s;
    unsigned char uc = (unsigned char)c;
    for (size_t i = 0; i < n; i++) {
        if (p[i] == uc) return (void *)(p + i);
    }
    return NULL;
}
</file>

<file path="kernel/string.h">
/*
 * VibeOS String Functions
 */

#ifndef STRING_H
#define STRING_H

#include <stddef.h>

// Memory operations
void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
void *memmove(void *dest, const void *src, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);

// String operations
size_t strlen(const char *s);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strcat(char *dest, const char *src);
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
char *strdup(const char *s);

// Case-insensitive compare (for our case-insensitive filesystem)
int strcasecmp(const char *s1, const char *s2);

// Tokenization
char *strtok_r(char *str, const char *delim, char **saveptr);

// Search
char *strstr(const char *haystack, const char *needle);
void *memchr(const void *s, int c, size_t n);

#endif
</file>

<file path="user/bin/browser.c">
/*
 * VibeOS Web Browser
 *
 * A simple text-mode web browser with basic HTML rendering.
 *
 * Usage: browser [url]
 * Example: browser http://example.com/
 */

#include "../lib/vibe.h"
#include "../lib/gfx.h"

static kapi_t *k;

// ============ String Helpers ============

static int str_len(const char *s) {
    int len = 0;
    while (s[len]) len++;
    return len;
}

static int str_eqn(const char *a, const char *b, int n) {
    while (n > 0 && *a && *b && *a == *b) { a++; b++; n--; }
    return n == 0;
}

static int str_ieqn(const char *a, const char *b, int n) {
    while (n > 0 && *a && *b) {
        char ca = *a, cb = *b;
        if (ca >= 'A' && ca <= 'Z') ca += 32;
        if (cb >= 'A' && cb <= 'Z') cb += 32;
        if (ca != cb) return 0;
        a++; b++; n--;
    }
    return n == 0;
}

static void str_cpy(char *dst, const char *src) {
    while (*src) *dst++ = *src++;
    *dst = '\0';
}

static void str_ncpy(char *dst, const char *src, int n) {
    while (n > 0 && *src) { *dst++ = *src++; n--; }
    *dst = '\0';
}

static int parse_int(const char *s) {
    int n = 0;
    while (*s >= '0' && *s <= '9') {
        n = n * 10 + (*s - '0');
        s++;
    }
    return n;
}

// ============ URL Parsing ============

typedef struct {
    char host[256];
    char path[512];
    int port;
    int use_tls;  // 1 for https, 0 for http
} url_t;

static int parse_url(const char *url, url_t *out) {
    out->use_tls = 0;
    out->port = 80;

    // Check for https://
    if (str_eqn(url, "https://", 8)) {
        url += 8;
        out->use_tls = 1;
        out->port = 443;
    } else if (str_eqn(url, "http://", 7)) {
        url += 7;
    }

    const char *host_start = url;
    const char *host_end = url;
    while (*host_end && *host_end != '/' && *host_end != ':') host_end++;

    int host_len = host_end - host_start;
    if (host_len >= 256) return -1;
    str_ncpy(out->host, host_start, host_len);

    // Parse port if present
    if (*host_end == ':') {
        host_end++;
        out->port = parse_int(host_end);
        while (*host_end >= '0' && *host_end <= '9') host_end++;
    }

    if (*host_end == '/') str_cpy(out->path, host_end);
    else str_cpy(out->path, "/");

    return 0;
}

// ============ HTTP Client ============

typedef struct {
    int status_code;
    int content_length;
    char location[512];
    int header_len;
} http_response_t;

static int find_header_end(const char *buf, int len) {
    for (int i = 0; i < len - 3; i++) {
        if (buf[i] == '\r' && buf[i+1] == '\n' &&
            buf[i+2] == '\r' && buf[i+3] == '\n') {
            return i + 4;
        }
    }
    return -1;
}

static int parse_headers(const char *buf, int len, http_response_t *resp) {
    memset(resp, 0, sizeof(*resp));
    resp->content_length = -1;
    resp->header_len = find_header_end(buf, len);
    if (resp->header_len < 0) return -1;

    const char *p = buf;
    if (!str_eqn(p, "HTTP/1.", 7)) return -1;
    p += 7;
    while (*p && *p != ' ') p++;
    while (*p == ' ') p++;
    resp->status_code = parse_int(p);

    while (*p && *p != '\r') p++;
    if (*p == '\r') p += 2;

    while (p < buf + resp->header_len - 2) {
        const char *line_end = p;
        while (line_end < buf + resp->header_len && *line_end != '\r') line_end++;

        if (str_ieqn(p, "Content-Length:", 15)) {
            const char *val = p + 15;
            while (*val == ' ') val++;
            resp->content_length = parse_int(val);
        } else if (str_ieqn(p, "Location:", 9)) {
            const char *val = p + 9;
            while (*val == ' ') val++;
            int loc_len = line_end - val;
            if (loc_len >= 512) loc_len = 511;
            str_ncpy(resp->location, val, loc_len);
        }
        p = line_end + 2;
    }
    return 0;
}

static int http_get(url_t *url, char *response, int max_response, http_response_t *resp) {
    uint32_t ip = k->dns_resolve(url->host);
    if (ip == 0) return -1;

    // Connect (TLS or plain TCP)
    int sock;
    if (url->use_tls) {
        sock = k->tls_connect(ip, url->port, url->host);
    } else {
        sock = k->tcp_connect(ip, url->port);
    }
    if (sock < 0) return -1;

    char request[1024];
    char *p = request;
    const char *s;

    s = "GET "; while (*s) *p++ = *s++;
    s = url->path; while (*s) *p++ = *s++;
    s = " HTTP/1.0\r\nHost: "; while (*s) *p++ = *s++;
    s = url->host; while (*s) *p++ = *s++;
    s = "\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\r\nAccept: text/html,*/*\r\nConnection: close\r\n\r\n";
    while (*s) *p++ = *s++;
    *p = '\0';

    // Send request
    int sent;
    if (url->use_tls) {
        sent = k->tls_send(sock, request, p - request);
    } else {
        sent = k->tcp_send(sock, request, p - request);
    }
    if (sent < 0) {
        if (url->use_tls) k->tls_close(sock);
        else k->tcp_close(sock);
        return -1;
    }

    int total = 0;
    int timeout = 0;
    resp->header_len = 0;

    while (total < max_response - 1 && timeout < 500) {
        int n;
        if (url->use_tls) {
            n = k->tls_recv(sock, response + total, max_response - 1 - total);
        } else {
            n = k->tcp_recv(sock, response + total, max_response - 1 - total);
        }
        if (n < 0) break;  // Connection closed
        if (n == 0) {
            k->net_poll();
            k->sleep_ms(10);
            timeout++;
            continue;
        }
        total += n;
        timeout = 0;

        // Check if we got headers yet
        if (resp->header_len == 0) {
            response[total] = '\0';
            parse_headers(response, total, resp);

            // If we have Content-Length and got all content, we're done
            if (resp->header_len > 0 && resp->content_length >= 0) {
                int body_received = total - resp->header_len;
                if (body_received >= resp->content_length) break;
            }
        }
    }

    response[total] = '\0';
    if (url->use_tls) k->tls_close(sock);
    else k->tcp_close(sock);
    if (resp->header_len == 0) parse_headers(response, total, resp);
    return total;
}

static int is_redirect(int status) {
    return status == 301 || status == 302 || status == 307 || status == 308;
}

// ============ HTML Parser ============

// Parsed content - simple linked list of text blocks
typedef struct text_block {
    char *text;
    char *link_url;      // URL if this is a link
    int is_heading;      // h1-h6
    int is_bold;
    int is_link;
    int is_list_item;
    int is_paragraph;
    struct text_block *next;
} text_block_t;

// Clickable link regions for hit testing
typedef struct {
    int x, y, w, h;      // Bounding box (relative to content, not scroll)
    char url[512];
} link_region_t;

#define MAX_LINK_REGIONS 256
static link_region_t link_regions[MAX_LINK_REGIONS];
static int num_link_regions = 0;

// Current link URL being parsed
static char current_link_url[512] = "";

static text_block_t *blocks_head = NULL;
static text_block_t *blocks_tail = NULL;

static void add_block(const char *text, int len, int heading, int bold, int link, int list_item, int para) {
    if (len <= 0) return;

    // Skip pure whitespace blocks
    int has_content = 0;
    for (int i = 0; i < len; i++) {
        if (text[i] != ' ' && text[i] != '\t' && text[i] != '\n' && text[i] != '\r') {
            has_content = 1;
            break;
        }
    }
    if (!has_content) return;

    text_block_t *block = k->malloc(sizeof(text_block_t));
    if (!block) return;

    block->text = k->malloc(len + 1);
    if (!block->text) { k->free(block); return; }

    // Copy and normalize whitespace
    char *dst = block->text;
    int last_was_space = 1;
    for (int i = 0; i < len; i++) {
        char c = text[i];
        if (c == '\n' || c == '\r' || c == '\t') c = ' ';
        if (c == ' ' && last_was_space) continue;
        *dst++ = c;
        last_was_space = (c == ' ');
    }
    // Trim trailing space
    if (dst > block->text && *(dst-1) == ' ') dst--;
    *dst = '\0';

    if (dst == block->text) {
        k->free(block->text);
        k->free(block);
        return;
    }

    block->is_heading = heading;
    block->is_bold = bold;
    block->is_link = link;
    block->is_list_item = list_item;
    block->is_paragraph = para;
    block->next = NULL;

    // Store link URL if this is a link
    block->link_url = NULL;
    if (link && current_link_url[0]) {
        int url_len = str_len(current_link_url);
        block->link_url = k->malloc(url_len + 1);
        if (block->link_url) {
            str_cpy(block->link_url, current_link_url);
        }
    }

    if (blocks_tail) {
        blocks_tail->next = block;
        blocks_tail = block;
    } else {
        blocks_head = blocks_tail = block;
    }
}

static void free_blocks(void) {
    text_block_t *b = blocks_head;
    while (b) {
        text_block_t *next = b->next;
        if (b->text) k->free(b->text);
        if (b->link_url) k->free(b->link_url);
        k->free(b);
        b = next;
    }
    blocks_head = blocks_tail = NULL;
    num_link_regions = 0;
}

// Simple HTML parser
static void parse_html(const char *html, int len) {
    free_blocks();

    const char *p = html;
    const char *end = html + len;

    int in_head = 0;
    int in_script = 0;
    int in_style = 0;
    int heading = 0;
    int bold = 0;
    int link = 0;
    int list_item = 0;

    const char *text_start = NULL;

    while (p < end) {
        if (*p == '<') {
            // Flush any pending text
            if (text_start && !in_head && !in_script && !in_style) {
                add_block(text_start, p - text_start, heading, bold, link, list_item, 0);
            }
            text_start = NULL;

            // Parse tag
            p++;
            int closing = (*p == '/');
            if (closing) p++;

            const char *tag_start = p;
            while (p < end && *p != '>' && *p != ' ' && *p != '\t' && *p != '\n') p++;
            int tag_len = p - tag_start;

            // Save position after tag name for attribute parsing
            const char *attrs_start = p;

            // Skip to end of tag
            while (p < end && *p != '>') p++;
            const char *tag_end = p;
            if (p < end) p++;

            // Handle tags
            if (str_ieqn(tag_start, "head", 4) && tag_len == 4) {
                in_head = !closing;
            } else if (str_ieqn(tag_start, "script", 6) && tag_len == 6) {
                in_script = !closing;
            } else if (str_ieqn(tag_start, "style", 5) && tag_len == 5) {
                in_style = !closing;
            } else if (tag_start[0] == 'h' && tag_len == 2 &&
                       tag_start[1] >= '1' && tag_start[1] <= '6') {
                heading = closing ? 0 : (tag_start[1] - '0');
                if (closing) add_block("\n", 1, 0, 0, 0, 0, 1);
            } else if ((str_ieqn(tag_start, "b", 1) && tag_len == 1) ||
                       (str_ieqn(tag_start, "strong", 6) && tag_len == 6)) {
                bold = !closing;
            } else if (str_ieqn(tag_start, "a", 1) && tag_len == 1) {
                if (closing) {
                    link = 0;
                    current_link_url[0] = '\0';
                } else {
                    link = 1;
                    // Extract href attribute
                    current_link_url[0] = '\0';
                    const char *ap = attrs_start;
                    while (ap < tag_end) {
                        // Skip whitespace
                        while (ap < tag_end && (*ap == ' ' || *ap == '\t' || *ap == '\n')) ap++;
                        if (ap >= tag_end) break;

                        // Check for href
                        if (str_ieqn(ap, "href", 4)) {
                            ap += 4;
                            while (ap < tag_end && *ap == ' ') ap++;
                            if (*ap == '=') {
                                ap++;
                                while (ap < tag_end && *ap == ' ') ap++;
                                char quote = 0;
                                if (*ap == '"' || *ap == '\'') {
                                    quote = *ap++;
                                }
                                const char *href_start = ap;
                                while (ap < tag_end && *ap != quote && *ap != '>' && *ap != ' ') ap++;
                                int href_len = ap - href_start;
                                if (href_len > 0 && href_len < 511) {
                                    str_ncpy(current_link_url, href_start, href_len);
                                }
                                break;
                            }
                        }
                        // Skip to next attribute
                        while (ap < tag_end && *ap != ' ' && *ap != '\t') ap++;
                    }
                }
            } else if (str_ieqn(tag_start, "li", 2) && tag_len == 2) {
                if (!closing) {
                    add_block(" ", 2, 0, 0, 0, 1, 0);
                    list_item = 1;
                } else {
                    list_item = 0;
                    add_block("\n", 1, 0, 0, 0, 0, 0);
                }
            } else if ((str_ieqn(tag_start, "p", 1) && tag_len == 1) ||
                       (str_ieqn(tag_start, "div", 3) && tag_len == 3) ||
                       (str_ieqn(tag_start, "br", 2) && tag_len == 2)) {
                add_block("\n", 1, 0, 0, 0, 0, 1);
            } else if ((str_ieqn(tag_start, "ul", 2) && tag_len == 2) ||
                       (str_ieqn(tag_start, "ol", 2) && tag_len == 2)) {
                add_block("\n", 1, 0, 0, 0, 0, 1);
            } else if (str_ieqn(tag_start, "title", 5) && tag_len == 5) {
                // Will capture title text
            }
        } else if (*p == '&') {
            // HTML entity
            if (text_start && !in_head && !in_script && !in_style) {
                add_block(text_start, p - text_start, heading, bold, link, list_item, 0);
            }

            const char *entity_start = p;
            while (p < end && *p != ';' && *p != ' ' && *p != '<') p++;

            // Decode common entities
            if (str_eqn(entity_start, "&amp;", 5)) {
                add_block("&", 1, heading, bold, link, list_item, 0);
            } else if (str_eqn(entity_start, "&lt;", 4)) {
                add_block("<", 1, heading, bold, link, list_item, 0);
            } else if (str_eqn(entity_start, "&gt;", 4)) {
                add_block(">", 1, heading, bold, link, list_item, 0);
            } else if (str_eqn(entity_start, "&quot;", 6)) {
                add_block("\"", 1, heading, bold, link, list_item, 0);
            } else if (str_eqn(entity_start, "&nbsp;", 6)) {
                add_block(" ", 1, heading, bold, link, list_item, 0);
            } else if (str_eqn(entity_start, "&copy;", 6)) {
                add_block("(c)", 3, heading, bold, link, list_item, 0);
            }

            if (*p == ';') p++;
            text_start = p;
        } else {
            if (!text_start) text_start = p;
            p++;
        }
    }

    // Flush remaining text
    if (text_start && !in_head && !in_script && !in_style) {
        add_block(text_start, p - text_start, heading, bold, link, list_item, 0);
    }
}

// ============ Browser UI ============

#define WIN_WIDTH 600
#define WIN_HEIGHT 400
#define ADDR_BAR_HEIGHT 24
#define CONTENT_Y (ADDR_BAR_HEIGHT + 2)
#define CHAR_W 8
#define CHAR_H 16
#define MARGIN 8

static int window_id = -1;
static uint32_t *win_buf = NULL;
static int win_w, win_h;
static char current_url[512] = "";
static int scroll_offset = 0;
static int content_height = 0;
static int editing_url = 0;
static char url_input[512] = "";
static int cursor_pos = 0;
static int dragging_scrollbar = 0;
static int drag_start_y = 0;
static int drag_start_scroll = 0;

// History for back button
#define MAX_HISTORY 32
static char history[MAX_HISTORY][512];
static int history_pos = -1;
static int history_len = 0;

// Graphics context
static gfx_ctx_t gfx;

// Scrollbar dimensions (calculated in draw)
static int scrollbar_y = 0;
static int scrollbar_h = 0;
#define SCROLLBAR_W 12

static void draw_browser(void) {
    if (!win_buf) return;

    // Clear link regions
    num_link_regions = 0;

    // Clear
    gfx_fill_rect(&gfx, 0, 0, win_w, win_h, COLOR_WHITE);

    // Address bar background
    gfx_fill_rect(&gfx, 0, 0, win_w, ADDR_BAR_HEIGHT, 0x00DDDDDD);
    gfx_draw_rect(&gfx, 0, ADDR_BAR_HEIGHT - 1, win_w, 1, COLOR_BLACK);

    // Back button
    #define BACK_BTN_W 24
    uint32_t back_color = (history_pos > 0) ? COLOR_BLACK : 0x00888888;
    gfx_fill_rect(&gfx, 4, 4, BACK_BTN_W, 16, 0x00EEEEEE);
    gfx_draw_rect(&gfx, 4, 4, BACK_BTN_W, 16, back_color);
    gfx_draw_string(&gfx, 8, 4, "<", back_color, 0x00EEEEEE);

    // URL input box (shifted right for back button)
    int url_x = 4 + BACK_BTN_W + 4;
    gfx_fill_rect(&gfx, url_x, 4, win_w - url_x - 4, 16, COLOR_WHITE);
    gfx_draw_rect(&gfx, url_x, 4, win_w - url_x - 4, 16, COLOR_BLACK);

    // URL text
    const char *display_url = editing_url ? url_input : current_url;
    gfx_draw_string(&gfx, url_x + 4, 4, display_url, COLOR_BLACK, COLOR_WHITE);

    // Cursor when editing
    if (editing_url) {
        int cursor_x = url_x + 4 + cursor_pos * CHAR_W;
        gfx_fill_rect(&gfx, cursor_x, 5, 1, 14, COLOR_BLACK);
    }

    // Content area
    int y = CONTENT_Y + MARGIN - scroll_offset;
    int max_chars = (win_w - MARGIN * 2) / CHAR_W;

    text_block_t *block = blocks_head;
    while (block) {
        if (y > win_h) break;

        const char *text = block->text;
        int len = str_len(text);

        // Word wrap
        int pos = 0;
        while (pos < len) {
            // Find line break point
            int line_len = 0;
            int last_space = -1;

            while (pos + line_len < len && line_len < max_chars) {
                if (text[pos + line_len] == '\n') break;
                if (text[pos + line_len] == ' ') last_space = line_len;
                line_len++;
            }

            // Break at word boundary if possible
            if (pos + line_len < len && last_space > 0 && line_len >= max_chars) {
                line_len = last_space + 1;
            }

            // Draw line if visible
            if (y + CHAR_H > CONTENT_Y && y < win_h) {
                uint32_t fg = COLOR_BLACK;
                if (block->is_link) fg = 0x000000FF;  // Blue for links

                // Draw character by character for styling
                int actual_chars = 0;
                for (int i = 0; i < line_len && text[pos + i] != '\n'; i++) {
                    char c = text[pos + i];
                    int x = MARGIN + i * CHAR_W;
                    if (x + CHAR_W > win_w - MARGIN) break;
                    gfx_draw_char(&gfx, x, y, c, fg, COLOR_WHITE);
                    actual_chars++;
                }

                // Register link region for hit testing
                if (block->is_link && block->link_url && num_link_regions < MAX_LINK_REGIONS && actual_chars > 0) {
                    link_region_t *lr = &link_regions[num_link_regions++];
                    lr->x = MARGIN;
                    lr->y = y;
                    lr->w = actual_chars * CHAR_W;
                    lr->h = CHAR_H;
                    str_ncpy(lr->url, block->link_url, 511);
                }

                // Underline for headings
                if (block->is_heading == 1) {
                    gfx_fill_rect(&gfx, MARGIN, y + CHAR_H - 2,
                                  line_len * CHAR_W, 2, COLOR_BLACK);
                }
            }

            pos += line_len;
            y += CHAR_H;

            // Skip newline
            if (pos < len && text[pos] == '\n') pos++;
        }

        // Extra space after paragraphs
        if (block->is_paragraph || block->is_heading) {
            y += CHAR_H / 2;
        }

        block = block->next;
    }

    content_height = y + scroll_offset - CONTENT_Y;

    // Scrollbar if needed
    if (content_height > win_h - CONTENT_Y) {
        int content_area = win_h - CONTENT_Y - 16;  // minus status bar
        scrollbar_h = content_area * content_area / content_height;
        if (scrollbar_h < 20) scrollbar_h = 20;
        int max_scroll = content_height - content_area;
        if (max_scroll > 0) {
            scrollbar_y = CONTENT_Y + scroll_offset * (content_area - scrollbar_h) / max_scroll;
        } else {
            scrollbar_y = CONTENT_Y;
        }
        // Draw scrollbar track
        gfx_fill_rect(&gfx, win_w - SCROLLBAR_W, CONTENT_Y, SCROLLBAR_W, content_area, 0x00CCCCCC);
        // Draw scrollbar thumb
        gfx_fill_rect(&gfx, win_w - SCROLLBAR_W + 2, scrollbar_y, SCROLLBAR_W - 4, scrollbar_h, 0x00666666);
    } else {
        scrollbar_h = 0;
    }

    // Status bar
    gfx_fill_rect(&gfx, 0, win_h - 16, win_w, 16, 0x00DDDDDD);
    if (blocks_head) {
        gfx_draw_string(&gfx, 4, win_h - 16, "Ready", COLOR_BLACK, 0x00DDDDDD);
    } else if (current_url[0]) {
        gfx_draw_string(&gfx, 4, win_h - 16, "Loading...", COLOR_BLACK, 0x00DDDDDD);
    } else {
        gfx_draw_string(&gfx, 4, win_h - 16, "Enter URL and press Enter", COLOR_BLACK, 0x00DDDDDD);
    }

    k->window_invalidate(window_id);
}

// Resolve a potentially relative URL against the current URL
static void resolve_url(const char *href, char *out, int max_len) {
    if (str_eqn(href, "http://", 7) || str_eqn(href, "https://", 8)) {
        // Absolute URL
        str_ncpy(out, href, max_len - 1);
        return;
    }

    // Parse current URL to get host and scheme
    url_t base;
    if (parse_url(current_url, &base) < 0) {
        str_ncpy(out, href, max_len - 1);
        return;
    }

    char *p = out;
    char *end = out + max_len - 1;

    // Build scheme://host (preserve https if current page is https)
    const char *s = base.use_tls ? "https://" : "http://";
    while (*s && p < end) *p++ = *s++;
    s = base.host;
    while (*s && p < end) *p++ = *s++;

    if (href[0] == '/') {
        // Absolute path
        s = href;
        while (*s && p < end) *p++ = *s++;
    } else {
        // Relative path - append to current directory
        // Find last / in current path
        int last_slash = 0;
        for (int i = 0; base.path[i]; i++) {
            if (base.path[i] == '/') last_slash = i;
        }
        // Copy path up to and including last /
        for (int i = 0; i <= last_slash && p < end; i++) {
            *p++ = base.path[i];
        }
        // Append relative href
        s = href;
        while (*s && p < end) *p++ = *s++;
    }
    *p = '\0';
}

static void navigate_internal(const char *url, int add_to_history);

static void go_back(void) {
    if (history_pos > 0) {
        history_pos--;
        navigate_internal(history[history_pos], 0);
    }
}

static void navigate(const char *url) {
    // Add to history
    if (history_pos < MAX_HISTORY - 1) {
        history_pos++;
        str_ncpy(history[history_pos], url, 511);
        history_len = history_pos + 1;
    }
    navigate_internal(url, 1);
}

static void navigate_internal(const char *url, int add_to_history) {
    (void)add_to_history;
    str_cpy(current_url, url);
    str_cpy(url_input, url);
    free_blocks();
    scroll_offset = 0;
    draw_browser();

    url_t parsed;
    if (parse_url(url, &parsed) < 0) {
        add_block("Error: Invalid URL", 18, 1, 0, 0, 0, 0);
        draw_browser();
        return;
    }

    char *response = k->malloc(131072);  // 128KB
    if (!response) {
        add_block("Error: Out of memory", 20, 1, 0, 0, 0, 0);
        draw_browser();
        return;
    }

    http_response_t resp;
    int redirects = 0;

    while (1) {
        int len = http_get(&parsed, response, 131072, &resp);

        if (len <= 0) {
            add_block("Error: No response from server", 30, 1, 0, 0, 0, 0);
            break;
        }

        if (is_redirect(resp.status_code) && resp.location[0] && redirects < 5) {
            redirects++;
            // Check if it's a relative URL (starts with /)
            if (resp.location[0] == '/') {
                // Just update path, keep same host and protocol
                str_cpy(parsed.path, resp.location);
            } else {
                // Parse new URL (might switch http->https or vice versa)
                parse_url(resp.location, &parsed);
            }
            continue;
        }

        // For non-200 responses, still try to render the body (many sites return HTML error pages)
        if (resp.header_len > 0 && resp.header_len < len) {
            parse_html(response + resp.header_len, len - resp.header_len);
        }
        break;
    }

    k->free(response);
    draw_browser();
}

int main(kapi_t *kapi, int argc, char **argv) {
    k = kapi;

    if (!k->window_create) {
        k->puts("Browser requires desktop environment\n");
        return 1;
    }

    // Create window
    window_id = k->window_create(50, 50, WIN_WIDTH, WIN_HEIGHT, "VibeOS Browser");
    if (window_id < 0) {
        k->puts("Failed to create window\n");
        return 1;
    }

    win_buf = k->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buf) {
        k->window_destroy(window_id);
        return 1;
    }

    // Setup graphics context
    gfx_init(&gfx, win_buf, win_w, win_h, k->font_data);

    // Navigate to initial URL if provided
    if (argc > 1) {
        str_cpy(url_input, argv[1]);
        navigate(argv[1]);
    } else {
        str_cpy(url_input, "http://");
        cursor_pos = 7;
        editing_url = 1;
    }

    draw_browser();

    // Event loop
    int running = 1;
    while (running) {
        int event_type, data1, data2, data3;
        while (k->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;

                case WIN_EVENT_KEY: {
                    int key = data1;

                    if (editing_url) {
                        if (key == '\n' || key == '\r') {
                            // Navigate
                            editing_url = 0;
                            navigate(url_input);
                        } else if (key == 27) {  // Escape
                            editing_url = 0;
                            str_cpy(url_input, current_url);
                            draw_browser();
                        } else if (key == '\b' || key == 127) {
                            if (cursor_pos > 0) {
                                // Delete character before cursor
                                for (int i = cursor_pos - 1; url_input[i]; i++) {
                                    url_input[i] = url_input[i + 1];
                                }
                                cursor_pos--;
                                draw_browser();
                            }
                        } else if (key == KEY_LEFT) {
                            if (cursor_pos > 0) cursor_pos--;
                            draw_browser();
                        } else if (key == KEY_RIGHT) {
                            if (url_input[cursor_pos]) cursor_pos++;
                            draw_browser();
                        } else if (key >= 32 && key < 127) {
                            int len = str_len(url_input);
                            if (len < 500) {
                                // Insert character at cursor
                                for (int i = len + 1; i > cursor_pos; i--) {
                                    url_input[i] = url_input[i - 1];
                                }
                                url_input[cursor_pos++] = key;
                                draw_browser();
                            }
                        }
                    } else {
                        // Not editing URL
                        if (key == 'g' || key == 'G') {
                            // Go to URL
                            editing_url = 1;
                            cursor_pos = str_len(url_input);
                            draw_browser();
                        } else if (key == 'r' || key == 'R') {
                            // Reload
                            navigate_internal(current_url, 0);
                        } else if (key == '\b' || key == 127 || key == 'b' || key == 'B') {
                            // Back
                            go_back();
                        } else if (key == KEY_UP || key == 'k') {
                            scroll_offset -= CHAR_H * 3;
                            if (scroll_offset < 0) scroll_offset = 0;
                            draw_browser();
                        } else if (key == KEY_DOWN || key == 'j') {
                            int max_scroll = content_height - (win_h - CONTENT_Y);
                            if (max_scroll < 0) max_scroll = 0;
                            scroll_offset += CHAR_H * 3;
                            if (scroll_offset > max_scroll) scroll_offset = max_scroll;
                            draw_browser();
                        } else if (key == ' ') {
                            // Page down
                            int max_scroll = content_height - (win_h - CONTENT_Y);
                            if (max_scroll < 0) max_scroll = 0;
                            scroll_offset += win_h - CONTENT_Y - CHAR_H * 2;
                            if (scroll_offset > max_scroll) scroll_offset = max_scroll;
                            draw_browser();
                        }
                    }
                    break;
                }

                case WIN_EVENT_MOUSE_DOWN: {
                    int mx = data1;
                    int my = data2;

                    // Click in address bar area
                    if (my < ADDR_BAR_HEIGHT) {
                        if (mx >= 4 && mx < 4 + BACK_BTN_W) {
                            // Back button clicked
                            go_back();
                        } else {
                            // URL bar clicked
                            editing_url = 1;
                            cursor_pos = str_len(url_input);
                            draw_browser();
                        }
                    } else if (scrollbar_h > 0 && mx >= win_w - SCROLLBAR_W) {
                        // Click on scrollbar area
                        if (my >= scrollbar_y && my < scrollbar_y + scrollbar_h) {
                            // Start dragging scrollbar
                            dragging_scrollbar = 1;
                            drag_start_y = my;
                            drag_start_scroll = scroll_offset;
                        } else if (my < scrollbar_y) {
                            // Click above scrollbar - page up
                            scroll_offset -= (win_h - CONTENT_Y - 16);
                            if (scroll_offset < 0) scroll_offset = 0;
                            draw_browser();
                        } else {
                            // Click below scrollbar - page down
                            int max_scroll = content_height - (win_h - CONTENT_Y - 16);
                            if (max_scroll < 0) max_scroll = 0;
                            scroll_offset += (win_h - CONTENT_Y - 16);
                            if (scroll_offset > max_scroll) scroll_offset = max_scroll;
                            draw_browser();
                        }
                    } else if (!editing_url) {
                        // Check for link click
                        for (int i = 0; i < num_link_regions; i++) {
                            link_region_t *lr = &link_regions[i];
                            if (mx >= lr->x && mx < lr->x + lr->w &&
                                my >= lr->y && my < lr->y + lr->h) {
                                // Clicked on a link!
                                char resolved[512];
                                resolve_url(lr->url, resolved, 512);
                                navigate(resolved);
                                break;
                            }
                        }
                    }
                    break;
                }

                case WIN_EVENT_MOUSE_UP:
                    dragging_scrollbar = 0;
                    break;

                case WIN_EVENT_MOUSE_MOVE:
                    if (dragging_scrollbar) {
                        int dy = data2 - drag_start_y;
                        int content_area = win_h - CONTENT_Y - 16;
                        int max_scroll = content_height - content_area;
                        if (max_scroll > 0 && content_area > scrollbar_h) {
                            int scroll_range = content_area - scrollbar_h;
                            scroll_offset = drag_start_scroll + dy * max_scroll / scroll_range;
                            if (scroll_offset < 0) scroll_offset = 0;
                            if (scroll_offset > max_scroll) scroll_offset = max_scroll;
                            draw_browser();
                        }
                    }
                    break;

                case WIN_EVENT_RESIZE:
                    // Re-fetch buffer with new dimensions
                    win_buf = k->window_get_buffer(window_id, &win_w, &win_h);
                    gfx_init(&gfx, win_buf, win_w, win_h, k->font_data);
                    draw_browser();
                    break;
            }
        }

        k->yield();
    }

    free_blocks();
    k->window_destroy(window_id);
    return 0;
}
</file>

<file path="user/bin/fetch.c">
/*
 * VibeOS fetch command - HTTP/HTTPS client
 *
 * Usage: fetch <url>
 * Example: fetch http://example.com/
 *          fetch https://google.com/
 *
 * Features:
 * - HTTP and HTTPS support
 * - Follows redirects (301, 302, 307, 308)
 * - Parses HTTP headers
 * - Shows response info
 */

#include "../lib/vibe.h"

static kapi_t *k;

// Output helpers
static void out_puts(const char *s) {
    if (k->stdio_puts) k->stdio_puts(s);
    else k->puts(s);
}

static void out_putc(char c) {
    if (k->stdio_putc) k->stdio_putc(c);
    else k->putc(c);
}

static void out_num(int n) {
    if (n < 0) { out_putc('-'); n = -n; }
    if (n == 0) { out_putc('0'); return; }
    char buf[12];
    int i = 0;
    while (n > 0) { buf[i++] = '0' + (n % 10); n /= 10; }
    while (i > 0) out_putc(buf[--i]);
}

// String helpers
static int str_len(const char *s) {
    int len = 0;
    while (s[len]) len++;
    return len;
}

static int str_eq(const char *a, const char *b) {
    while (*a && *b && *a == *b) { a++; b++; }
    return *a == *b;
}

static int str_eqn(const char *a, const char *b, int n) {
    while (n > 0 && *a && *b && *a == *b) { a++; b++; n--; }
    return n == 0;
}

static int str_ieqn(const char *a, const char *b, int n) {
    // Case-insensitive compare
    while (n > 0 && *a && *b) {
        char ca = *a, cb = *b;
        if (ca >= 'A' && ca <= 'Z') ca += 32;
        if (cb >= 'A' && cb <= 'Z') cb += 32;
        if (ca != cb) return 0;
        a++; b++; n--;
    }
    return n == 0;
}

static void str_cpy(char *dst, const char *src) {
    while (*src) *dst++ = *src++;
    *dst = '\0';
}

static void str_ncpy(char *dst, const char *src, int n) {
    while (n > 0 && *src) { *dst++ = *src++; n--; }
    *dst = '\0';
}

static int parse_int(const char *s) {
    int n = 0;
    while (*s >= '0' && *s <= '9') {
        n = n * 10 + (*s - '0');
        s++;
    }
    return n;
}

// URL parsing
typedef struct {
    char host[256];
    char path[512];
    int port;
    int use_tls;  // 1 for https, 0 for http
} url_t;

static int parse_url(const char *url, url_t *out) {
    out->use_tls = 0;
    out->port = 80;

    // Check for https://
    if (str_eqn(url, "https://", 8)) {
        url += 8;
        out->use_tls = 1;
        out->port = 443;
    } else if (str_eqn(url, "http://", 7)) {
        url += 7;
    }

    // Find host end (/ or :)
    const char *host_start = url;
    const char *host_end = url;
    while (*host_end && *host_end != '/' && *host_end != ':') host_end++;

    int host_len = host_end - host_start;
    if (host_len >= 256) return -1;
    str_ncpy(out->host, host_start, host_len);

    // Parse port if present
    if (*host_end == ':') {
        host_end++;
        out->port = parse_int(host_end);
        while (*host_end >= '0' && *host_end <= '9') host_end++;
    }

    // Path (default to /)
    if (*host_end == '/') {
        str_cpy(out->path, host_end);
    } else {
        str_cpy(out->path, "/");
    }

    return 0;
}

// HTTP response
typedef struct {
    int status_code;
    int content_length;
    char location[512];
    char content_type[128];
    int header_len;
} http_response_t;

// Find \r\n\r\n (end of headers)
static int find_header_end(const char *buf, int len) {
    for (int i = 0; i < len - 3; i++) {
        if (buf[i] == '\r' && buf[i+1] == '\n' &&
            buf[i+2] == '\r' && buf[i+3] == '\n') {
            return i + 4;
        }
    }
    return -1;
}

// Parse HTTP response headers
static int parse_headers(const char *buf, int len, http_response_t *resp) {
    memset(resp, 0, sizeof(*resp));
    resp->content_length = -1;

    // Find end of headers
    resp->header_len = find_header_end(buf, len);
    if (resp->header_len < 0) return -1;

    // Parse status line: HTTP/1.x NNN ...
    const char *p = buf;
    if (!str_eqn(p, "HTTP/1.", 7)) return -1;
    p += 7;
    while (*p && *p != ' ') p++;  // Skip version
    while (*p == ' ') p++;
    resp->status_code = parse_int(p);

    // Parse headers (line by line)
    while (*p && *p != '\r') p++;
    if (*p == '\r') p += 2;  // Skip status line

    while (p < buf + resp->header_len - 2) {
        // Find end of line
        const char *line_end = p;
        while (line_end < buf + resp->header_len && *line_end != '\r') line_end++;
        int line_len = line_end - p;

        // Parse header
        if (str_ieqn(p, "Content-Length:", 15)) {
            const char *val = p + 15;
            while (*val == ' ') val++;
            resp->content_length = parse_int(val);
        } else if (str_ieqn(p, "Location:", 9)) {
            const char *val = p + 9;
            while (*val == ' ') val++;
            int loc_len = line_end - val;
            if (loc_len >= 512) loc_len = 511;
            str_ncpy(resp->location, val, loc_len);
        } else if (str_ieqn(p, "Content-Type:", 13)) {
            const char *val = p + 13;
            while (*val == ' ') val++;
            int ct_len = line_end - val;
            if (ct_len >= 128) ct_len = 127;
            str_ncpy(resp->content_type, val, ct_len);
        }

        // Next line
        p = line_end + 2;
    }

    return 0;
}

// Make HTTP/HTTPS request
static int http_get(url_t *url, char *response, int max_response, http_response_t *resp) {
    // Resolve hostname
    uint32_t ip = k->dns_resolve(url->host);
    if (ip == 0) {
        out_puts("DNS resolution failed\n");
        return -1;
    }

    // Connect (TLS or plain TCP)
    int sock;
    if (url->use_tls) {
        out_puts("Connecting with TLS...\n");
        sock = k->tls_connect(ip, url->port, url->host);
    } else {
        sock = k->tcp_connect(ip, url->port);
    }

    if (sock < 0) {
        out_puts("Connection failed\n");
        return -1;
    }

    // Build request
    char request[1024];
    char *p = request;

    // GET /path HTTP/1.0\r\n
    const char *s = "GET ";
    while (*s) *p++ = *s++;
    s = url->path;
    while (*s) *p++ = *s++;
    s = " HTTP/1.0\r\n";
    while (*s) *p++ = *s++;

    // Host: hostname\r\n
    s = "Host: ";
    while (*s) *p++ = *s++;
    s = url->host;
    while (*s) *p++ = *s++;
    *p++ = '\r'; *p++ = '\n';

    // User-Agent
    s = "User-Agent: Mozilla/5.0 (compatible; VibeOS)\r\n";
    while (*s) *p++ = *s++;

    // Connection: close\r\n\r\n
    s = "Connection: close\r\n\r\n";
    while (*s) *p++ = *s++;
    *p = '\0';

    // Send request
    int sent;
    if (url->use_tls) {
        sent = k->tls_send(sock, request, p - request);
    } else {
        sent = k->tcp_send(sock, request, p - request);
    }

    if (sent < 0) {
        out_puts("Send failed\n");
        if (url->use_tls) k->tls_close(sock);
        else k->tcp_close(sock);
        return -1;
    }

    // Receive response
    int total = 0;
    int timeout = 0;

    while (total < max_response - 1 && timeout < 500) {
        int n;
        if (url->use_tls) {
            n = k->tls_recv(sock, response + total, max_response - 1 - total);
        } else {
            n = k->tcp_recv(sock, response + total, max_response - 1 - total);
        }

        if (n < 0) break;  // Connection closed
        if (n == 0) {
            k->net_poll();
            k->sleep_ms(10);
            timeout++;
            continue;
        }
        total += n;
        timeout = 0;

        // Check if we got headers yet
        if (resp->header_len == 0) {
            response[total] = '\0';
            parse_headers(response, total, resp);

            // If we have Content-Length and got all content, we're done
            if (resp->header_len > 0 && resp->content_length >= 0) {
                int body_received = total - resp->header_len;
                if (body_received >= resp->content_length) break;
            }
        }
    }

    response[total] = '\0';

    if (url->use_tls) k->tls_close(sock);
    else k->tcp_close(sock);

    // Parse headers if not done yet
    if (resp->header_len == 0) {
        parse_headers(response, total, resp);
    }

    return total;
}

// Check if redirect status
static int is_redirect(int status) {
    return status == 301 || status == 302 || status == 307 || status == 308;
}

int main(kapi_t *kapi, int argc, char **argv) {
    k = kapi;

    if (argc < 2) {
        out_puts("Usage: fetch <url>\n");
        out_puts("Example: fetch http://example.com/\n");
        out_puts("         fetch https://google.com/\n");
        return 1;
    }

    // Parse URL
    url_t url;
    if (parse_url(argv[1], &url) < 0) {
        out_puts("Invalid URL\n");
        return 1;
    }

    // Allocate response buffer
    char *response = k->malloc(65536);
    if (!response) {
        out_puts("Out of memory\n");
        return 1;
    }

    http_response_t resp;
    int redirects = 0;
    const int max_redirects = 5;

    while (1) {
        out_puts("Fetching ");
        out_puts(url.use_tls ? "https://" : "http://");
        out_puts(url.host);
        out_puts(url.path);
        out_puts("\n");

        memset(&resp, 0, sizeof(resp));
        int len = http_get(&url, response, 65536, &resp);
        if (len < 0) {
            k->free(response);
            return 1;
        }

        out_puts("HTTP ");
        out_num(resp.status_code);
        out_puts(" - ");
        out_num(len);
        out_puts(" bytes\n");

        if (resp.content_type[0]) {
            out_puts("Content-Type: ");
            out_puts(resp.content_type);
            out_puts("\n");
        }

        // Handle redirect
        if (is_redirect(resp.status_code) && resp.location[0]) {
            redirects++;
            if (redirects > max_redirects) {
                out_puts("Too many redirects\n");
                k->free(response);
                return 1;
            }

            out_puts("Redirecting to: ");
            out_puts(resp.location);
            out_puts("\n\n");

            // Check if it's a relative URL (starts with /)
            if (resp.location[0] == '/') {
                // Just update path, keep same host and protocol
                str_cpy(url.path, resp.location);
            } else {
                // Parse new URL (might switch http->https)
                if (parse_url(resp.location, &url) < 0) {
                    out_puts("Invalid redirect URL\n");
                    k->free(response);
                    return 1;
                }
            }

            continue;
        }

        // Print body
        out_puts("\n");
        if (resp.header_len > 0 && resp.header_len < len) {
            out_puts(response + resp.header_len);
        }
        out_puts("\n");

        break;
    }

    k->free(response);
    return 0;
}
</file>

<file path="user/bin/mkdir.c">
/*
 * mkdir - create directory
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    if (argc < 2) {
        out_puts("usage: mkdir <directory>\n");
        return 1;
    }

    void *dir = k->mkdir(argv[1]);
    if (!dir) {
        out_puts("mkdir: cannot create directory '");
        out_puts(argv[1]);
        out_puts("'\n");
        return 1;
    }

    return 0;
}
</file>

<file path="user/bin/ping.c">
/*
 * VibeOS ping command
 *
 * Usage: ping <ip>
 * Example: ping 10.0.2.2
 */

#include "../lib/vibe.h"

static kapi_t *k;

// Simple output helper
static void out_puts(const char *s) {
    if (k->stdio_puts) k->stdio_puts(s);
    else k->puts(s);
}

static void out_putc(char c) {
    if (k->stdio_putc) k->stdio_putc(c);
    else k->putc(c);
}

// Print a number
static void out_num(int n) {
    if (n < 0) {
        out_putc('-');
        n = -n;
    }
    if (n == 0) {
        out_putc('0');
        return;
    }
    char buf[12];
    int i = 0;
    while (n > 0) {
        buf[i++] = '0' + (n % 10);
        n /= 10;
    }
    while (i > 0) {
        out_putc(buf[--i]);
    }
}

// Check if string is an IP address (contains only digits and dots)
static int is_ip_address(const char *s) {
    while (*s) {
        if ((*s < '0' || *s > '9') && *s != '.') return 0;
        s++;
    }
    return 1;
}

// Parse IP address from string "a.b.c.d"
static int parse_ip(const char *s, uint32_t *ip) {
    int parts[4] = {0, 0, 0, 0};
    int part = 0;
    int val = 0;

    while (*s) {
        if (*s >= '0' && *s <= '9') {
            val = val * 10 + (*s - '0');
            if (val > 255) return -1;
        } else if (*s == '.') {
            if (part >= 3) return -1;
            parts[part++] = val;
            val = 0;
        } else {
            return -1;
        }
        s++;
    }

    if (part != 3) return -1;
    parts[3] = val;

    *ip = MAKE_IP(parts[0], parts[1], parts[2], parts[3]);
    return 0;
}

// Print IP address
static void print_ip(uint32_t ip) {
    out_num((ip >> 24) & 0xff);
    out_putc('.');
    out_num((ip >> 16) & 0xff);
    out_putc('.');
    out_num((ip >> 8) & 0xff);
    out_putc('.');
    out_num(ip & 0xff);
}

int main(kapi_t *kapi, int argc, char **argv) {
    k = kapi;

    if (argc < 2) {
        out_puts("Usage: ping <ip or hostname>\n");
        out_puts("Example: ping 10.0.2.2\n");
        out_puts("         ping google.com\n");
        return 1;
    }

    uint32_t ip;
    const char *target = argv[1];

    // Check if it's an IP address or hostname
    if (is_ip_address(target)) {
        if (parse_ip(target, &ip) < 0) {
            out_puts("Invalid IP address: ");
            out_puts(target);
            out_puts("\n");
            return 1;
        }
    } else {
        // It's a hostname - resolve via DNS
        out_puts("Resolving ");
        out_puts(target);
        out_puts("...\n");

        ip = k->dns_resolve(target);
        if (ip == 0) {
            out_puts("Could not resolve hostname: ");
            out_puts(target);
            out_puts("\n");
            return 1;
        }
    }

    out_puts("PING ");
    out_puts(target);
    out_puts(" (");
    print_ip(ip);
    out_puts(")\n");

    int sent = 0;
    int received = 0;

    // Send 4 pings
    for (int i = 0; i < 4; i++) {
        int result = k->net_ping(ip, i + 1, 1000);  // 1 second timeout

        if (result == 0) {
            out_puts("Reply from ");
            print_ip(ip);
            out_puts(": seq=");
            out_num(i + 1);
            out_puts("\n");
            received++;
        } else {
            out_puts("Request timed out: seq=");
            out_num(i + 1);
            out_puts("\n");
        }
        sent++;

        // Wait a bit between pings
        k->sleep_ms(500);
    }

    out_puts("\n--- ");
    print_ip(ip);
    out_puts(" ping statistics ---\n");
    out_num(sent);
    out_puts(" packets transmitted, ");
    out_num(received);
    out_puts(" received, ");
    out_num(((sent - received) * 100) / sent);
    out_puts("% packet loss\n");

    return 0;
}
</file>

<file path="user/bin/pwd.c">
/*
 * pwd - print working directory
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    (void)argc;
    (void)argv;
    api = k;

    char cwd[256];
    if (k->get_cwd(cwd, sizeof(cwd)) >= 0) {
        out_puts(cwd);
        out_putc('\n');
        return 0;
    }

    out_puts("pwd: error getting current directory\n");
    return 1;
}
</file>

<file path="user/bin/touch.c">
/*
 * touch - create empty file
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    if (argc < 2) {
        out_puts("usage: touch <file>\n");
        return 1;
    }

    void *file = k->create(argv[1]);
    if (!file) {
        out_puts("touch: cannot create '");
        out_puts(argv[1]);
        out_puts("'\n");
        return 1;
    }

    return 0;
}
</file>

<file path=".gitignore">
build/
*.o
*.elf
*.bin
.DS_Store
disk.img
Music/
beep.mp3
</file>

<file path="kernel/elf.c">
/*
 * VibeOS ELF64 Loader
 */

#include "elf.h"
#include "string.h"
#include "printf.h"
#include <stddef.h>

int elf_validate(const void *data, size_t size) {
    if (size < sizeof(Elf64_Ehdr)) {
        return -1;
    }

    const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)data;

    // Check magic
    if (ehdr->e_ident[EI_MAG0] != 0x7F ||
        ehdr->e_ident[EI_MAG1] != 'E' ||
        ehdr->e_ident[EI_MAG2] != 'L' ||
        ehdr->e_ident[EI_MAG3] != 'F') {
        return -2;
    }

    // Check class (64-bit)
    if (ehdr->e_ident[EI_CLASS] != ELFCLASS64) {
        return -3;
    }

    // Check endianness (little endian)
    if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {
        return -4;
    }

    // Check machine type (AArch64)
    if (ehdr->e_machine != EM_AARCH64) {
        return -5;
    }

    // Check type (executable or PIE)
    if (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {
        return -6;
    }

    return 0;
}

uint64_t elf_entry(const void *data) {
    const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)data;
    return ehdr->e_entry;
}

uint64_t elf_load(const void *data, size_t size) {
    int valid = elf_validate(data, size);
    if (valid != 0) {
        printf("[ELF] Invalid ELF: error %d\n", valid);
        return 0;
    }

    const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)data;
    const uint8_t *base = (const uint8_t *)data;

    printf("[ELF] Loading %d program headers\n", ehdr->e_phnum);

    // Process program headers
    for (int i = 0; i < ehdr->e_phnum; i++) {
        const Elf64_Phdr *phdr = (const Elf64_Phdr *)(base + ehdr->e_phoff + i * ehdr->e_phentsize);

        // Only load PT_LOAD segments
        if (phdr->p_type != PT_LOAD) {
            continue;
        }

        printf("[ELF] LOAD: vaddr=0x%lx filesz=0x%lx memsz=0x%lx\n",
               phdr->p_vaddr, phdr->p_filesz, phdr->p_memsz);

        // Copy segment data
        void *dest = (void *)phdr->p_vaddr;
        printf("[ELF] Copying %lu bytes to %p\n", phdr->p_filesz, dest);
        const void *src = base + phdr->p_offset;

        // Copy file contents
        if (phdr->p_filesz > 0) {
            memcpy(dest, src, phdr->p_filesz);
        }

        // Zero out any remaining memory (BSS)
        if (phdr->p_memsz > phdr->p_filesz) {
            memset((uint8_t *)dest + phdr->p_filesz, 0,
                   phdr->p_memsz - phdr->p_filesz);
        }
    }

    printf("[ELF] Entry point: 0x%lx\n", ehdr->e_entry);

    // Debug: dump first few instructions at entry
    uint32_t *code = (uint32_t *)ehdr->e_entry;
    printf("[ELF] Code at entry: %08x %08x %08x %08x\n",
           code[0], code[1], code[2], code[3]);

    return ehdr->e_entry;
}

// Calculate total memory size needed for all LOAD segments
uint64_t elf_calc_size(const void *data, size_t size) {
    int valid = elf_validate(data, size);
    if (valid != 0) return 0;

    const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)data;
    const uint8_t *base = (const uint8_t *)data;

    uint64_t min_addr = (uint64_t)-1;
    uint64_t max_addr = 0;

    for (int i = 0; i < ehdr->e_phnum; i++) {
        const Elf64_Phdr *phdr = (const Elf64_Phdr *)(base + ehdr->e_phoff + i * ehdr->e_phentsize);
        if (phdr->p_type != PT_LOAD) continue;

        if (phdr->p_vaddr < min_addr) {
            min_addr = phdr->p_vaddr;
        }
        uint64_t end = phdr->p_vaddr + phdr->p_memsz;
        if (end > max_addr) {
            max_addr = end;
        }
    }

    if (max_addr <= min_addr) return 0;
    return max_addr - min_addr;
}

// Process dynamic relocations for PIE binaries
static void elf_process_relocations(uint64_t load_base, const Elf64_Dyn *dynamic) {
    uint64_t rela_addr = 0;
    uint64_t rela_size = 0;
    uint64_t rela_ent = sizeof(Elf64_Rela);

    // Parse dynamic section to find RELA info
    for (const Elf64_Dyn *dyn = dynamic; dyn->d_tag != DT_NULL; dyn++) {
        switch (dyn->d_tag) {
            case DT_RELA:    rela_addr = dyn->d_val; break;
            case DT_RELASZ:  rela_size = dyn->d_val; break;
            case DT_RELAENT: rela_ent = dyn->d_val;  break;
        }
    }

    if (rela_addr == 0 || rela_size == 0) {
        printf("[ELF] No relocations to process\n");
        return;
    }

    // Relocations are at file offset, add load_base to get runtime address
    const Elf64_Rela *rela = (const Elf64_Rela *)(load_base + rela_addr);
    int num_relas = rela_size / rela_ent;

    printf("[ELF] Processing %d relocations at 0x%lx\n", num_relas, load_base + rela_addr);

    for (int i = 0; i < num_relas; i++) {
        uint64_t offset = rela[i].r_offset;
        uint64_t type = rela[i].r_info & 0xFFFFFFFF;
        int64_t addend = rela[i].r_addend;

        if (type == R_AARCH64_RELATIVE) {
            // R_AARCH64_RELATIVE: *(load_base + offset) = load_base + addend
            uint64_t *target = (uint64_t *)(load_base + offset);
            *target = load_base + addend;
        } else {
            printf("[ELF] Unknown relocation type 0x%lx at offset 0x%lx\n", type, offset);
        }
    }

    printf("[ELF] Relocations applied successfully\n");
}

// Load ELF at a specific base address
int elf_load_at(const void *data, size_t size, uint64_t load_base, elf_load_info_t *info) {
    int valid = elf_validate(data, size);
    if (valid != 0) {
        printf("[ELF] Invalid ELF: error %d\n", valid);
        return -1;
    }

    const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)data;
    const uint8_t *base = (const uint8_t *)data;
    int is_pie = (ehdr->e_type == ET_DYN);

    printf("[ELF] Loading %s at 0x%lx (%d program headers)\n",
           is_pie ? "PIE" : "EXEC", load_base, ehdr->e_phnum);

    uint64_t total_size = 0;
    const Elf64_Dyn *dynamic = NULL;

    // Process program headers
    for (int i = 0; i < ehdr->e_phnum; i++) {
        const Elf64_Phdr *phdr = (const Elf64_Phdr *)(base + ehdr->e_phoff + i * ehdr->e_phentsize);

        // Remember DYNAMIC segment for relocations
        if (phdr->p_type == PT_DYNAMIC) {
            // Dynamic section will be loaded, remember its runtime address
            dynamic = (const Elf64_Dyn *)(load_base + phdr->p_vaddr);
            continue;
        }

        if (phdr->p_type != PT_LOAD) continue;

        // For PIE, add load_base to vaddr
        // For EXEC, use vaddr as-is
        uint64_t dest_addr = is_pie ? (load_base + phdr->p_vaddr) : phdr->p_vaddr;

        printf("[ELF] LOAD: vaddr=0x%lx -> 0x%lx filesz=0x%lx memsz=0x%lx\n",
               phdr->p_vaddr, dest_addr, phdr->p_filesz, phdr->p_memsz);

        void *dest = (void *)dest_addr;
        const void *src = base + phdr->p_offset;

        // Copy file contents
        if (phdr->p_filesz > 0) {
            memcpy(dest, src, phdr->p_filesz);
        }

        // Zero BSS
        if (phdr->p_memsz > phdr->p_filesz) {
            uint64_t bss_start = dest_addr + phdr->p_filesz;
            uint64_t bss_size = phdr->p_memsz - phdr->p_filesz;
            printf("[ELF] Zeroing BSS: 0x%lx - 0x%lx (size 0x%lx)\n",
                   bss_start, bss_start + bss_size, bss_size);
            memset((uint8_t *)dest + phdr->p_filesz, 0, bss_size);
        }

        uint64_t seg_end = phdr->p_vaddr + phdr->p_memsz;
        if (seg_end > total_size) total_size = seg_end;
    }

    // Process relocations for PIE binaries
    if (is_pie && dynamic) {
        elf_process_relocations(load_base, dynamic);
    }

    // Calculate entry point
    uint64_t entry = is_pie ? (load_base + ehdr->e_entry) : ehdr->e_entry;

    printf("[ELF] Entry point: 0x%lx\n", entry);

    // Fill info struct
    if (info) {
        info->entry = entry;
        info->load_base = load_base;
        info->load_size = total_size;
    }

    return 0;
}
</file>

<file path="kernel/elf.h">
/*
 * VibeOS ELF64 Definitions
 */

#ifndef ELF_H
#define ELF_H

#include <stdint.h>
#include <stddef.h>

// ELF Magic
#define ELF_MAGIC 0x464C457F  // "\x7FELF" as little-endian uint32

// ELF64 Header
typedef struct {
    uint8_t  e_ident[16];    // ELF identification
    uint16_t e_type;         // Object file type
    uint16_t e_machine;      // Machine type
    uint32_t e_version;      // Object file version
    uint64_t e_entry;        // Entry point address
    uint64_t e_phoff;        // Program header offset
    uint64_t e_shoff;        // Section header offset
    uint32_t e_flags;        // Processor-specific flags
    uint16_t e_ehsize;       // ELF header size
    uint16_t e_phentsize;    // Program header entry size
    uint16_t e_phnum;        // Number of program headers
    uint16_t e_shentsize;    // Section header entry size
    uint16_t e_shnum;        // Number of section headers
    uint16_t e_shstrndx;     // Section name string table index
} Elf64_Ehdr;

// Program Header
typedef struct {
    uint32_t p_type;         // Segment type
    uint32_t p_flags;        // Segment flags
    uint64_t p_offset;       // Segment offset in file
    uint64_t p_vaddr;        // Virtual address
    uint64_t p_paddr;        // Physical address
    uint64_t p_filesz;       // Size in file
    uint64_t p_memsz;        // Size in memory
    uint64_t p_align;        // Alignment
} Elf64_Phdr;

// Program header types
#define PT_NULL    0
#define PT_LOAD    1
#define PT_DYNAMIC 2
#define PT_INTERP  3

// Dynamic section entry
typedef struct {
    int64_t  d_tag;
    uint64_t d_val;
} Elf64_Dyn;

// Dynamic tags
#define DT_NULL    0
#define DT_RELA    7   // Address of Rela relocs
#define DT_RELASZ  8   // Total size of Rela relocs
#define DT_RELAENT 9   // Size of one Rela entry

// Relocation entry with addend
typedef struct {
    uint64_t r_offset;
    uint64_t r_info;
    int64_t  r_addend;
} Elf64_Rela;

// Relocation types for AArch64
#define R_AARCH64_RELATIVE 0x403

// ELF identification indices
#define EI_MAG0    0
#define EI_MAG1    1
#define EI_MAG2    2
#define EI_MAG3    3
#define EI_CLASS   4
#define EI_DATA    5

// ELF class
#define ELFCLASS64 2

// ELF data encoding
#define ELFDATA2LSB 1  // Little endian

// Machine types
#define EM_AARCH64 183

// ELF types
#define ET_EXEC 2
#define ET_DYN  3  // Shared object / PIE

// Info about a loaded program
typedef struct {
    uint64_t entry;       // Entry point (absolute address)
    uint64_t load_base;   // Where it was loaded
    uint64_t load_size;   // Total size in memory
} elf_load_info_t;

// Validate ELF header, returns 0 if valid
int elf_validate(const void *data, size_t size);

// Get entry point from ELF
uint64_t elf_entry(const void *data);

// Load ELF segments into memory, returns entry point or 0 on failure
// DEPRECATED: use elf_load_at instead
uint64_t elf_load(const void *data, size_t size);

// Load ELF at a specific base address (for PIE binaries)
// Returns 0 on success, fills info struct
int elf_load_at(const void *data, size_t size, uint64_t base, elf_load_info_t *info);

// Calculate total memory size needed for ELF
uint64_t elf_calc_size(const void *data, size_t size);

#endif
</file>

<file path="kernel/fb.c">
/*
 * VibeOS Framebuffer Driver
 *
 * Uses QEMU ramfb device via fw_cfg interface (non-DMA)
 */

#include "fb.h"
#include "printf.h"
#include "string.h"
#include "memory.h"

// Framebuffer state
uint32_t fb_width = 0;
uint32_t fb_height = 0;
uint32_t fb_pitch = 0;
uint32_t *fb_base = NULL;

// QEMU fw_cfg MMIO interface (for aarch64 virt machine)
#define FW_CFG_BASE         0x09020000
#define FW_CFG_DATA8        (*(volatile uint8_t *)(FW_CFG_BASE + 0x00))
#define FW_CFG_DATA16       (*(volatile uint16_t *)(FW_CFG_BASE + 0x00))
#define FW_CFG_DATA32       (*(volatile uint32_t *)(FW_CFG_BASE + 0x00))
#define FW_CFG_DATA64       (*(volatile uint64_t *)(FW_CFG_BASE + 0x00))
#define FW_CFG_SELECTOR     (*(volatile uint16_t *)(FW_CFG_BASE + 0x08))
#define FW_CFG_DMA_ADDR_HI  (*(volatile uint32_t *)(FW_CFG_BASE + 0x10))
#define FW_CFG_DMA_ADDR_LO  (*(volatile uint32_t *)(FW_CFG_BASE + 0x14))

// fw_cfg selectors
#define FW_CFG_SIGNATURE    0x0000
#define FW_CFG_FILE_DIR     0x0019

// ramfb configuration structure (big-endian!)
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t fourcc;
    uint32_t flags;
    uint32_t width;
    uint32_t height;
    uint32_t stride;
} ramfb_config_t;

// Byte swap helpers for big-endian fw_cfg
static uint16_t bswap16(uint16_t x) {
    return (x >> 8) | (x << 8);
}

static uint32_t bswap32(uint32_t x) {
    return ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) |
           ((x << 8) & 0xff0000) | ((x << 24) & 0xff000000);
}

static uint64_t bswap64(uint64_t x) {
    return ((uint64_t)bswap32(x & 0xFFFFFFFF) << 32) | bswap32(x >> 32);
}

// DMA control structure
typedef struct __attribute__((packed)) {
    uint32_t control;
    uint32_t length;
    uint64_t address;
} fw_cfg_dma_t;

#define FW_CFG_DMA_CTL_ERROR  0x01
#define FW_CFG_DMA_CTL_READ   0x02
#define FW_CFG_DMA_CTL_SKIP   0x04
#define FW_CFG_DMA_CTL_SELECT 0x08
#define FW_CFG_DMA_CTL_WRITE  0x10

// File directory entry
typedef struct __attribute__((packed)) {
    uint32_t size;
    uint16_t select;
    uint16_t reserved;
    char name[56];
} fw_cfg_file_t;

// Read bytes from current fw_cfg selection
static void fw_cfg_read(void *buf, uint32_t len) {
    uint8_t *p = (uint8_t *)buf;
    for (uint32_t i = 0; i < len; i++) {
        p[i] = FW_CFG_DATA8;
    }
}

// Write bytes via DMA
static void fw_cfg_write_dma(uint16_t selector, void *buf, uint32_t len) {
    volatile fw_cfg_dma_t dma __attribute__((aligned(16)));

    dma.control = bswap32(FW_CFG_DMA_CTL_SELECT | FW_CFG_DMA_CTL_WRITE | ((uint32_t)selector << 16));
    dma.length = bswap32(len);
    dma.address = bswap64((uint64_t)buf);

    uint64_t dma_addr = (uint64_t)&dma;

    // Memory barrier
    asm volatile("dsb sy" ::: "memory");

    // Write DMA address (big-endian, high word first)
    FW_CFG_DMA_ADDR_HI = bswap32((uint32_t)(dma_addr >> 32));
    FW_CFG_DMA_ADDR_LO = bswap32((uint32_t)(dma_addr & 0xFFFFFFFF));

    // Wait for completion
    while (bswap32(dma.control) & ~FW_CFG_DMA_CTL_ERROR) {
        asm volatile("dsb sy" ::: "memory");
    }
}

static int find_ramfb_selector(void) {
    // Select file directory - selector is written as little-endian on MMIO
    FW_CFG_SELECTOR = bswap16(FW_CFG_FILE_DIR);

    // Small delay for selector to take effect
    for (volatile int i = 0; i < 1000; i++);

    // Read file count (big-endian in the data)
    uint32_t count;
    fw_cfg_read(&count, sizeof(count));
    count = bswap32(count);

    printf("[FB] fw_cfg has %d files\n", count);

    if (count == 0 || count > 100) {
        // Try without byteswap on selector
        FW_CFG_SELECTOR = FW_CFG_FILE_DIR;
        for (volatile int i = 0; i < 1000; i++);
        fw_cfg_read(&count, sizeof(count));
        count = bswap32(count);
        printf("[FB] Retry: fw_cfg has %d files\n", count);
    }

    if (count == 0 || count > 100) {
        printf("[FB] ERROR: Unreasonable file count\n");
        return -1;
    }

    // Search for "etc/ramfb"
    for (uint32_t i = 0; i < count; i++) {
        fw_cfg_file_t file;
        fw_cfg_read(&file, sizeof(file));

        if (strcmp(file.name, "etc/ramfb") == 0) {
            uint16_t sel = bswap16(file.select);
            printf("[FB] Found ramfb: select=0x%x size=%d\n", sel, bswap32(file.size));
            return sel;
        }
    }

    return -1;
}

int fb_init(void) {
    printf("[FB] Initializing framebuffer...\n");

    // Find ramfb config selector
    int selector = find_ramfb_selector();
    if (selector < 0) {
        printf("[FB] ERROR: ramfb device not found!\n");
        return -1;
    }

    // Set up our desired resolution
    fb_width = 1024;
    fb_height = 768;
    fb_pitch = fb_width * 4;  // 4 bytes per pixel (32-bit)

    // Allocate framebuffer from heap
    // Size = 800 * 600 * 4 = 1,920,000 bytes (~1.9 MB)
    size_t fb_size = fb_width * fb_height * sizeof(uint32_t);
    fb_base = (uint32_t *)malloc(fb_size);
    if (!fb_base) {
        printf("[FB] ERROR: Failed to allocate framebuffer!\n");
        return -1;
    }

    // Configure ramfb (all values big-endian)
    ramfb_config_t config;
    config.addr = bswap64((uint64_t)fb_base);
    config.fourcc = bswap32(0x34325258);  // "XR24" = XRGB8888
    config.flags = bswap32(0);
    config.width = bswap32(fb_width);
    config.height = bswap32(fb_height);
    config.stride = bswap32(fb_pitch);

    // Write config via DMA
    fw_cfg_write_dma((uint16_t)selector, &config, sizeof(config));

    printf("[FB] Configured: %dx%d @ %p\n", fb_width, fb_height, fb_base);

    // Clear to black
    fb_clear(COLOR_BLACK);

    printf("[FB] Framebuffer ready!\n");
    return 0;
}

void fb_put_pixel(uint32_t x, uint32_t y, uint32_t color) {
    if (x >= fb_width || y >= fb_height) return;
    fb_base[y * fb_width + x] = color;
}

void fb_fill_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {
    for (uint32_t row = y; row < y + h && row < fb_height; row++) {
        for (uint32_t col = x; col < x + w && col < fb_width; col++) {
            fb_base[row * fb_width + col] = color;
        }
    }
}

void fb_clear(uint32_t color) {
    for (uint32_t i = 0; i < fb_width * fb_height; i++) {
        fb_base[i] = color;
    }
}

// Include font data
#include "font.h"

void fb_draw_char(uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg) {
    const uint8_t *glyph = font_data[(uint8_t)c];

    for (int row = 0; row < FONT_HEIGHT; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < FONT_WIDTH; col++) {
            uint32_t color = (bits & (0x80 >> col)) ? fg : bg;
            fb_put_pixel(x + col, y + row, color);
        }
    }
}

void fb_draw_string(uint32_t x, uint32_t y, const char *s, uint32_t fg, uint32_t bg) {
    uint32_t orig_x = x;
    while (*s) {
        if (*s == '\n') {
            x = orig_x;
            y += FONT_HEIGHT;
        } else {
            fb_draw_char(x, y, *s, fg, bg);
            x += FONT_WIDTH;
        }
        s++;
    }
}
</file>

<file path="kernel/irq.c">
/*
 * VibeOS Interrupt Handling
 *
 * GIC-400 driver for QEMU virt machine.
 * Uses GICv2 interface at 0x08000000.
 */

#include "irq.h"
#include "printf.h"
#include "keyboard.h"
#include "virtio_sound.h"

// QEMU virt machine GIC addresses
#define GICD_BASE   0x08000000UL  // Distributor
#define GICC_BASE   0x08010000UL  // CPU Interface

// GIC Distributor registers
#define GICD_CTLR       (*(volatile uint32_t *)(GICD_BASE + 0x000))  // Control
#define GICD_TYPER      (*(volatile uint32_t *)(GICD_BASE + 0x004))  // Type
#define GICD_IGROUPR(n)   (*(volatile uint32_t *)(GICD_BASE + 0x080 + (n)*4))  // Group (0=Secure, 1=Non-Secure)
#define GICD_ISENABLER(n) (*(volatile uint32_t *)(GICD_BASE + 0x100 + (n)*4))  // Set-Enable
#define GICD_ICENABLER(n) (*(volatile uint32_t *)(GICD_BASE + 0x180 + (n)*4))  // Clear-Enable
#define GICD_ISPENDR(n)   (*(volatile uint32_t *)(GICD_BASE + 0x200 + (n)*4))  // Set-Pending
#define GICD_ICPENDR(n)   (*(volatile uint32_t *)(GICD_BASE + 0x280 + (n)*4))  // Clear-Pending
#define GICD_IPRIORITYR(n) (*(volatile uint32_t *)(GICD_BASE + 0x400 + (n)*4)) // Priority
#define GICD_ITARGETSR(n)  (*(volatile uint32_t *)(GICD_BASE + 0x800 + (n)*4)) // Target CPU
#define GICD_ICFGR(n)      (*(volatile uint32_t *)(GICD_BASE + 0xC00 + (n)*4)) // Config

// GIC CPU Interface registers
#define GICC_CTLR   (*(volatile uint32_t *)(GICC_BASE + 0x000))  // Control
#define GICC_PMR    (*(volatile uint32_t *)(GICC_BASE + 0x004))  // Priority Mask
#define GICC_IAR    (*(volatile uint32_t *)(GICC_BASE + 0x00C))  // Interrupt Acknowledge
#define GICC_EOIR   (*(volatile uint32_t *)(GICC_BASE + 0x010))  // End of Interrupt

// Timer registers (Generic Timer)
#define CNTFRQ_EL0      "cntfrq_el0"
#define CNTP_CTL_EL0    "cntp_ctl_el0"
#define CNTP_TVAL_EL0   "cntp_tval_el0"
#define CNTP_CVAL_EL0   "cntp_cval_el0"
#define CNTPCT_EL0      "cntpct_el0"

// Timer IRQ (EL1 Physical Timer is PPI 30, which is IRQ 30)
#define TIMER_IRQ   30

// Virtio IRQs start at SPI 32 (IRQ 32+)
#define VIRTIO_IRQ_BASE 48

// Maximum number of IRQs we support
#define MAX_IRQS    128

// IRQ handlers
static irq_handler_t irq_handlers[MAX_IRQS] = {0};

// Timer state
static uint64_t timer_ticks = 0;
static uint32_t timer_interval_ticks = 0;
static uint32_t timer_freq = 0;

// Memory barrier
static inline void dmb(void) {
    asm volatile("dmb sy" ::: "memory");
}

static inline void dsb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline void isb(void) {
    asm volatile("isb" ::: "memory");
}

// Read system register
static inline uint64_t read_sysreg(const char *reg) {
    uint64_t val;
    if (__builtin_strcmp(reg, CNTFRQ_EL0) == 0) {
        asm volatile("mrs %0, cntfrq_el0" : "=r"(val));
    } else if (__builtin_strcmp(reg, CNTP_CTL_EL0) == 0) {
        asm volatile("mrs %0, cntp_ctl_el0" : "=r"(val));
    } else if (__builtin_strcmp(reg, CNTP_TVAL_EL0) == 0) {
        asm volatile("mrs %0, cntp_tval_el0" : "=r"(val));
    } else if (__builtin_strcmp(reg, CNTPCT_EL0) == 0) {
        asm volatile("mrs %0, cntpct_el0" : "=r"(val));
    }
    return val;
}

// Write system register
static inline void write_sysreg(const char *reg, uint64_t val) {
    if (__builtin_strcmp(reg, CNTP_CTL_EL0) == 0) {
        asm volatile("msr cntp_ctl_el0, %0" :: "r"(val));
    } else if (__builtin_strcmp(reg, CNTP_TVAL_EL0) == 0) {
        asm volatile("msr cntp_tval_el0, %0" :: "r"(val));
    } else if (__builtin_strcmp(reg, CNTP_CVAL_EL0) == 0) {
        asm volatile("msr cntp_cval_el0, %0" :: "r"(val));
    }
    isb();
}

void irq_enable(void) {
    asm volatile("msr daifclr, #2" ::: "memory");  // Clear IRQ mask
}

void irq_disable(void) {
    asm volatile("msr daifset, #2" ::: "memory");  // Set IRQ mask
}

void irq_enable_irq(uint32_t irq) {
    if (irq >= MAX_IRQS) return;
    uint32_t reg = irq / 32;
    uint32_t bit = irq % 32;
    dsb();
    GICD_ISENABLER(reg) = (1 << bit);
    dsb();
}

void irq_disable_irq(uint32_t irq) {
    if (irq >= MAX_IRQS) return;
    uint32_t reg = irq / 32;
    uint32_t bit = irq % 32;
    dsb();
    GICD_ICENABLER(reg) = (1 << bit);
    dsb();
}

void irq_register_handler(uint32_t irq, irq_handler_t handler) {
    if (irq < MAX_IRQS) {
        irq_handlers[irq] = handler;
    }
}

void irq_init(void) {
    printf("[IRQ] Initializing GIC...\n");

    // Disable distributor while configuring
    dsb();
    GICD_CTLR = 0;
    dsb();

    // Get number of IRQ lines
    uint32_t typer = GICD_TYPER;
    uint32_t num_irqs = ((typer & 0x1F) + 1) * 32;
    printf("[IRQ] GIC supports %d IRQs\n", num_irqs);

    // Disable all IRQs
    for (uint32_t i = 0; i < num_irqs / 32; i++) {
        GICD_ICENABLER(i) = 0xFFFFFFFF;
    }
    dsb();

    // Clear all pending IRQs
    for (uint32_t i = 0; i < num_irqs / 32; i++) {
        GICD_ICPENDR(i) = 0xFFFFFFFF;
    }
    dsb();

    // Set all SPIs to Group 0 (Secure)
    // We're running in Secure EL1, so interrupts must be Group 0
    // Group 0 interrupts are delivered as IRQ in Secure state
    for (uint32_t i = 0; i < num_irqs / 32; i++) {
        GICD_IGROUPR(i) = 0x00000000;  // All bits = 0 means Group 0 (Secure)
    }
    dsb();
    printf("[IRQ] All interrupts set to Group 0 (Secure)\n");

    // Set all IRQs to mid priority
    for (uint32_t i = 0; i < num_irqs / 4; i++) {
        GICD_IPRIORITYR(i) = 0xA0A0A0A0;  // Priority 160 for all
    }
    dsb();

    // Route all SPIs to CPU 0
    // ITARGETSR registers 0-7 are for SGIs/PPIs (read-only or banked)
    // SPIs start at register 8 (IRQ 32+)
    for (uint32_t i = 8; i < num_irqs / 4; i++) {
        GICD_ITARGETSR(i) = 0x01010101;  // Target CPU 0
    }
    dsb();
    printf("[IRQ] All SPIs targeted to CPU 0\n");

    // Configure all SPIs as level-sensitive (required for virtio!)
    // ICFGR registers: 2 bits per IRQ, 00 = level, 10 = edge
    // Registers 0-1 are for SGIs/PPIs
    for (uint32_t i = 2; i < num_irqs / 16; i++) {
        GICD_ICFGR(i) = 0x00000000;  // Level-sensitive
    }
    dsb();

    // Enable distributor - Group 0 only (we're Secure)
    // Bit 0: Enable Group 0
    GICD_CTLR = 0x1;
    dsb();

    // Configure CPU interface
    GICC_PMR = 0xFF;   // Accept all priority levels (lowest threshold)
    dsb();

    // Enable CPU interface - Group 0 only
    // Bit 0: Enable Group 0
    GICC_CTLR = 0x1;
    dsb();

    printf("[IRQ] GIC initialized (Secure, Group 0)\n");
}

void timer_init(uint32_t interval_ms) {
    // Get timer frequency
    asm volatile("mrs %0, cntfrq_el0" : "=r"(timer_freq));
    printf("[TIMER] Frequency: %u Hz\n", timer_freq);

    // Calculate ticks per interval
    timer_interval_ticks = (timer_freq / 1000) * interval_ms;
    printf("[TIMER] Interval: %u ms (%u ticks)\n", interval_ms, timer_interval_ticks);

    // Set timer value
    asm volatile("msr cntp_tval_el0, %0" :: "r"(timer_interval_ticks));
    isb();

    // Enable timer (bit 0 = enable, bit 1 = mask output)
    asm volatile("msr cntp_ctl_el0, %0" :: "r"((uint64_t)1));
    isb();

    // Enable timer IRQ in GIC
    irq_enable_irq(TIMER_IRQ);

    printf("[TIMER] Timer initialized\n");
}

void timer_set_interval(uint32_t interval_ms) {
    timer_interval_ticks = (timer_freq / 1000) * interval_ms;
}

uint64_t timer_get_ticks(void) {
    return timer_ticks;
}

void wfi(void) {
    asm volatile("wfi");
}

void sleep_ms(uint32_t ms) {
    // Timer runs at 100Hz (10ms per tick)
    // Convert ms to ticks, rounding up
    uint64_t ticks_to_wait = (ms + 9) / 10;
    if (ticks_to_wait == 0) ticks_to_wait = 1;

    uint64_t target = timer_ticks + ticks_to_wait;
    while (timer_ticks < target) {
        wfi();  // Sleep until next interrupt (timer, keyboard, mouse)
    }
}

// Timer IRQ handler
static void timer_handler(void) {
    timer_ticks++;

    // Pump audio if playing
    virtio_sound_pump();

    // Reload timer
    asm volatile("msr cntp_tval_el0, %0" :: "r"(timer_interval_ticks));
    isb();
}

// Main IRQ handler - called from vectors.S
void handle_irq(void) {
    dsb();

    // Read interrupt ID
    uint32_t iar = GICC_IAR;
    uint32_t irq = iar & 0x3FF;

    // Check for spurious interrupt
    if (irq == 1023) {
        return;
    }

    // Handle the interrupt
    if (irq == TIMER_IRQ) {
        timer_handler();
    } else if (irq_handlers[irq]) {
        irq_handlers[irq]();
    } else {
        printf("[IRQ] Unhandled IRQ %d\n", irq);
    }

    // Signal end of interrupt
    dsb();
    GICC_EOIR = iar;
    dsb();
}

// Synchronous exception handler
void handle_sync_exception(uint64_t esr, uint64_t elr, uint64_t far) {
    uint32_t ec = (esr >> 26) & 0x3F;   // Exception Class
    uint32_t iss = esr & 0x1FFFFFF;      // Instruction Specific Syndrome

    printf("\n");
    printf("==========================================\n");
    printf("  KERNEL PANIC: Synchronous Exception\n");
    printf("==========================================\n");
    printf("  ESR_EL1: 0x%08lx\n", esr);
    printf("  ELR_EL1: 0x%016lx (return address)\n", elr);
    printf("  FAR_EL1: 0x%016lx (fault address)\n", far);
    printf("\n");
    printf("  Exception Class (EC): 0x%02x = ", ec);

    switch (ec) {
        case 0x00: printf("Unknown reason\n"); break;
        case 0x01: printf("Trapped WFI/WFE\n"); break;
        case 0x0E: printf("Illegal execution state\n"); break;
        case 0x15: printf("SVC instruction (syscall)\n"); break;
        case 0x20: printf("Instruction abort from lower EL\n"); break;
        case 0x21: printf("Instruction abort from current EL\n"); break;
        case 0x22: printf("PC alignment fault\n"); break;
        case 0x24: printf("Data abort from lower EL\n"); break;
        case 0x25: printf("Data abort from current EL\n"); break;
        case 0x26: printf("SP alignment fault\n"); break;
        case 0x2C: printf("Floating-point exception\n"); break;
        default:   printf("(see ARM ARM)\n"); break;
    }

    printf("  ISS: 0x%06x\n", iss);

    // For data/instruction aborts, decode more info
    if (ec == 0x24 || ec == 0x25 || ec == 0x20 || ec == 0x21) {
        printf("  Access type: %s\n", (iss & (1 << 6)) ? "Write" : "Read");
        printf("  DFSC/IFSC: 0x%02x\n", iss & 0x3F);
    }

    printf("\n");
    printf("  System halted.\n");
    printf("==========================================\n");

    // Halt
    irq_disable();
    while (1) {
        asm volatile("wfi");
    }
}

// FIQ handler (not used)
void handle_fiq(void) {
    printf("[IRQ] FIQ received (unexpected)\n");
}

// SError handler
void handle_serror(uint64_t esr) {
    printf("\n");
    printf("==========================================\n");
    printf("  KERNEL PANIC: SError (Async Abort)\n");
    printf("==========================================\n");
    printf("  ESR_EL1: 0x%08lx\n", esr);
    printf("  System halted.\n");
    printf("==========================================\n");

    irq_disable();
    while (1) {
        asm volatile("wfi");
    }
}
</file>

<file path="kernel/keyboard.h">
/*
 * VibeOS Keyboard Driver
 *
 * Virtio keyboard input
 */

#ifndef KEYBOARD_H
#define KEYBOARD_H

#include <stdint.h>

// Initialize keyboard
int keyboard_init(void);

// Get a character (returns -1 if none available)
int keyboard_getc(void);

// Check if key is available
int keyboard_has_key(void);

// IRQ handler (called from irq.c)
void keyboard_irq_handler(void);

// Get the keyboard's IRQ number
uint32_t keyboard_get_irq(void);

// Enable interrupt-driven mode (disables polling)
void keyboard_enable_irq_mode(void);

#endif
</file>

<file path="kernel/mouse.c">
/*
 * VibeOS Virtio Mouse/Tablet Driver
 *
 * Uses virtio-input (tablet mode) for absolute positioning.
 * QEMU provides virtio-tablet which sends EV_ABS events.
 */

#include "mouse.h"
#include "printf.h"
#include "string.h"

// Virtio MMIO registers (same as keyboard)
#define VIRTIO_MMIO_BASE        0x0a000000
#define VIRTIO_MMIO_STRIDE      0x200

#define VIRTIO_MMIO_MAGIC           0x000
#define VIRTIO_MMIO_VERSION         0x004
#define VIRTIO_MMIO_DEVICE_ID       0x008
#define VIRTIO_MMIO_VENDOR_ID       0x00c
#define VIRTIO_MMIO_DEVICE_FEATURES 0x010
#define VIRTIO_MMIO_DRIVER_FEATURES 0x020
#define VIRTIO_MMIO_QUEUE_SEL       0x030
#define VIRTIO_MMIO_QUEUE_NUM_MAX   0x034
#define VIRTIO_MMIO_QUEUE_NUM       0x038
#define VIRTIO_MMIO_QUEUE_READY     0x044
#define VIRTIO_MMIO_QUEUE_NOTIFY    0x050
#define VIRTIO_MMIO_INTERRUPT_STATUS 0x060
#define VIRTIO_MMIO_INTERRUPT_ACK   0x064
#define VIRTIO_MMIO_STATUS          0x070
#define VIRTIO_MMIO_QUEUE_DESC_LOW  0x080
#define VIRTIO_MMIO_QUEUE_DESC_HIGH 0x084
#define VIRTIO_MMIO_QUEUE_AVAIL_LOW 0x090
#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH 0x094
#define VIRTIO_MMIO_QUEUE_USED_LOW  0x0a0
#define VIRTIO_MMIO_QUEUE_USED_HIGH 0x0a4

#define VIRTIO_STATUS_ACK       1
#define VIRTIO_STATUS_DRIVER    2
#define VIRTIO_STATUS_DRIVER_OK 4
#define VIRTIO_STATUS_FEATURES_OK 8

#define VIRTIO_DEV_INPUT        18

// Linux input event types
#define EV_SYN      0x00
#define EV_KEY      0x01
#define EV_REL      0x02
#define EV_ABS      0x03

// Absolute axis codes
#define ABS_X       0x00
#define ABS_Y       0x01

// Mouse button codes (BTN_LEFT = 0x110, etc)
#define BTN_LEFT    0x110
#define BTN_RIGHT   0x111
#define BTN_MIDDLE  0x112

// Virtio input config
#define VIRTIO_INPUT_CFG_SELECT  0x100
#define VIRTIO_INPUT_CFG_SUBSEL  0x101
#define VIRTIO_INPUT_CFG_SIZE    0x102
#define VIRTIO_INPUT_CFG_DATA    0x108
#define VIRTIO_INPUT_CFG_ID_NAME 0x01

// Virtio input event structure
typedef struct __attribute__((packed)) {
    uint16_t type;
    uint16_t code;
    uint32_t value;
} virtio_input_event_t;

// Virtqueue structures
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} virtq_desc_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} virtq_avail_t;

typedef struct __attribute__((packed)) {
    uint32_t id;
    uint32_t len;
} virtq_used_elem_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    virtq_used_elem_t ring[];
} virtq_used_t;

#define QUEUE_SIZE 16
#define DESC_F_WRITE 2

// Virtio MMIO IRQs start at 48 (SPI 16) on QEMU virt
#define VIRTIO_IRQ_BASE 48

// Mouse state
static volatile uint32_t *mouse_base = NULL;
static int mouse_device_index = -1;  // Which virtio device slot (for IRQ calculation)
static virtq_desc_t *desc = NULL;
static virtq_avail_t *avail = NULL;
static virtq_used_t *used = NULL;
static virtio_input_event_t *events = NULL;
static uint16_t last_used_idx = 0;

// Queue memory
static uint8_t queue_mem[4096] __attribute__((aligned(4096)));
static virtio_input_event_t event_bufs[QUEUE_SIZE] __attribute__((aligned(16)));

// Current mouse state
static int mouse_x = 0;        // Raw value (0-32767)
static int mouse_y = 0;
static uint8_t mouse_buttons = 0;
static int mouse_event_pending = 0;

// Memory barriers
static inline void mb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline uint32_t read32(volatile uint32_t *addr) {
    uint32_t val = *addr;
    mb();
    return val;
}

static inline void write32(volatile uint32_t *addr, uint32_t val) {
    mb();
    *addr = val;
    mb();
}

// Find virtio-tablet device (mouse with absolute positioning)
static volatile uint32_t *find_virtio_tablet(void) {
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(uintptr_t)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);
        volatile uint8_t *base8 = (volatile uint8_t *)(uintptr_t)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic != 0x74726976 || device_id != VIRTIO_DEV_INPUT) {
            continue;
        }

        // Check device name for "Tablet"
        base8[VIRTIO_INPUT_CFG_SELECT] = VIRTIO_INPUT_CFG_ID_NAME;
        base8[VIRTIO_INPUT_CFG_SUBSEL] = 0;
        mb();

        uint8_t size = base8[VIRTIO_INPUT_CFG_SIZE];
        char name[32] = {0};
        for (int j = 0; j < 31 && j < size; j++) {
            name[j] = base8[VIRTIO_INPUT_CFG_DATA + j];
        }

        // Look for "Tablet" in name
        if (name[0] == 'Q' && name[5] == 'V' && name[12] == 'T') {
            mouse_device_index = i;
            return base;
        }
    }

    return NULL;
}

int mouse_init(void) {
    printf("[MOUSE] Initializing mouse...\n");

    mouse_base = find_virtio_tablet();
    if (!mouse_base) {
        return -1;
    }

    // Reset device
    write32(mouse_base + VIRTIO_MMIO_STATUS/4, 0);
    while (read32(mouse_base + VIRTIO_MMIO_STATUS/4) != 0) {
        asm volatile("nop");
    }

    // Acknowledge
    write32(mouse_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK);
    write32(mouse_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER);

    // Accept no special features
    write32(mouse_base + VIRTIO_MMIO_DRIVER_FEATURES/4, 0);
    write32(mouse_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK);

    // Setup queue 0
    write32(mouse_base + VIRTIO_MMIO_QUEUE_SEL/4, 0);

    uint32_t max_queue = read32(mouse_base + VIRTIO_MMIO_QUEUE_NUM_MAX/4);
    if (max_queue < QUEUE_SIZE) {
        printf("[MOUSE] Queue too small\n");
        return -1;
    }

    write32(mouse_base + VIRTIO_MMIO_QUEUE_NUM/4, QUEUE_SIZE);

    // Setup queue memory
    desc = (virtq_desc_t *)queue_mem;
    avail = (virtq_avail_t *)(queue_mem + QUEUE_SIZE * sizeof(virtq_desc_t));
    used = (virtq_used_t *)(queue_mem + 2048);
    events = event_bufs;

    // Set queue addresses
    uint64_t desc_addr = (uint64_t)(uintptr_t)desc;
    uint64_t avail_addr = (uint64_t)(uintptr_t)avail;
    uint64_t used_addr = (uint64_t)(uintptr_t)used;

    write32(mouse_base + VIRTIO_MMIO_QUEUE_DESC_LOW/4, (uint32_t)desc_addr);
    write32(mouse_base + VIRTIO_MMIO_QUEUE_DESC_HIGH/4, (uint32_t)(desc_addr >> 32));
    write32(mouse_base + VIRTIO_MMIO_QUEUE_AVAIL_LOW/4, (uint32_t)avail_addr);
    write32(mouse_base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH/4, (uint32_t)(avail_addr >> 32));
    write32(mouse_base + VIRTIO_MMIO_QUEUE_USED_LOW/4, (uint32_t)used_addr);
    write32(mouse_base + VIRTIO_MMIO_QUEUE_USED_HIGH/4, (uint32_t)(used_addr >> 32));

    // Initialize descriptors
    for (int i = 0; i < QUEUE_SIZE; i++) {
        desc[i].addr = (uint64_t)(uintptr_t)&events[i];
        desc[i].len = sizeof(virtio_input_event_t);
        desc[i].flags = DESC_F_WRITE;
        desc[i].next = 0;
    }

    // Fill available ring
    avail->flags = 0;
    for (int i = 0; i < QUEUE_SIZE; i++) {
        avail->ring[i] = i;
    }
    avail->idx = QUEUE_SIZE;

    // Queue ready
    write32(mouse_base + VIRTIO_MMIO_QUEUE_READY/4, 1);

    // Driver OK
    write32(mouse_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK | VIRTIO_STATUS_DRIVER_OK);

    // Notify device
    write32(mouse_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    // Check status
    uint32_t status = read32(mouse_base + VIRTIO_MMIO_STATUS/4);
    if (status & 0x40) {
        printf("[MOUSE] Device reported failure!\n");
        return -1;
    }

    // Center mouse initially
    mouse_x = 16384;
    mouse_y = 16384;

    printf("[MOUSE] Mouse initialized!\n");
    return 0;
}

void mouse_poll(void) {
    if (!mouse_base || !used) return;

    mb();
    uint16_t current_used = used->idx;

    while (last_used_idx != current_used) {
        uint16_t idx = last_used_idx % QUEUE_SIZE;
        uint32_t desc_idx = used->ring[idx].id;

        virtio_input_event_t *ev = &events[desc_idx];

        // Process event
        if (ev->type == EV_ABS) {
            if (ev->code == ABS_X) {
                mouse_x = ev->value;
                mouse_event_pending = 1;
            } else if (ev->code == ABS_Y) {
                mouse_y = ev->value;
                mouse_event_pending = 1;
            }
        } else if (ev->type == EV_KEY) {
            // Mouse button events
            int pressed = (ev->value != 0);
            if (ev->code == BTN_LEFT) {
                if (pressed) mouse_buttons |= MOUSE_BTN_LEFT;
                else mouse_buttons &= ~MOUSE_BTN_LEFT;
                mouse_event_pending = 1;
            } else if (ev->code == BTN_RIGHT) {
                if (pressed) mouse_buttons |= MOUSE_BTN_RIGHT;
                else mouse_buttons &= ~MOUSE_BTN_RIGHT;
                mouse_event_pending = 1;
            } else if (ev->code == BTN_MIDDLE) {
                if (pressed) mouse_buttons |= MOUSE_BTN_MIDDLE;
                else mouse_buttons &= ~MOUSE_BTN_MIDDLE;
                mouse_event_pending = 1;
            }
        }

        // Re-add descriptor to available ring
        uint16_t avail_idx = avail->idx % QUEUE_SIZE;
        avail->ring[avail_idx] = desc_idx;
        avail->idx++;

        last_used_idx++;
    }

    // Notify device
    write32(mouse_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);
    write32(mouse_base + VIRTIO_MMIO_INTERRUPT_ACK/4,
            read32(mouse_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));
}

void mouse_get_pos(int *x, int *y) {
    mouse_poll();
    if (x) *x = mouse_x;
    if (y) *y = mouse_y;
}

void mouse_get_screen_pos(int *x, int *y) {
    mouse_poll();

    // Scale from 0-32767 to screen dimensions
    // fb_width and fb_height are global variables from fb.h
    extern uint32_t fb_width, fb_height;

    if (x) *x = (mouse_x * (int)fb_width) / 32768;
    if (y) *y = (mouse_y * (int)fb_height) / 32768;
}

uint8_t mouse_get_buttons(void) {
    mouse_poll();
    return mouse_buttons;
}

int mouse_has_event(void) {
    mouse_poll();
    int pending = mouse_event_pending;
    mouse_event_pending = 0;
    return pending;
}

// Get the mouse's IRQ number
uint32_t mouse_get_irq(void) {
    if (mouse_device_index < 0) {
        return 0;  // Not initialized
    }
    return VIRTIO_IRQ_BASE + mouse_device_index;
}

// IRQ handler - called from irq.c
void mouse_irq_handler(void) {
    mouse_poll();
}
</file>

<file path="kernel/vfs.h">
/*
 * VibeOS Virtual File System
 *
 * Simple in-memory filesystem with hierarchical directories
 */

#ifndef VFS_H
#define VFS_H

#include <stdint.h>
#include <stddef.h>

// File types
#define VFS_FILE      1
#define VFS_DIRECTORY 2

// Max limits
#define VFS_MAX_NAME     64
#define VFS_MAX_CHILDREN 32
#define VFS_MAX_PATH     256
#define VFS_MAX_INODES   256

// Forward declaration
struct vfs_node;

// Directory entry
typedef struct vfs_node {
    char name[VFS_MAX_NAME];
    uint8_t type;                           // VFS_FILE or VFS_DIRECTORY

    // For files
    char *data;                             // File contents
    size_t size;                            // File size
    size_t capacity;                        // Allocated capacity

    // For directories
    struct vfs_node *children[VFS_MAX_CHILDREN];
    int child_count;

    // Tree structure
    struct vfs_node *parent;
} vfs_node_t;

// Initialize the filesystem
void vfs_init(void);

// Path operations
vfs_node_t *vfs_lookup(const char *path);
vfs_node_t *vfs_get_root(void);
vfs_node_t *vfs_get_cwd(void);
int vfs_set_cwd(const char *path);
int vfs_get_cwd_path(char *buf, size_t size);

// Directory operations
vfs_node_t *vfs_mkdir(const char *path);
int vfs_readdir(vfs_node_t *dir, int index, char *name, size_t name_size, uint8_t *type);

// File operations
vfs_node_t *vfs_create(const char *path);
int vfs_read(vfs_node_t *file, char *buf, size_t size, size_t offset);
int vfs_write(vfs_node_t *file, const char *buf, size_t size);
int vfs_append(vfs_node_t *file, const char *buf, size_t size);

// Delete file
int vfs_delete(const char *path);

// Delete empty directory
int vfs_delete_dir(const char *path);

// Delete file or directory recursively
int vfs_delete_recursive(const char *path);

// Rename (same directory only)
int vfs_rename(const char *path, const char *newname);

// Utility
int vfs_is_dir(vfs_node_t *node);
int vfs_is_file(vfs_node_t *node);

#endif
</file>

<file path="kernel/virtio_sound.c">
/*
 * VibeOS Virtio Sound Driver
 *
 * Implements virtio-snd for audio playback on QEMU virt machine.
 * Based on virtio 1.2 spec (modern mode).
 *
 * Device ID: 25
 * Virtqueues:
 *   0 - controlq (control messages)
 *   1 - eventq (device events)
 *   2 - txq (audio output)
 *   3 - rxq (audio input)
 */

#include "virtio_sound.h"
#include "printf.h"
#include "string.h"

// Virtio MMIO registers
#define VIRTIO_MMIO_BASE        0x0a000000
#define VIRTIO_MMIO_STRIDE      0x200

// Virtio MMIO register offsets
#define VIRTIO_MMIO_MAGIC           0x000
#define VIRTIO_MMIO_VERSION         0x004
#define VIRTIO_MMIO_DEVICE_ID       0x008
#define VIRTIO_MMIO_VENDOR_ID       0x00c
#define VIRTIO_MMIO_DEVICE_FEATURES 0x010
#define VIRTIO_MMIO_DEVICE_FEATURES_SEL 0x014
#define VIRTIO_MMIO_DRIVER_FEATURES 0x020
#define VIRTIO_MMIO_DRIVER_FEATURES_SEL 0x024
#define VIRTIO_MMIO_QUEUE_SEL       0x030
#define VIRTIO_MMIO_QUEUE_NUM_MAX   0x034
#define VIRTIO_MMIO_QUEUE_NUM       0x038
#define VIRTIO_MMIO_QUEUE_READY     0x044
#define VIRTIO_MMIO_QUEUE_NOTIFY    0x050
#define VIRTIO_MMIO_INTERRUPT_STATUS 0x060
#define VIRTIO_MMIO_INTERRUPT_ACK   0x064
#define VIRTIO_MMIO_STATUS          0x070
#define VIRTIO_MMIO_QUEUE_DESC_LOW  0x080
#define VIRTIO_MMIO_QUEUE_DESC_HIGH 0x084
#define VIRTIO_MMIO_QUEUE_AVAIL_LOW 0x090
#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH 0x094
#define VIRTIO_MMIO_QUEUE_USED_LOW  0x0a0
#define VIRTIO_MMIO_QUEUE_USED_HIGH 0x0a4
#define VIRTIO_MMIO_CONFIG          0x100

// Virtio status bits
#define VIRTIO_STATUS_ACK         1
#define VIRTIO_STATUS_DRIVER      2
#define VIRTIO_STATUS_DRIVER_OK   4
#define VIRTIO_STATUS_FEATURES_OK 8

// Virtio device types
#define VIRTIO_DEV_SOUND  25

// Virtio sound virtqueue indices
#define VIRTIO_SND_VQ_CONTROL  0
#define VIRTIO_SND_VQ_EVENT    1
#define VIRTIO_SND_VQ_TX       2
#define VIRTIO_SND_VQ_RX       3

// Virtio sound request codes
#define VIRTIO_SND_R_JACK_INFO       0x0001
#define VIRTIO_SND_R_JACK_REMAP      0x0002
#define VIRTIO_SND_R_PCM_INFO        0x0100
#define VIRTIO_SND_R_PCM_SET_PARAMS  0x0101
#define VIRTIO_SND_R_PCM_PREPARE     0x0102
#define VIRTIO_SND_R_PCM_RELEASE     0x0103
#define VIRTIO_SND_R_PCM_START       0x0104
#define VIRTIO_SND_R_PCM_STOP        0x0105
#define VIRTIO_SND_R_CHMAP_INFO      0x0200

// Virtio sound status codes
#define VIRTIO_SND_S_OK        0x8000
#define VIRTIO_SND_S_BAD_MSG   0x8001
#define VIRTIO_SND_S_NOT_SUPP  0x8002
#define VIRTIO_SND_S_IO_ERR    0x8003

// PCM stream direction
#define VIRTIO_SND_D_OUTPUT  0
#define VIRTIO_SND_D_INPUT   1

// PCM sample formats
#define VIRTIO_SND_PCM_FMT_IMA_ADPCM  0
#define VIRTIO_SND_PCM_FMT_MU_LAW     1
#define VIRTIO_SND_PCM_FMT_A_LAW      2
#define VIRTIO_SND_PCM_FMT_S8         3
#define VIRTIO_SND_PCM_FMT_U8         4
#define VIRTIO_SND_PCM_FMT_S16        5
#define VIRTIO_SND_PCM_FMT_U16        6
#define VIRTIO_SND_PCM_FMT_S18_3      7
#define VIRTIO_SND_PCM_FMT_U18_3      8
#define VIRTIO_SND_PCM_FMT_S20_3      9
#define VIRTIO_SND_PCM_FMT_U20_3      10
#define VIRTIO_SND_PCM_FMT_S24_3      11
#define VIRTIO_SND_PCM_FMT_U24_3      12
#define VIRTIO_SND_PCM_FMT_S20        13
#define VIRTIO_SND_PCM_FMT_U20        14
#define VIRTIO_SND_PCM_FMT_S24        15
#define VIRTIO_SND_PCM_FMT_U24        16
#define VIRTIO_SND_PCM_FMT_S32        17
#define VIRTIO_SND_PCM_FMT_U32        18
#define VIRTIO_SND_PCM_FMT_FLOAT      19
#define VIRTIO_SND_PCM_FMT_FLOAT64    20

// PCM sample rates (as indices)
#define VIRTIO_SND_PCM_RATE_5512    0
#define VIRTIO_SND_PCM_RATE_8000    1
#define VIRTIO_SND_PCM_RATE_11025   2
#define VIRTIO_SND_PCM_RATE_16000   3
#define VIRTIO_SND_PCM_RATE_22050   4
#define VIRTIO_SND_PCM_RATE_32000   5
#define VIRTIO_SND_PCM_RATE_44100   6
#define VIRTIO_SND_PCM_RATE_48000   7
#define VIRTIO_SND_PCM_RATE_64000   8
#define VIRTIO_SND_PCM_RATE_88200   9
#define VIRTIO_SND_PCM_RATE_96000   10
#define VIRTIO_SND_PCM_RATE_176400  11
#define VIRTIO_SND_PCM_RATE_192000  12
#define VIRTIO_SND_PCM_RATE_384000  13

// Virtqueue structures
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} virtq_desc_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} virtq_avail_t;

typedef struct __attribute__((packed)) {
    uint32_t id;
    uint32_t len;
} virtq_used_elem_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    virtq_used_elem_t ring[];
} virtq_used_t;

// Virtio sound config space
typedef struct __attribute__((packed)) {
    uint32_t jacks;
    uint32_t streams;
    uint32_t chmaps;
} virtio_snd_config_t;

// Generic request header
typedef struct __attribute__((packed)) {
    uint32_t code;
} virtio_snd_hdr_t;

// PCM request header
typedef struct __attribute__((packed)) {
    uint32_t code;
    uint32_t stream_id;
} virtio_snd_pcm_hdr_t;

// Query info request
typedef struct __attribute__((packed)) {
    uint32_t code;
    uint32_t start_id;
    uint32_t count;
    uint32_t size;
} virtio_snd_query_info_t;

// PCM info response (per stream)
typedef struct __attribute__((packed)) {
    uint32_t hda_fn_nid;
    uint32_t features;
    uint64_t formats;      // Bitmask of supported formats
    uint64_t rates;        // Bitmask of supported rates
    uint8_t  direction;
    uint8_t  channels_min;
    uint8_t  channels_max;
    uint8_t  padding[5];
} virtio_snd_pcm_info_t;

// PCM set params request
typedef struct __attribute__((packed)) {
    uint32_t code;
    uint32_t stream_id;
    uint32_t buffer_bytes;
    uint32_t period_bytes;
    uint32_t features;
    uint8_t  channels;
    uint8_t  format;
    uint8_t  rate;
    uint8_t  padding;
} virtio_snd_pcm_set_params_t;

// PCM xfer header (for TX/RX queues)
typedef struct __attribute__((packed)) {
    uint32_t stream_id;
} virtio_snd_pcm_xfer_t;

// PCM status response
typedef struct __attribute__((packed)) {
    uint32_t status;
    uint32_t latency_bytes;
} virtio_snd_pcm_status_t;

// Driver state
static volatile uint32_t *snd_base = NULL;
static int snd_device_index = -1;

// Queue structures - one set per queue
#define QUEUE_SIZE 64
#define DESC_F_NEXT  1
#define DESC_F_WRITE 2

// Control queue
static uint8_t ctrl_queue_mem[4096] __attribute__((aligned(4096)));
static virtq_desc_t *ctrl_desc = NULL;
static virtq_avail_t *ctrl_avail = NULL;
static virtq_used_t *ctrl_used = NULL;
static uint16_t ctrl_last_used = 0;

// TX queue (audio output)
static uint8_t tx_queue_mem[4096] __attribute__((aligned(4096)));
static virtq_desc_t *tx_desc = NULL;
static virtq_avail_t *tx_avail = NULL;
static virtq_used_t *tx_used = NULL;
static uint16_t tx_last_used = 0;

// Request/response buffers
static virtio_snd_hdr_t ctrl_response __attribute__((aligned(16)));
static virtio_snd_pcm_status_t tx_status __attribute__((aligned(16)));

// Audio playback state
static int playing = 0;
static uint32_t playback_position = 0;

// Async playback state
static const uint8_t *async_pcm_data = NULL;
static uint32_t async_pcm_bytes = 0;
static uint32_t async_pcm_offset = 0;
static int async_playing = 0;
static int async_paused = 0;
static uint8_t async_channels = 2;
static uint32_t async_sample_rate = 44100;

// Memory barriers for device communication
static inline void mb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline uint32_t read32(volatile uint32_t *addr) {
    uint32_t val = *addr;
    mb();
    return val;
}

static inline void write32(volatile uint32_t *addr, uint32_t val) {
    mb();
    *addr = val;
    mb();
}

static volatile uint32_t *find_virtio_sound(void) {
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic == 0x74726976 && device_id == VIRTIO_DEV_SOUND) {
            snd_device_index = i;
            return base;
        }
    }

    return NULL;
}

static int setup_queue(int queue_num, uint8_t *queue_mem,
                       virtq_desc_t **desc_out, virtq_avail_t **avail_out, virtq_used_t **used_out) {
    write32(snd_base + VIRTIO_MMIO_QUEUE_SEL/4, queue_num);

    uint32_t max_queue = read32(snd_base + VIRTIO_MMIO_QUEUE_NUM_MAX/4);
    if (max_queue == 0) {
        printf("[SND] Queue %d not available\n", queue_num);
        return -1;
    }

    uint32_t queue_size = (max_queue < QUEUE_SIZE) ? max_queue : QUEUE_SIZE;
    write32(snd_base + VIRTIO_MMIO_QUEUE_NUM/4, queue_size);

    // Setup queue memory layout
    *desc_out = (virtq_desc_t *)queue_mem;
    *avail_out = (virtq_avail_t *)(queue_mem + queue_size * sizeof(virtq_desc_t));
    *used_out = (virtq_used_t *)(queue_mem + 2048);  // Aligned offset

    uint64_t desc_addr = (uint64_t)*desc_out;
    uint64_t avail_addr = (uint64_t)*avail_out;
    uint64_t used_addr = (uint64_t)*used_out;

    write32(snd_base + VIRTIO_MMIO_QUEUE_DESC_LOW/4, (uint32_t)desc_addr);
    write32(snd_base + VIRTIO_MMIO_QUEUE_DESC_HIGH/4, (uint32_t)(desc_addr >> 32));
    write32(snd_base + VIRTIO_MMIO_QUEUE_AVAIL_LOW/4, (uint32_t)avail_addr);
    write32(snd_base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH/4, (uint32_t)(avail_addr >> 32));
    write32(snd_base + VIRTIO_MMIO_QUEUE_USED_LOW/4, (uint32_t)used_addr);
    write32(snd_base + VIRTIO_MMIO_QUEUE_USED_HIGH/4, (uint32_t)(used_addr >> 32));

    (*avail_out)->flags = 0;
    (*avail_out)->idx = 0;

    write32(snd_base + VIRTIO_MMIO_QUEUE_READY/4, 1);

    return 0;
}

// Send a control request and wait for response
static int send_ctrl_request(void *request, uint32_t req_len, void *response, uint32_t resp_len) {
    // Setup descriptor chain: request (device reads) -> response (device writes)
    ctrl_desc[0].addr = (uint64_t)request;
    ctrl_desc[0].len = req_len;
    ctrl_desc[0].flags = DESC_F_NEXT;
    ctrl_desc[0].next = 1;

    ctrl_desc[1].addr = (uint64_t)response;
    ctrl_desc[1].len = resp_len;
    ctrl_desc[1].flags = DESC_F_WRITE;
    ctrl_desc[1].next = 0;

    // Add to available ring
    mb();
    uint16_t old_used_idx = ctrl_used->idx;
    uint16_t avail_slot = ctrl_avail->idx % QUEUE_SIZE;
    ctrl_avail->ring[avail_slot] = 0;
    mb();
    ctrl_avail->idx++;
    mb();

    // Notify device
    write32(snd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, VIRTIO_SND_VQ_CONTROL);

    // Poll for completion
    int timeout = 10000000;
    while (ctrl_used->idx == old_used_idx && timeout > 0) {
        mb();
        timeout--;
    }

    if (timeout == 0) {
        printf("[SND] Control request timed out\n");
        return -1;
    }

    ctrl_last_used = ctrl_used->idx;

    // Ack interrupt
    write32(snd_base + VIRTIO_MMIO_INTERRUPT_ACK/4, read32(snd_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    return 0;
}

int virtio_sound_init(void) {
    printf("[SND] Initializing sound...\n");

    snd_base = find_virtio_sound();
    if (!snd_base) {
        printf("[SND] No virtio-sound device found\n");
        return -1;
    }

    printf("[SND] Found virtio-sound at device %d\n", snd_device_index);

    // Reset device
    write32(snd_base + VIRTIO_MMIO_STATUS/4, 0);
    while (read32(snd_base + VIRTIO_MMIO_STATUS/4) != 0) {
        asm volatile("nop");
    }

    // Acknowledge and set driver
    write32(snd_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK);
    write32(snd_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER);

    // Read device config
    volatile uint8_t *config = (volatile uint8_t *)snd_base + VIRTIO_MMIO_CONFIG;
    uint32_t jacks = *(volatile uint32_t *)(config + 0);
    uint32_t streams = *(volatile uint32_t *)(config + 4);
    uint32_t chmaps = *(volatile uint32_t *)(config + 8);
    printf("[SND] Config: jacks=%d streams=%d chmaps=%d\n", jacks, streams, chmaps);

    if (streams == 0) {
        printf("[SND] No PCM streams available\n");
        return -1;
    }

    // Accept no special features
    write32(snd_base + VIRTIO_MMIO_DEVICE_FEATURES_SEL/4, 0);
    write32(snd_base + VIRTIO_MMIO_DRIVER_FEATURES_SEL/4, 0);
    write32(snd_base + VIRTIO_MMIO_DRIVER_FEATURES/4, 0);
    write32(snd_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK);

    uint32_t status = read32(snd_base + VIRTIO_MMIO_STATUS/4);
    if (!(status & VIRTIO_STATUS_FEATURES_OK)) {
        printf("[SND] Feature negotiation failed\n");
        return -1;
    }

    // Setup control queue
    if (setup_queue(VIRTIO_SND_VQ_CONTROL, ctrl_queue_mem, &ctrl_desc, &ctrl_avail, &ctrl_used) < 0) {
        printf("[SND] Failed to setup control queue\n");
        return -1;
    }

    // Setup TX queue (audio output)
    if (setup_queue(VIRTIO_SND_VQ_TX, tx_queue_mem, &tx_desc, &tx_avail, &tx_used) < 0) {
        printf("[SND] Failed to setup TX queue\n");
        return -1;
    }

    // Mark driver ready
    write32(snd_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK | VIRTIO_STATUS_DRIVER_OK);

    status = read32(snd_base + VIRTIO_MMIO_STATUS/4);
    if (status & 0x40) {
        printf("[SND] Device failure\n");
        return -1;
    }

    // Query PCM stream info
    static virtio_snd_query_info_t query __attribute__((aligned(16)));
    static virtio_snd_hdr_t query_resp __attribute__((aligned(16)));
    static virtio_snd_pcm_info_t pcm_info __attribute__((aligned(16)));

    query.code = VIRTIO_SND_R_PCM_INFO;
    query.start_id = 0;
    query.count = 1;
    query.size = sizeof(virtio_snd_pcm_info_t);

    // For PCM_INFO, we need: request -> response header -> pcm_info array
    // Setup 3-descriptor chain
    ctrl_desc[0].addr = (uint64_t)&query;
    ctrl_desc[0].len = sizeof(query);
    ctrl_desc[0].flags = DESC_F_NEXT;
    ctrl_desc[0].next = 1;

    ctrl_desc[1].addr = (uint64_t)&query_resp;
    ctrl_desc[1].len = sizeof(query_resp);
    ctrl_desc[1].flags = DESC_F_NEXT | DESC_F_WRITE;
    ctrl_desc[1].next = 2;

    ctrl_desc[2].addr = (uint64_t)&pcm_info;
    ctrl_desc[2].len = sizeof(pcm_info);
    ctrl_desc[2].flags = DESC_F_WRITE;
    ctrl_desc[2].next = 0;

    mb();
    uint16_t old_used = ctrl_used->idx;
    ctrl_avail->ring[ctrl_avail->idx % QUEUE_SIZE] = 0;
    mb();
    ctrl_avail->idx++;
    mb();
    write32(snd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, VIRTIO_SND_VQ_CONTROL);

    int timeout = 10000000;
    while (ctrl_used->idx == old_used && timeout > 0) {
        mb();
        timeout--;
    }

    write32(snd_base + VIRTIO_MMIO_INTERRUPT_ACK/4, read32(snd_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    if (timeout == 0) {
        printf("[SND] PCM_INFO timed out\n");
    } else {
        printf("[SND] PCM stream 0: direction=%d, channels=%d-%d, formats=0x%x, rates=0x%x\n",
               pcm_info.direction, pcm_info.channels_min, pcm_info.channels_max,
               (uint32_t)pcm_info.formats, (uint32_t)pcm_info.rates);
    }

    printf("[SND] Sound initialized!\n");
    return 0;
}

// Configure stream for playback
static int configure_stream(uint8_t channels, uint8_t format, uint8_t rate) {
    static virtio_snd_pcm_set_params_t params __attribute__((aligned(16)));

    params.code = VIRTIO_SND_R_PCM_SET_PARAMS;
    params.stream_id = 0;
    params.buffer_bytes = 32768;  // 32KB buffer
    params.period_bytes = 4096;   // 4KB periods
    params.features = 0;
    params.channels = channels;
    params.format = format;
    params.rate = rate;
    params.padding = 0;

    if (send_ctrl_request(&params, sizeof(params), &ctrl_response, sizeof(ctrl_response)) < 0) {
        return -1;
    }

    if (ctrl_response.code != VIRTIO_SND_S_OK) {
        printf("[SND] SET_PARAMS failed: 0x%x\n", ctrl_response.code);
        return -1;
    }

    return 0;
}

// Prepare stream for playback
static int prepare_stream(void) {
    static virtio_snd_pcm_hdr_t hdr __attribute__((aligned(16)));

    hdr.code = VIRTIO_SND_R_PCM_PREPARE;
    hdr.stream_id = 0;

    if (send_ctrl_request(&hdr, sizeof(hdr), &ctrl_response, sizeof(ctrl_response)) < 0) {
        return -1;
    }

    if (ctrl_response.code != VIRTIO_SND_S_OK) {
        printf("[SND] PREPARE failed: 0x%x\n", ctrl_response.code);
        return -1;
    }

    return 0;
}

// Start stream
static int start_stream(void) {
    static virtio_snd_pcm_hdr_t hdr __attribute__((aligned(16)));

    hdr.code = VIRTIO_SND_R_PCM_START;
    hdr.stream_id = 0;

    if (send_ctrl_request(&hdr, sizeof(hdr), &ctrl_response, sizeof(ctrl_response)) < 0) {
        return -1;
    }

    if (ctrl_response.code != VIRTIO_SND_S_OK) {
        printf("[SND] START failed: 0x%x\n", ctrl_response.code);
        return -1;
    }

    return 0;
}

// Stop stream
static int stop_stream(void) {
    static virtio_snd_pcm_hdr_t hdr __attribute__((aligned(16)));

    hdr.code = VIRTIO_SND_R_PCM_STOP;
    hdr.stream_id = 0;

    if (send_ctrl_request(&hdr, sizeof(hdr), &ctrl_response, sizeof(ctrl_response)) < 0) {
        return -1;
    }

    if (ctrl_response.code != VIRTIO_SND_S_OK) {
        printf("[SND] STOP failed: 0x%x\n", ctrl_response.code);
        return -1;
    }

    return 0;
}

// Submit audio data to TX queue
static int submit_audio(const void *data, uint32_t size) {
    static virtio_snd_pcm_xfer_t xfer __attribute__((aligned(16)));

    xfer.stream_id = 0;

    // Descriptor chain: xfer header -> audio data -> status response
    tx_desc[0].addr = (uint64_t)&xfer;
    tx_desc[0].len = sizeof(xfer);
    tx_desc[0].flags = DESC_F_NEXT;
    tx_desc[0].next = 1;

    tx_desc[1].addr = (uint64_t)data;
    tx_desc[1].len = size;
    tx_desc[1].flags = DESC_F_NEXT;
    tx_desc[1].next = 2;

    tx_desc[2].addr = (uint64_t)&tx_status;
    tx_desc[2].len = sizeof(tx_status);
    tx_desc[2].flags = DESC_F_WRITE;
    tx_desc[2].next = 0;

    mb();
    uint16_t old_used = tx_used->idx;
    tx_avail->ring[tx_avail->idx % QUEUE_SIZE] = 0;
    mb();
    tx_avail->idx++;
    mb();

    // Notify TX queue
    write32(snd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, VIRTIO_SND_VQ_TX);

    // Wait for completion
    int timeout = 50000000;  // Longer timeout for audio
    while (tx_used->idx == old_used && timeout > 0) {
        mb();
        timeout--;
    }

    write32(snd_base + VIRTIO_MMIO_INTERRUPT_ACK/4, read32(snd_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    if (timeout == 0) {
        printf("[SND] Audio submit timed out\n");
        return -1;
    }

    if (tx_status.status != VIRTIO_SND_S_OK) {
        printf("[SND] Audio submit failed: 0x%x\n", tx_status.status);
        return -1;
    }

    tx_last_used = tx_used->idx;
    return 0;
}

// Convert sample rate in Hz to virtio rate index
static int hz_to_rate_index(uint32_t hz) {
    switch (hz) {
        case 5512:   return VIRTIO_SND_PCM_RATE_5512;
        case 8000:   return VIRTIO_SND_PCM_RATE_8000;
        case 11025:  return VIRTIO_SND_PCM_RATE_11025;
        case 16000:  return VIRTIO_SND_PCM_RATE_16000;
        case 22050:  return VIRTIO_SND_PCM_RATE_22050;
        case 32000:  return VIRTIO_SND_PCM_RATE_32000;
        case 44100:  return VIRTIO_SND_PCM_RATE_44100;
        case 48000:  return VIRTIO_SND_PCM_RATE_48000;
        case 64000:  return VIRTIO_SND_PCM_RATE_64000;
        case 88200:  return VIRTIO_SND_PCM_RATE_88200;
        case 96000:  return VIRTIO_SND_PCM_RATE_96000;
        case 176400: return VIRTIO_SND_PCM_RATE_176400;
        case 192000: return VIRTIO_SND_PCM_RATE_192000;
        default:     return -1;  // Unsupported
    }
}

int virtio_sound_play_pcm(const int16_t *data, uint32_t samples, uint8_t channels, uint32_t sample_rate) {
    if (!snd_base) return -1;

    int rate_idx = hz_to_rate_index(sample_rate);
    if (rate_idx < 0) {
        printf("[SND] Unsupported sample rate: %d\n", sample_rate);
        return -1;
    }

    if (configure_stream(channels, VIRTIO_SND_PCM_FMT_S16, rate_idx) < 0) {
        return -1;
    }

    if (prepare_stream() < 0) {
        return -1;
    }

    if (start_stream() < 0) {
        return -1;
    }

    playing = 1;
    playback_position = 0;

    // Submit audio in chunks
    uint32_t bytes = samples * channels * sizeof(int16_t);
    uint32_t chunk_size = 4096;  // Match period_bytes
    const uint8_t *ptr = (const uint8_t *)data;

    while (bytes > 0 && playing) {
        uint32_t to_send = (bytes < chunk_size) ? bytes : chunk_size;

        if (submit_audio(ptr, to_send) < 0) {
            break;
        }

        ptr += to_send;
        bytes -= to_send;
        playback_position += to_send / (channels * sizeof(int16_t));
    }

    stop_stream();
    playing = 0;

    return 0;
}

int virtio_sound_play(const int16_t *data, uint32_t samples) {
    // Legacy function - assume stereo 44100Hz
    return virtio_sound_play_pcm(data, samples, 2, 44100);
}

// WAV file header structure
typedef struct __attribute__((packed)) {
    char riff[4];           // "RIFF"
    uint32_t file_size;     // File size - 8
    char wave[4];           // "WAVE"
    char fmt[4];            // "fmt "
    uint32_t fmt_size;      // Format chunk size (16 for PCM)
    uint16_t audio_format;  // 1 = PCM
    uint16_t channels;      // 1 = mono, 2 = stereo
    uint32_t sample_rate;   // e.g. 44100
    uint32_t byte_rate;     // sample_rate * channels * bits/8
    uint16_t block_align;   // channels * bits/8
    uint16_t bits_per_sample;
} wav_header_t;

int virtio_sound_play_wav(const void *data, uint32_t size) {
    if (!snd_base) return -1;
    if (size < sizeof(wav_header_t) + 8) return -1;

    const uint8_t *ptr = (const uint8_t *)data;
    const wav_header_t *hdr = (const wav_header_t *)ptr;

    // Verify RIFF/WAVE header
    if (hdr->riff[0] != 'R' || hdr->riff[1] != 'I' ||
        hdr->riff[2] != 'F' || hdr->riff[3] != 'F') {
        printf("[SND] Not a RIFF file\n");
        return -1;
    }

    if (hdr->wave[0] != 'W' || hdr->wave[1] != 'A' ||
        hdr->wave[2] != 'V' || hdr->wave[3] != 'E') {
        printf("[SND] Not a WAVE file\n");
        return -1;
    }

    if (hdr->audio_format != 1) {
        printf("[SND] Only PCM format supported (got %d)\n", hdr->audio_format);
        return -1;
    }

    printf("[SND] WAV: %dHz, %d-bit, %d channels\n",
           hdr->sample_rate, hdr->bits_per_sample, hdr->channels);

    // Find format and rate indices
    uint8_t format;
    if (hdr->bits_per_sample == 8) {
        format = VIRTIO_SND_PCM_FMT_U8;
    } else if (hdr->bits_per_sample == 16) {
        format = VIRTIO_SND_PCM_FMT_S16;
    } else if (hdr->bits_per_sample == 32) {
        format = VIRTIO_SND_PCM_FMT_S32;
    } else {
        printf("[SND] Unsupported bit depth: %d\n", hdr->bits_per_sample);
        return -1;
    }

    uint8_t rate;
    switch (hdr->sample_rate) {
        case 8000:   rate = VIRTIO_SND_PCM_RATE_8000; break;
        case 11025:  rate = VIRTIO_SND_PCM_RATE_11025; break;
        case 16000:  rate = VIRTIO_SND_PCM_RATE_16000; break;
        case 22050:  rate = VIRTIO_SND_PCM_RATE_22050; break;
        case 32000:  rate = VIRTIO_SND_PCM_RATE_32000; break;
        case 44100:  rate = VIRTIO_SND_PCM_RATE_44100; break;
        case 48000:  rate = VIRTIO_SND_PCM_RATE_48000; break;
        case 96000:  rate = VIRTIO_SND_PCM_RATE_96000; break;
        default:
            printf("[SND] Unsupported sample rate: %d\n", hdr->sample_rate);
            return -1;
    }

    // Find data chunk
    ptr += sizeof(wav_header_t);
    uint32_t remaining = size - sizeof(wav_header_t);

    // Skip any extra fmt data
    if (hdr->fmt_size > 16) {
        uint32_t extra = hdr->fmt_size - 16;
        if (extra > remaining) return -1;
        ptr += extra;
        remaining -= extra;
    }

    // Find "data" chunk
    while (remaining >= 8) {
        if (ptr[0] == 'd' && ptr[1] == 'a' && ptr[2] == 't' && ptr[3] == 'a') {
            uint32_t data_size = *(uint32_t *)(ptr + 4);
            ptr += 8;
            remaining -= 8;

            if (data_size > remaining) {
                data_size = remaining;
            }

            printf("[SND] Playing %d bytes of audio...\n", data_size);

            // Configure and play
            if (configure_stream(hdr->channels, format, rate) < 0) {
                return -1;
            }

            if (prepare_stream() < 0) {
                return -1;
            }

            if (start_stream() < 0) {
                return -1;
            }

            playing = 1;
            playback_position = 0;

            // Submit audio in chunks
            uint32_t chunk_size = 4096;
            const uint8_t *audio_ptr = ptr;
            uint32_t bytes_left = data_size;

            while (bytes_left > 0 && playing) {
                uint32_t to_send = (bytes_left < chunk_size) ? bytes_left : chunk_size;

                if (submit_audio(audio_ptr, to_send) < 0) {
                    break;
                }

                audio_ptr += to_send;
                bytes_left -= to_send;
                playback_position += to_send / hdr->block_align;
            }

            stop_stream();
            playing = 0;

            printf("[SND] Playback complete\n");
            return 0;
        }

        // Skip unknown chunk
        uint32_t chunk_size = *(uint32_t *)(ptr + 4);
        ptr += 8 + chunk_size;
        if (8 + chunk_size > remaining) break;
        remaining -= 8 + chunk_size;
    }

    printf("[SND] No data chunk found\n");
    return -1;
}

void virtio_sound_stop(void) {
    if (!snd_base) return;
    playing = 0;
    async_playing = 0;
    async_paused = 0;
    async_pcm_data = NULL;
    stop_stream();
}

// Pause async playback - can be resumed later
void virtio_sound_pause(void) {
    if (!snd_base) return;
    if (!async_playing) return;  // Nothing to pause

    // Stop the stream but keep state
    stop_stream();
    async_playing = 0;
    async_paused = 1;
    playing = 0;
}

// Resume paused playback
int virtio_sound_resume(void) {
    if (!snd_base) return -1;
    if (!async_paused || !async_pcm_data) return -1;  // Nothing to resume

    int rate_idx = hz_to_rate_index(async_sample_rate);
    if (rate_idx < 0) return -1;

    // Reconfigure and restart stream
    if (configure_stream(async_channels, VIRTIO_SND_PCM_FMT_S16, rate_idx) < 0) {
        return -1;
    }

    if (prepare_stream() < 0) {
        return -1;
    }

    if (start_stream() < 0) {
        return -1;
    }

    // Resume from where we left off
    async_playing = 1;
    async_paused = 0;
    playing = 1;

    // Submit next chunk
    virtio_sound_pump();

    return 0;
}

int virtio_sound_is_paused(void) {
    return async_paused;
}

int virtio_sound_is_playing(void) {
    return playing;
}

void virtio_sound_set_volume(int volume) {
    (void)volume;  // Not implemented yet
}

uint32_t virtio_sound_get_position(void) {
    return playback_position;
}

// Non-blocking audio submit - returns immediately, doesn't wait for completion
static int submit_audio_async(const void *data, uint32_t size) {
    static virtio_snd_pcm_xfer_t xfer __attribute__((aligned(16)));

    xfer.stream_id = 0;

    // Descriptor chain: xfer header -> audio data -> status response
    tx_desc[0].addr = (uint64_t)&xfer;
    tx_desc[0].len = sizeof(xfer);
    tx_desc[0].flags = DESC_F_NEXT;
    tx_desc[0].next = 1;

    tx_desc[1].addr = (uint64_t)data;
    tx_desc[1].len = size;
    tx_desc[1].flags = DESC_F_NEXT;
    tx_desc[1].next = 2;

    tx_desc[2].addr = (uint64_t)&tx_status;
    tx_desc[2].len = sizeof(tx_status);
    tx_desc[2].flags = DESC_F_WRITE;
    tx_desc[2].next = 0;

    mb();
    tx_avail->ring[tx_avail->idx % QUEUE_SIZE] = 0;
    mb();
    tx_avail->idx++;
    mb();

    // Notify TX queue and return immediately
    write32(snd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, VIRTIO_SND_VQ_TX);

    return 0;
}

// Check if previous async submit completed
static int async_submit_ready(void) {
    static uint16_t last_checked_idx = 0;

    mb();
    if (tx_used->idx != last_checked_idx) {
        last_checked_idx = tx_used->idx;
        write32(snd_base + VIRTIO_MMIO_INTERRUPT_ACK/4,
                read32(snd_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));
        return 1;
    }
    return 0;
}

// Start async playback - returns immediately
int virtio_sound_play_pcm_async(const int16_t *data, uint32_t samples, uint8_t channels, uint32_t sample_rate) {
    if (!snd_base) return -1;

    // Stop any current playback
    if (async_playing || async_paused) {
        virtio_sound_stop();
    }

    int rate_idx = hz_to_rate_index(sample_rate);
    if (rate_idx < 0) {
        printf("[SND] Unsupported sample rate: %d\n", sample_rate);
        return -1;
    }

    if (configure_stream(channels, VIRTIO_SND_PCM_FMT_S16, rate_idx) < 0) {
        return -1;
    }

    if (prepare_stream() < 0) {
        return -1;
    }

    if (start_stream() < 0) {
        return -1;
    }

    // Store async state
    async_pcm_data = (const uint8_t *)data;
    async_pcm_bytes = samples * channels * sizeof(int16_t);
    async_pcm_offset = 0;
    async_playing = 1;
    async_paused = 0;
    async_channels = channels;
    async_sample_rate = sample_rate;
    playing = 1;
    playback_position = 0;

    // Submit first chunk
    virtio_sound_pump();

    return 0;
}

// Called periodically (e.g., from timer) to feed more audio data
void virtio_sound_pump(void) {
    if (!async_playing || !async_pcm_data) return;

    // Check if device is ready for more data
    if (!async_submit_ready() && async_pcm_offset > 0) {
        return;  // Previous chunk still processing
    }

    // Check if we're done
    if (async_pcm_offset >= async_pcm_bytes) {
        stop_stream();
        async_playing = 0;
        playing = 0;
        async_pcm_data = NULL;
        return;
    }

    // Submit next chunk
    uint32_t chunk_size = 4096;  // Match period_bytes
    uint32_t remaining = async_pcm_bytes - async_pcm_offset;
    uint32_t to_send = (remaining < chunk_size) ? remaining : chunk_size;

    submit_audio_async(async_pcm_data + async_pcm_offset, to_send);
    async_pcm_offset += to_send;
    playback_position = async_pcm_offset / 4;  // Approx samples (stereo S16)
}
</file>

<file path="kernel/virtio_sound.h">
/*
 * VibeOS Virtio Sound Driver
 *
 * Implements virtio-snd for audio playback on QEMU virt machine.
 * Based on virtio 1.2 spec (modern mode).
 */

#ifndef VIRTIO_SOUND_H
#define VIRTIO_SOUND_H

#include <stdint.h>

// Initialize the virtio sound device
// Returns 0 on success, -1 on failure
int virtio_sound_init(void);

// Play raw PCM audio with configurable format
// data: pointer to PCM samples (S16LE)
// samples: number of samples per channel (not bytes)
// channels: 1 = mono, 2 = stereo
// sample_rate: sample rate in Hz (e.g. 44100, 48000)
// Returns 0 on success, -1 on failure
int virtio_sound_play_pcm(const int16_t *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);

// Play raw PCM audio (legacy - assumes stereo 44100Hz)
// data: pointer to PCM samples (S16LE, stereo)
// samples: number of samples (not bytes)
// Returns 0 on success, -1 on failure
int virtio_sound_play(const int16_t *data, uint32_t samples);

// Play a WAV file from memory
// data: pointer to WAV file data
// size: size of WAV file in bytes
// Returns 0 on success, -1 on failure
int virtio_sound_play_wav(const void *data, uint32_t size);

// Stop playback
void virtio_sound_stop(void);

// Pause playback (can be resumed)
void virtio_sound_pause(void);

// Resume paused playback
// Returns 0 on success, -1 on failure
int virtio_sound_resume(void);

// Check if sound is currently playing
int virtio_sound_is_playing(void);

// Check if sound is paused
int virtio_sound_is_paused(void);

// Set volume (0-100)
void virtio_sound_set_volume(int volume);

// Get current playback position in samples
uint32_t virtio_sound_get_position(void);

// Async playback - starts playing and returns immediately
// The PCM buffer must remain valid until playback completes!
int virtio_sound_play_pcm_async(const int16_t *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);

// Pump audio data - call periodically (e.g., from timer) to feed audio
void virtio_sound_pump(void);

#endif // VIRTIO_SOUND_H
</file>

<file path="user/bin/cat.c">
/*
 * cat - concatenate and print files
 *
 * Supports multiple files: cat file1 file2
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    if (argc < 2) {
        out_puts("Usage: cat <file> [...]\n");
        return 1;
    }

    int status = 0;

    for (int i = 1; i < argc; i++) {
        void *file = k->open(argv[i]);
        if (!file) {
            out_puts("cat: ");
            out_puts(argv[i]);
            out_puts(": No such file\n");
            status = 1;
            continue;
        }

        if (k->is_dir(file)) {
            out_puts("cat: ");
            out_puts(argv[i]);
            out_puts(": Is a directory\n");
            status = 1;
            continue;
        }

        // Read and print file contents
        char buf[256];
        size_t offset = 0;
        int bytes;

        while ((bytes = k->read(file, buf, sizeof(buf) - 1, offset)) > 0) {
            buf[bytes] = '\0';
            out_puts(buf);
            offset += bytes;
        }
    }

    return status;
}
</file>

<file path="user/bin/echo.c">
/*
 * echo - print arguments
 *
 * Supports output redirection: echo hello > file.txt
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    // Check for output redirection
    int redir_idx = -1;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], ">") == 0 && i + 1 < argc) {
            redir_idx = i;
            break;
        }
    }

    if (redir_idx > 0) {
        // Redirect to file
        char *filename = argv[redir_idx + 1];
        void *file = k->create(filename);
        if (!file) {
            out_puts("echo: cannot create ");
            out_puts(filename);
            out_putc('\n');
            return 1;
        }

        // Build content from args before >
        char content[512];
        int pos = 0;
        for (int i = 1; i < redir_idx && pos < 510; i++) {
            int len = strlen(argv[i]);
            for (int j = 0; j < len && pos < 510; j++) {
                content[pos++] = argv[i][j];
            }
            if (i < redir_idx - 1 && pos < 510) {
                content[pos++] = ' ';
            }
        }
        content[pos++] = '\n';
        content[pos] = '\0';

        k->write(file, content, pos);
    } else {
        // Print to console
        for (int i = 1; i < argc; i++) {
            out_puts(argv[i]);
            if (i < argc - 1) {
                out_putc(' ');
            }
        }
        out_putc('\n');
    }

    return 0;
}
</file>

<file path="user/bin/ls.c">
/*
 * ls - list directory contents
 *
 * Uses the proper readdir API instead of accessing VFS internals.
 */

#include "../lib/vibe.h"

static kapi_t *api;

// I/O helpers - use stdio hooks if available
static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;
    const char *path = ".";

    if (argc > 1) {
        path = argv[1];
    }

    void *dir = k->open(path);
    if (!dir) {
        out_puts("ls: ");
        out_puts(path);
        out_puts(": No such file or directory\n");
        return 1;
    }

    if (!k->is_dir(dir)) {
        // It's a file, just print the name
        out_puts(path);
        out_putc('\n');
        return 0;
    }

    // List directory contents using readdir
    char name[256];
    uint8_t type;
    int index = 0;

    while (k->readdir(dir, index, name, sizeof(name), &type) >= 0) {
        out_puts(name);
        if (type == 2) {
            // Directory
            out_putc('/');
        }
        out_putc('\n');
        index++;
    }

    return 0;
}
</file>

<file path="user/bin/music.c">
/*
 * VibeOS Music Player
 *
 * Classic Mac System 7 style - 1-bit black & white
 */

#include "../lib/vibe.h"
#include "../lib/gfx.h"

// Disable SIMD - freestanding environment has no arm_neon.h
#define MINIMP3_NO_SIMD
#define MINIMP3_IMPLEMENTATION
#include "../../vendor/minimp3.h"

static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;
static gfx_ctx_t gfx;

// ============ Colors - Classic Mac ============
#define BLACK   0x00000000
#define WHITE   0x00FFFFFF
#define GRAY    0x00808080

// ============ Layout Constants ============
#define SIDEBAR_W       160
#define CONTROLS_H      85
#define ALBUM_ITEM_H    20
#define TRACK_ITEM_H    18

// ============ Player State ============
#define MAX_ALBUMS      32
#define MAX_TRACKS      64
#define MAX_NAME_LEN    64

typedef struct {
    char name[MAX_NAME_LEN];
    char path[128];
} album_t;

typedef struct {
    char name[MAX_NAME_LEN];
    char path[128];
} track_t;

static album_t albums[MAX_ALBUMS];
static int album_count = 0;
static int selected_album = -1;

static track_t tracks[MAX_TRACKS];
static int track_count = 0;
static int selected_track = -1;
static int playing_track = -1;

// Playback state
static int is_playing = 0;
static int volume = 80;  // 0-100

// Decoded audio buffer (kept for async playback)
static int16_t *pcm_buffer = NULL;
static uint32_t pcm_samples = 0;
static uint32_t pcm_sample_rate = 44100;
static uint32_t playback_start_tick = 0;
static uint32_t pause_elapsed_ms = 0;  // Elapsed time when paused

// Scroll positions
static int album_scroll = 0;
static int track_scroll = 0;

// Error message (shown briefly)
static char error_msg[64] = {0};
static uint32_t error_tick = 0;

// Loading state machine
typedef enum {
    LOAD_STATE_IDLE = 0,
    LOAD_STATE_LOADING_FILE,
    LOAD_STATE_COUNTING_SAMPLES,
    LOAD_STATE_DECODING,
    LOAD_STATE_STARTING_PLAYBACK
} load_state_t;

static load_state_t load_state = LOAD_STATE_IDLE;
static int is_loading = 0;

// Loading progress tracking
static int load_progress = 0;  // 0-100 percent
static int load_target_track = -1;

// File loading state
static uint8_t *load_mp3_data = NULL;
static int load_file_size = 0;
static int load_file_offset = 0;
static void *load_file_handle = NULL;

// Decode state
static mp3dec_t load_mp3d;
static const uint8_t *load_decode_ptr = NULL;
static int load_decode_remaining = 0;
static uint32_t load_total_samples = 0;
static int load_channels = 0;
static int16_t *load_out_ptr = NULL;
static uint32_t load_decoded_samples = 0;

// Chunk sizes for non-blocking operations
#define FILE_CHUNK_SIZE     (32 * 1024)   // 32KB per file read chunk
#define DECODE_FRAMES_PER_YIELD  20        // Decode 20 MP3 frames per yield

// ============ Drawing Helpers ============

#define fill_rect(x, y, w, h, c)     gfx_fill_rect(&gfx, x, y, w, h, c)
#define draw_char(x, y, ch, fg, bg)  gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define draw_string(x, y, s, fg, bg) gfx_draw_string(&gfx, x, y, s, fg, bg)
#define draw_rect(x, y, w, h, c)     gfx_draw_rect(&gfx, x, y, w, h, c)
#define draw_hline(x, y, w, c)       gfx_draw_hline(&gfx, x, y, w, c)
#define draw_vline(x, y, h, c)       gfx_draw_vline(&gfx, x, y, h, c)

// Draw text clipped to width
static void draw_text_clip(int x, int y, const char *s, uint32_t fg, uint32_t bg, int max_w) {
    int drawn = 0;
    while (*s && drawn + 8 <= max_w) {
        draw_char(x, y, *s, fg, bg);
        x += 8;
        drawn += 8;
        s++;
    }
}

// Show error message for 3 seconds
static void show_error(const char *msg) {
    int i = 0;
    while (msg[i] && i < 63) {
        error_msg[i] = msg[i];
        i++;
    }
    error_msg[i] = 0;
    error_tick = api->get_uptime_ticks();
}

// Draw 3D button (classic Mac style)
static void draw_button(int x, int y, int w, int h, const char *label, int pressed) {
    if (pressed) {
        fill_rect(x, y, w, h, BLACK);
        draw_string(x + (w - strlen(label) * 8) / 2, y + (h - 16) / 2, label, WHITE, BLACK);
    } else {
        fill_rect(x, y, w, h, WHITE);
        draw_rect(x, y, w, h, BLACK);
        // 3D effect
        draw_hline(x + 1, y + h - 2, w - 2, GRAY);
        draw_vline(x + w - 2, y + 1, h - 2, GRAY);
        draw_string(x + (w - strlen(label) * 8) / 2, y + (h - 16) / 2, label, BLACK, WHITE);
    }
}

// Draw checkerboard pattern (System 7 style)
static void draw_pattern(int x, int y, int w, int h) {
    for (int py = y; py < y + h && py < gfx.height; py++) {
        for (int px = x; px < x + w && px < gfx.width; px++) {
            if ((px + py) % 2 == 0) {
                gfx.buffer[py * gfx.width + px] = GRAY;
            } else {
                gfx.buffer[py * gfx.width + px] = WHITE;
            }
        }
    }
}

// ============ UI Drawing ============

static void draw_sidebar(void) {
    // Sidebar background
    fill_rect(0, 0, SIDEBAR_W, win_h - CONTROLS_H, WHITE);
    draw_vline(SIDEBAR_W - 1, 0, win_h - CONTROLS_H, BLACK);

    // Title
    draw_string(8, 6, "Albums", BLACK, WHITE);
    draw_hline(4, 24, SIDEBAR_W - 8, BLACK);

    // Album list
    int y = 28;
    int visible_albums = (win_h - CONTROLS_H - 32) / ALBUM_ITEM_H;

    for (int i = album_scroll; i < album_count && i < album_scroll + visible_albums; i++) {
        int item_y = y + (i - album_scroll) * ALBUM_ITEM_H;

        // Highlight selected
        if (i == selected_album) {
            fill_rect(2, item_y, SIDEBAR_W - 4, ALBUM_ITEM_H - 2, BLACK);
            draw_text_clip(6, item_y + 2, albums[i].name, WHITE, BLACK, SIDEBAR_W - 12);
        } else {
            draw_text_clip(6, item_y + 2, albums[i].name, BLACK, WHITE, SIDEBAR_W - 12);
        }
    }

    // Scroll arrows if needed
    if (album_count > visible_albums) {
        if (album_scroll > 0) {
            draw_string(SIDEBAR_W - 16, 28, "^", BLACK, WHITE);
        }
        if (album_scroll + visible_albums < album_count) {
            draw_string(SIDEBAR_W - 16, win_h - CONTROLS_H - 20, "v", BLACK, WHITE);
        }
    }
}

static void draw_track_list(void) {
    int x = SIDEBAR_W;
    int w = win_w - SIDEBAR_W;
    int h = win_h - CONTROLS_H;

    // Background
    fill_rect(x, 0, w, h, WHITE);

    // Show error message for 3 seconds
    if (error_msg[0] && api->get_uptime_ticks() - error_tick < 300) {
        int err_len = strlen(error_msg) * 8;
        int err_x = x + (w - err_len) / 2;
        fill_rect(err_x - 4, h - 30, err_len + 8, 20, BLACK);
        draw_string(err_x, h - 28, error_msg, WHITE, BLACK);
    } else {
        error_msg[0] = 0;  // Clear expired error
    }

    if (selected_album < 0 || selected_album >= album_count) {
        // No album selected
        draw_string(x + w/2 - 64, h/2 - 8, "Select album", BLACK, WHITE);
        return;
    }

    // Album header
    draw_string(x + 8, 6, albums[selected_album].name, BLACK, WHITE);

    // Track count
    char info[32];
    int tc = track_count;
    int len = 0;
    info[len++] = '(';
    if (tc >= 10) info[len++] = '0' + (tc / 10);
    info[len++] = '0' + (tc % 10);
    info[len++] = ' ';
    info[len++] = 't';
    info[len++] = 'r';
    info[len++] = 'a';
    info[len++] = 'c';
    info[len++] = 'k';
    if (tc != 1) info[len++] = 's';
    info[len++] = ')';
    info[len] = 0;
    draw_string(x + 8 + strlen(albums[selected_album].name) * 8 + 8, 6, info, GRAY, WHITE);

    draw_hline(x + 4, 24, w - 8, BLACK);

    // Track list
    int list_y = 28;
    int visible_tracks = (h - 32) / TRACK_ITEM_H;

    for (int i = track_scroll; i < track_count && i < track_scroll + visible_tracks; i++) {
        int item_y = list_y + (i - track_scroll) * TRACK_ITEM_H;

        // Track number
        char num[4];
        num[0] = '0' + ((i + 1) / 10);
        num[1] = '0' + ((i + 1) % 10);
        num[2] = '.';
        num[3] = 0;
        if (num[0] == '0') num[0] = ' ';

        // Highlight selected/playing
        if (i == selected_track) {
            fill_rect(x + 2, item_y, w - 4, TRACK_ITEM_H - 2, BLACK);
            draw_string(x + 6, item_y + 1, num, WHITE, BLACK);
        } else {
            draw_string(x + 6, item_y + 1, num, GRAY, WHITE);
        }

        // Playing indicator
        if (i == playing_track && is_playing) {
            if (i == selected_track) {
                draw_char(x + 6, item_y + 1, '>', WHITE, BLACK);
            } else {
                draw_char(x + 6, item_y + 1, '>', BLACK, WHITE);
            }
        }

        // Track name (strip .mp3)
        char display_name[MAX_NAME_LEN];
        int j = 0;
        for (; tracks[i].name[j] && j < MAX_NAME_LEN - 1; j++) {
            display_name[j] = tracks[i].name[j];
        }
        display_name[j] = 0;
        if (j > 4 && display_name[j-4] == '.' && display_name[j-3] == 'm') {
            display_name[j-4] = 0;
        }

        if (i == selected_track) {
            draw_text_clip(x + 32, item_y + 1, display_name, WHITE, BLACK, w - 40);
        } else {
            draw_text_clip(x + 32, item_y + 1, display_name, BLACK, WHITE, w - 40);
        }
    }
}

static void draw_controls(void) {
    int y = win_h - CONTROLS_H;

    // Background with border
    fill_rect(0, y, win_w, CONTROLS_H, WHITE);
    draw_hline(0, y, win_w, BLACK);

    // Now playing info (left side)
    if (playing_track >= 0 && playing_track < track_count) {
        char display_name[MAX_NAME_LEN];
        int j = 0;
        for (; tracks[playing_track].name[j] && j < MAX_NAME_LEN - 1; j++) {
            display_name[j] = tracks[playing_track].name[j];
        }
        display_name[j] = 0;
        if (j > 4 && display_name[j-4] == '.' && display_name[j-3] == 'm') {
            display_name[j-4] = 0;
        }

        draw_text_clip(8, y + 8, display_name, BLACK, WHITE, 180);
        draw_text_clip(8, y + 26, albums[selected_album].name, GRAY, WHITE, 180);
    } else if (is_loading) {
        const char *status = "Loading...";
        if (load_state == LOAD_STATE_LOADING_FILE) status = "Reading file...";
        else if (load_state == LOAD_STATE_DECODING) status = "Decoding...";
        draw_string(8, y + 16, status, BLACK, WHITE);
    } else {
        draw_string(8, y + 16, "No track", GRAY, WHITE);
    }

    // Center controls
    int cx = win_w / 2;
    int btn_y = y + 8;

    // |< Back
    draw_button(cx - 90, btn_y, 30, 24, "|<", 0);

    // Play/Pause
    if (is_playing) {
        draw_button(cx - 40, btn_y, 80, 24, "Pause", 0);
    } else {
        draw_button(cx - 40, btn_y, 80, 24, "Play", 0);
    }

    // >| Next
    draw_button(cx + 60, btn_y, 30, 24, ">|", 0);

    // Progress bar
    int prog_y = y + 42;
    int prog_x = 8;
    int prog_w = win_w - 100;

    // Time labels
    draw_string(prog_x, prog_y, "0:00", GRAY, WHITE);

    // Bar background
    fill_rect(prog_x + 40, prog_y + 4, prog_w - 80, 8, WHITE);
    draw_rect(prog_x + 40, prog_y + 4, prog_w - 80, 8, BLACK);

    // Progress fill - show for both playing and paused states
    if ((is_playing || (playing_track >= 0 && api->sound_is_paused && api->sound_is_paused()))
        && pcm_samples > 0 && pcm_sample_rate > 0) {
        uint32_t elapsed_ms;
        if (is_playing) {
            uint32_t now = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
            uint32_t elapsed_ticks = now - playback_start_tick;
            elapsed_ms = elapsed_ticks * 10;  // 100Hz timer
        } else {
            // Paused - use saved position
            elapsed_ms = pause_elapsed_ms;
        }
        uint32_t total_ms = ((uint64_t)pcm_samples * 1000) / pcm_sample_rate;

        if (elapsed_ms > total_ms) elapsed_ms = total_ms;

        int fill_w = ((prog_w - 84) * elapsed_ms) / (total_ms > 0 ? total_ms : 1);
        if (fill_w > 0) {
            // Dithered fill
            for (int py = prog_y + 5; py < prog_y + 11; py++) {
                for (int px = prog_x + 41; px < prog_x + 41 + fill_w; px++) {
                    if ((px + py) % 2 == 0) {
                        gfx.buffer[py * gfx.width + px] = BLACK;
                    }
                }
            }
        }

        // Time display
        int secs = elapsed_ms / 1000;
        int mins = secs / 60;
        secs = secs % 60;
        char time_str[8];
        time_str[0] = '0' + mins;
        time_str[1] = ':';
        time_str[2] = '0' + (secs / 10);
        time_str[3] = '0' + (secs % 10);
        time_str[4] = 0;
        draw_string(prog_x, prog_y, time_str, BLACK, WHITE);

        // Total time
        int total_secs = total_ms / 1000;
        int total_mins = total_secs / 60;
        total_secs = total_secs % 60;
        time_str[0] = '0' + total_mins;
        time_str[1] = ':';
        time_str[2] = '0' + (total_secs / 10);
        time_str[3] = '0' + (total_secs % 10);
        time_str[4] = 0;
        draw_string(prog_x + prog_w - 32, prog_y, time_str, GRAY, WHITE);
    } else {
        draw_string(prog_x + prog_w - 32, prog_y, "0:00", GRAY, WHITE);
    }

    // Volume (right side)
    int vol_x = win_w - 80;
    draw_string(vol_x, y + 8, "Vol:", BLACK, WHITE);

    // Volume bar
    fill_rect(vol_x, y + 28, 70, 10, WHITE);
    draw_rect(vol_x, y + 28, 70, 10, BLACK);
    int vol_fill = (volume * 66) / 100;
    fill_rect(vol_x + 2, y + 30, vol_fill, 6, BLACK);
}

static void draw_all(void) {
    draw_sidebar();
    draw_track_list();
    draw_controls();
    api->window_invalidate(window_id);
}

// ============ Album/Track Loading ============

static void scan_albums(void) {
    album_count = 0;

    void *dir = api->open("/home/user/Music");
    if (!dir || !api->is_dir(dir)) {
        return;
    }

    char name[MAX_NAME_LEN];
    uint8_t type;
    int idx = 0;

    while (album_count < MAX_ALBUMS && api->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        idx++;
        if (name[0] == '.') continue;
        if (type != 2) continue;  // 2 = directory

        int i = 0;
        while (name[i] && i < MAX_NAME_LEN - 1) {
            albums[album_count].name[i] = name[i];
            i++;
        }
        albums[album_count].name[i] = 0;

        char *p = albums[album_count].path;
        const char *base = "/home/user/Music/";
        while (*base) *p++ = *base++;
        i = 0;
        while (name[i]) *p++ = name[i++];
        *p = 0;

        album_count++;
    }
}

static void load_tracks(int album_idx) {
    track_count = 0;
    selected_track = -1;
    track_scroll = 0;

    if (album_idx < 0 || album_idx >= album_count) return;

    void *dir = api->open(albums[album_idx].path);
    if (!dir || !api->is_dir(dir)) return;

    char name[MAX_NAME_LEN];
    uint8_t type;
    int idx = 0;

    while (track_count < MAX_TRACKS && api->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        idx++;
        if (name[0] == '.') continue;
        if (type == 2) continue;

        int len = 0;
        while (name[len]) len++;
        if (len < 4) continue;
        if (name[len-4] != '.' || name[len-3] != 'm' || name[len-2] != 'p' || name[len-1] != '3') {
            continue;
        }

        int i = 0;
        while (name[i] && i < MAX_NAME_LEN - 1) {
            tracks[track_count].name[i] = name[i];
            i++;
        }
        tracks[track_count].name[i] = 0;

        char *p = tracks[track_count].path;
        const char *base = albums[album_idx].path;
        while (*base) *p++ = *base++;
        *p++ = '/';
        i = 0;
        while (name[i]) *p++ = name[i++];
        *p = 0;

        track_count++;
    }
}

// ============ Playback ============

static int play_track(int track_idx) {
    if (track_idx < 0 || track_idx >= track_count) return -1;

    // Stop current playback
    if (is_playing) {
        api->sound_stop();
        is_playing = 0;
    }

    // Free old buffer
    if (pcm_buffer) {
        api->free(pcm_buffer);
        pcm_buffer = NULL;
    }

    is_loading = 1;
    load_state = LOAD_STATE_LOADING_FILE;
    draw_all();
    api->yield();

    // Load file
    void *file = api->open(tracks[track_idx].path);
    if (!file) {
        is_loading = 0;
        load_state = LOAD_STATE_IDLE;
        show_error("Cannot open file");
        return -1;
    }

    int size = api->file_size(file);
    if (size <= 0) {
        is_loading = 0;
        load_state = LOAD_STATE_IDLE;
        show_error("Empty file");
        return -1;
    }

    uint8_t *mp3_data = api->malloc(size);
    if (!mp3_data) {
        is_loading = 0;
        load_state = LOAD_STATE_IDLE;
        show_error("Out of memory (file too large)");
        return -1;
    }

    int offset = 0;
    while (offset < size) {
        int n = api->read(file, (char *)mp3_data + offset, size - offset, offset);
        if (n <= 0) break;
        offset += n;
    }

    // Switch to decoding state
    load_state = LOAD_STATE_DECODING;
    draw_all();
    api->yield();

    // Single-pass decode with pre-allocated buffer
    // For 10MB MP3 @ 128kbps stereo: ~50 min = ~530MB PCM
    // Ratio ~53:1, but 320kbps would be ~21:1. Use 15x for safety.
    uint32_t max_pcm_bytes = (uint32_t)size * 15;
    pcm_buffer = api->malloc(max_pcm_bytes);
    if (!pcm_buffer) {
        api->free(mp3_data);
        is_loading = 0;
        load_state = LOAD_STATE_IDLE;
        show_error("Out of memory (song too long)");
        return -1;
    }

    mp3dec_t mp3d;
    mp3dec_init(&mp3d);
    mp3dec_frame_info_t info;
    int16_t temp_pcm[MINIMP3_MAX_SAMPLES_PER_FRAME];

    const uint8_t *ptr = mp3_data;
    int remaining = size;
    int16_t *out_ptr = pcm_buffer;
    uint32_t decoded_samples = 0;
    int channels = 0;

    while (remaining > 0) {
        int samples = mp3dec_decode_frame(&mp3d, ptr, remaining, temp_pcm, &info);
        if (info.frame_bytes == 0) break;
        if (samples > 0) {
            if (channels == 0) {
                channels = info.channels;
                pcm_sample_rate = info.hz;
            }
            decoded_samples += samples;
            if (channels == 1) {
                for (int i = 0; i < samples; i++) {
                    *out_ptr++ = temp_pcm[i];
                    *out_ptr++ = temp_pcm[i];
                }
            } else {
                for (int i = 0; i < samples * 2; i++) {
                    *out_ptr++ = temp_pcm[i];
                }
            }
        }
        ptr += info.frame_bytes;
        remaining -= info.frame_bytes;
    }

    api->free(mp3_data);

    if (decoded_samples == 0 || channels == 0) {
        api->free(pcm_buffer);
        pcm_buffer = NULL;
        is_loading = 0;
        load_state = LOAD_STATE_IDLE;
        show_error("Invalid MP3 format");
        return -1;
    }

    // Use actual decoded sample count for accurate duration
    pcm_samples = decoded_samples;
    playing_track = track_idx;
    is_playing = 1;
    is_loading = 0;
    load_state = LOAD_STATE_IDLE;
    playback_start_tick = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
    pause_elapsed_ms = 0;

    api->sound_play_pcm_async(pcm_buffer, pcm_samples, 2, pcm_sample_rate);

    return 0;
}

static void toggle_play_pause(void) {
    if (playing_track < 0) {
        // Nothing loaded - play selected or first track
        if (selected_track >= 0) {
            play_track(selected_track);
        } else if (track_count > 0) {
            play_track(0);
        }
    } else if (is_playing) {
        // Currently playing - pause it
        if (api->sound_pause) {
            // Save current elapsed time before pausing
            uint32_t now = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
            uint32_t elapsed_ticks = now - playback_start_tick;
            pause_elapsed_ms = elapsed_ticks * 10;  // 100Hz timer
            api->sound_pause();
            is_playing = 0;
        }
    } else {
        // Currently paused - resume
        if (api->sound_resume && api->sound_is_paused && api->sound_is_paused()) {
            // Adjust start tick so progress bar continues from paused position
            uint32_t now = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
            playback_start_tick = now - (pause_elapsed_ms / 10);
            api->sound_resume();
            is_playing = 1;
        } else {
            // Fallback: restart from beginning
            playback_start_tick = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
            pause_elapsed_ms = 0;
            api->sound_play_pcm_async(pcm_buffer, pcm_samples, 2, pcm_sample_rate);
            is_playing = 1;
        }
    }
}

static void next_track(void) {
    if (track_count == 0) return;
    int next = (playing_track >= 0 ? playing_track : selected_track) + 1;
    if (next >= track_count) next = 0;
    play_track(next);
}

static void prev_track(void) {
    if (track_count == 0) return;
    int prev = (playing_track >= 0 ? playing_track : selected_track) - 1;
    if (prev < 0) prev = track_count - 1;
    play_track(prev);
}

// ============ Event Handling ============

static void handle_click(int mx, int my) {
    int ctrl_y = win_h - CONTROLS_H;

    // Click in controls area
    if (my >= ctrl_y) {
        int cx = win_w / 2;
        int btn_y = ctrl_y + 8;

        // Back button
        if (mx >= cx - 90 && mx < cx - 60 && my >= btn_y && my < btn_y + 24) {
            prev_track();
            return;
        }

        // Play/Pause
        if (mx >= cx - 40 && mx < cx + 40 && my >= btn_y && my < btn_y + 24) {
            toggle_play_pause();
            return;
        }

        // Next button
        if (mx >= cx + 60 && mx < cx + 90 && my >= btn_y && my < btn_y + 24) {
            next_track();
            return;
        }

        // Volume bar
        int vol_x = win_w - 80;
        if (mx >= vol_x && mx < vol_x + 70 && my >= ctrl_y + 28 && my < ctrl_y + 38) {
            volume = ((mx - vol_x) * 100) / 70;
            if (volume < 0) volume = 0;
            if (volume > 100) volume = 100;
            return;
        }

        return;
    }

    // Click in sidebar (albums)
    if (mx < SIDEBAR_W) {
        int y = 28;
        int visible_albums = (win_h - CONTROLS_H - 32) / ALBUM_ITEM_H;

        for (int i = album_scroll; i < album_count && i < album_scroll + visible_albums; i++) {
            int item_y = y + (i - album_scroll) * ALBUM_ITEM_H;
            if (my >= item_y && my < item_y + ALBUM_ITEM_H) {
                selected_album = i;
                load_tracks(i);
                return;
            }
        }
        return;
    }

    // Click in track list
    if (selected_album >= 0) {
        int list_y = 28;
        int visible_tracks = (win_h - CONTROLS_H - 32) / TRACK_ITEM_H;

        for (int i = track_scroll; i < track_count && i < track_scroll + visible_tracks; i++) {
            int item_y = list_y + (i - track_scroll) * TRACK_ITEM_H;
            if (my >= item_y && my < item_y + TRACK_ITEM_H) {
                selected_track = i;
                return;
            }
        }
    }
}

static void handle_double_click(int mx, int my) {
    if (mx >= SIDEBAR_W && selected_album >= 0) {
        int list_y = 28;
        int visible_tracks = (win_h - CONTROLS_H - 32) / TRACK_ITEM_H;

        for (int i = track_scroll; i < track_count && i < track_scroll + visible_tracks; i++) {
            int item_y = list_y + (i - track_scroll) * TRACK_ITEM_H;
            if (my >= item_y && my < item_y + TRACK_ITEM_H) {
                play_track(i);
                return;
            }
        }
    }
}

// ============ Main ============

int main(kapi_t *k, int argc, char **argv) {
    (void)argc; (void)argv;
    api = k;

    // Create window
    win_w = 500;
    win_h = 400;
    window_id = api->window_create(150, 80, win_w, win_h, "Music");
    if (window_id < 0) {
        return 1;
    }

    int bw, bh;
    win_buffer = api->window_get_buffer(window_id, &bw, &bh);
    if (!win_buffer) {
        api->window_destroy(window_id);
        return 1;
    }

    gfx_init(&gfx, win_buffer, bw, bh, api->font_data);

    scan_albums();
    draw_all();

    int running = 1;
    int last_click_tick = 0;
    int last_click_x = -1, last_click_y = -1;

    while (running) {
        int event_type, data1, data2, data3;

        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;

                case WIN_EVENT_MOUSE_DOWN: {
                    int mx = data1;
                    int my = data2;

                    uint32_t now = api->get_uptime_ticks ? api->get_uptime_ticks() : 0;
                    if (now - last_click_tick < 30 &&
                        mx >= last_click_x - 5 && mx <= last_click_x + 5 &&
                        my >= last_click_y - 5 && my <= last_click_y + 5) {
                        handle_double_click(mx, my);
                    } else {
                        handle_click(mx, my);
                    }
                    last_click_tick = now;
                    last_click_x = mx;
                    last_click_y = my;
                    break;
                }

                case WIN_EVENT_KEY: {
                    int key = data1;
                    if (key == ' ') {
                        toggle_play_pause();
                    } else if (key == 'n' || key == 'N' || key == 0x103) {
                        next_track();
                    } else if (key == 'p' || key == 'P' || key == 0x102) {
                        prev_track();
                    } else if (key == 0x101) {
                        if (selected_track < track_count - 1) selected_track++;
                    } else if (key == 0x100) {
                        if (selected_track > 0) selected_track--;
                    } else if (key == '\n' || key == '\r') {
                        if (selected_track >= 0) play_track(selected_track);
                    } else if (key == 'q' || key == 'Q') {
                        running = 0;
                    }
                    break;
                }

                case WIN_EVENT_RESIZE: {
                    // Re-fetch buffer with new dimensions
                    int bw, bh;
                    win_buffer = api->window_get_buffer(window_id, &bw, &bh);
                    win_w = bw;
                    win_h = bh;
                    gfx_init(&gfx, win_buffer, bw, bh, api->font_data);
                    break;
                }
            }
        }

        // Check if playback finished
        if (is_playing && api->sound_is_playing && !api->sound_is_playing()) {
            next_track();
        }

        draw_all();
        api->yield();
    }

    if (is_playing) {
        api->sound_stop();
    }
    if (pcm_buffer) {
        api->free(pcm_buffer);
    }
    api->window_destroy(window_id);

    return 0;
}
</file>

<file path="user/bin/play.c">
/*
 * play - Play audio files (WAV, MP3)
 *
 * Usage: play <file.wav|file.mp3>
 */

#include "../lib/vibe.h"

// Disable SIMD - freestanding environment has no arm_neon.h
#define MINIMP3_NO_SIMD
#define MINIMP3_IMPLEMENTATION
#include "../../vendor/minimp3.h"

static kapi_t *api;

// Output helpers that use stdio hooks if available
static void out_putc(char c) {
    if (api->stdio_putc) api->stdio_putc(c);
    else api->putc(c);
}

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

static void out_int(int n) {
    if (n < 0) {
        out_putc('-');
        n = -n;
    }
    if (n == 0) {
        out_putc('0');
        return;
    }
    char buf[12];
    int i = 0;
    while (n > 0) {
        buf[i++] = '0' + (n % 10);
        n /= 10;
    }
    while (i > 0) {
        out_putc(buf[--i]);
    }
}

// WAV file header structure
typedef struct __attribute__((packed)) {
    char riff[4];           // "RIFF"
    uint32_t file_size;     // File size - 8
    char wave[4];           // "WAVE"
    char fmt[4];            // "fmt "
    uint32_t fmt_size;      // Format chunk size (16 for PCM)
    uint16_t audio_format;  // 1 = PCM
    uint16_t channels;      // 1 = mono, 2 = stereo
    uint32_t sample_rate;   // e.g. 44100
    uint32_t byte_rate;     // sample_rate * channels * bits/8
    uint16_t block_align;   // channels * bits/8
    uint16_t bits_per_sample;
} wav_header_t;

// Check if file ends with given suffix
static int ends_with(const char *str, const char *suffix) {
    int str_len = strlen(str);
    int suffix_len = strlen(suffix);
    if (suffix_len > str_len) return 0;
    for (int i = 0; i < suffix_len; i++) {
        char c1 = str[str_len - suffix_len + i];
        char c2 = suffix[i];
        // Case insensitive
        if (c1 >= 'A' && c1 <= 'Z') c1 += 32;
        if (c2 >= 'A' && c2 <= 'Z') c2 += 32;
        if (c1 != c2) return 0;
    }
    return 1;
}

// Play WAV file
static int play_wav(const uint8_t *data, uint32_t size) {
    if (size < sizeof(wav_header_t) + 8) {
        out_puts("Error: File too small for WAV\n");
        return -1;
    }

    const wav_header_t *hdr = (const wav_header_t *)data;

    // Verify RIFF/WAVE header
    if (hdr->riff[0] != 'R' || hdr->riff[1] != 'I' ||
        hdr->riff[2] != 'F' || hdr->riff[3] != 'F') {
        out_puts("Error: Not a RIFF file\n");
        return -1;
    }

    if (hdr->wave[0] != 'W' || hdr->wave[1] != 'A' ||
        hdr->wave[2] != 'V' || hdr->wave[3] != 'E') {
        out_puts("Error: Not a WAVE file\n");
        return -1;
    }

    if (hdr->audio_format != 1) {
        out_puts("Error: Not PCM format (compressed WAV not supported)\n");
        return -1;
    }

    if (hdr->bits_per_sample != 16) {
        out_puts("Error: Only 16-bit audio supported\n");
        return -1;
    }

    // Find data chunk (skip any extra chunks)
    const uint8_t *ptr = data + sizeof(wav_header_t);
    const uint8_t *end = data + size;

    // Skip any extra format bytes
    if (hdr->fmt_size > 16) {
        ptr += (hdr->fmt_size - 16);
    }

    // Find "data" chunk
    while (ptr + 8 < end) {
        if (ptr[0] == 'd' && ptr[1] == 'a' && ptr[2] == 't' && ptr[3] == 'a') {
            break;
        }
        // Skip this chunk
        uint32_t chunk_size = ptr[4] | (ptr[5] << 8) | (ptr[6] << 16) | (ptr[7] << 24);
        ptr += 8 + chunk_size;
    }

    if (ptr + 8 >= end) {
        out_puts("Error: No data chunk found\n");
        return -1;
    }

    uint32_t data_size = ptr[4] | (ptr[5] << 8) | (ptr[6] << 16) | (ptr[7] << 24);
    const int16_t *pcm_data = (const int16_t *)(ptr + 8);
    uint32_t samples = data_size / (hdr->channels * sizeof(int16_t));

    out_puts("WAV: ");
    out_int(hdr->sample_rate);
    out_puts(" Hz, ");
    out_int(hdr->channels);
    out_puts(" ch, ");
    out_int(samples);
    out_puts(" samples\n");

    // WAV data is in the file buffer which stays allocated, so async is safe
    return api->sound_play_pcm_async(pcm_data, samples, hdr->channels, hdr->sample_rate);
}

// Play MP3 file
static int play_mp3(const uint8_t *data, uint32_t size) {
    mp3dec_t mp3d;
    mp3dec_init(&mp3d);

    // First pass: count total samples needed
    mp3dec_frame_info_t info;
    int16_t temp_pcm[MINIMP3_MAX_SAMPLES_PER_FRAME];

    const uint8_t *ptr = data;
    int remaining = size;
    uint32_t total_samples = 0;
    int channels = 0;
    int sample_rate = 0;

    // Scan through to get format info and total size
    while (remaining > 0) {
        int samples = mp3dec_decode_frame(&mp3d, ptr, remaining, temp_pcm, &info);
        if (samples > 0) {
            total_samples += samples;
            if (channels == 0) {
                channels = info.channels;
                sample_rate = info.hz;
            }
        }
        if (info.frame_bytes == 0) break;
        ptr += info.frame_bytes;
        remaining -= info.frame_bytes;
    }

    if (total_samples == 0 || channels == 0) {
        out_puts("Error: Could not decode MP3\n");
        return -1;
    }

    out_puts("MP3: ");
    out_int(sample_rate);
    out_puts(" Hz, ");
    out_int(channels);
    out_puts(" ch, ");
    out_int(total_samples);
    out_puts(" samples, ");
    out_int(info.bitrate_kbps);
    out_puts(" kbps\n");

    // Allocate buffer for all decoded PCM (always stereo for output)
    int16_t *pcm_buf = api->malloc(total_samples * 2 * sizeof(int16_t));
    if (!pcm_buf) {
        out_puts("Error: Out of memory for PCM buffer\n");
        return -1;
    }

    // Second pass: decode all frames
    mp3dec_init(&mp3d);
    ptr = data;
    remaining = size;
    int16_t *out_ptr = pcm_buf;

    out_puts("Decoding...\n");

    while (remaining > 0) {
        int samples = mp3dec_decode_frame(&mp3d, ptr, remaining, temp_pcm, &info);
        if (samples > 0) {
            // Convert to stereo if mono
            if (channels == 1) {
                for (int i = 0; i < samples; i++) {
                    *out_ptr++ = temp_pcm[i];  // Left
                    *out_ptr++ = temp_pcm[i];  // Right (duplicate)
                }
            } else {
                for (int i = 0; i < samples * 2; i++) {
                    *out_ptr++ = temp_pcm[i];
                }
            }
        }
        if (info.frame_bytes == 0) break;
        ptr += info.frame_bytes;
        remaining -= info.frame_bytes;
    }

    out_puts("Playing...\n");

    // Always play as stereo (async - returns immediately)
    // NOTE: pcm_buf must stay allocated while playing!
    int result = api->sound_play_pcm_async(pcm_buf, total_samples, 2, sample_rate);

    if (result < 0) {
        api->free(pcm_buf);
        return result;
    }

    // Don't free pcm_buf - kernel needs it during async playback
    // It will be orphaned but that's OK for now
    return 0;
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    if (argc < 2) {
        out_puts("Usage: play <file.wav|file.mp3>\n");
        return 1;
    }

    const char *filename = argv[1];

    // Check if sound is available
    if (!api->sound_play_pcm) {
        out_puts("Error: Sound not available\n");
        return 1;
    }

    // Open the file
    void *file = api->open(filename);
    if (!file) {
        out_puts("Error: Cannot open ");
        out_puts(filename);
        out_puts("\n");
        return 1;
    }

    if (api->is_dir(file)) {
        out_puts("Error: ");
        out_puts(filename);
        out_puts(" is a directory\n");
        return 1;
    }

    // Get file size
    int size = api->file_size(file);
    if (size <= 0) {
        out_puts("Error: Empty or invalid file\n");
        return 1;
    }

    out_puts("Loading ");
    out_puts(filename);
    out_puts(" (");
    out_int(size);
    out_puts(" bytes)...\n");

    // Allocate buffer
    uint8_t *data = api->malloc(size);
    if (!data) {
        out_puts("Error: Out of memory\n");
        return 1;
    }

    // Read file
    int offset = 0;
    while (offset < size) {
        int n = api->read(file, (char *)data + offset, size - offset, offset);
        if (n <= 0) break;
        offset += n;
    }

    if (offset != size) {
        out_puts("Warning: Only read ");
        out_int(offset);
        out_puts(" bytes\n");
    }

    int result;

    // Detect format and play
    if (ends_with(filename, ".mp3")) {
        result = play_mp3(data, size);
    } else if (ends_with(filename, ".wav")) {
        result = play_wav(data, size);
    } else {
        // Try to detect by magic bytes
        if (size >= 4 && data[0] == 'R' && data[1] == 'I' && data[2] == 'F' && data[3] == 'F') {
            result = play_wav(data, size);
        } else if (size >= 2 && data[0] == 0xFF && (data[1] & 0xE0) == 0xE0) {
            // MP3 frame sync
            result = play_mp3(data, size);
        } else if (size >= 3 && data[0] == 'I' && data[1] == 'D' && data[2] == '3') {
            // ID3 tag - it's an MP3
            result = play_mp3(data, size);
        } else {
            out_puts("Error: Unknown file format\n");
            result = -1;
        }
    }

    // Don't free data - kernel needs it during async playback
    // Memory will be orphaned but that's OK for a CLI tool

    if (result < 0) {
        api->free(data);  // Only free on error
        out_puts("Error: Playback failed\n");
        return 1;
    }

    out_puts("Done!\n");
    return 0;
}
</file>

<file path="user/linker.ld">
/*
 * VibeOS Userspace Linker Script
 *
 * Programs are position-independent (PIE) - they can load anywhere.
 * Base is 0x0, kernel adds actual load address at runtime.
 */

ENTRY(_start)

PHDRS
{
    text PT_LOAD FLAGS(5);  /* R-X */
    dynamic PT_DYNAMIC FLAGS(6);
}

SECTIONS
{
    . = 0x0;  /* Base at 0 - kernel decides actual load address */

    .text : {
        *(.text.start)
        *(.text*)
    } :text

    .rodata : {
        *(.rodata*)
    } :text

    .data : {
        *(.data*)
    } :text

    .got : {
        *(.got)
        *(.got.plt)
    } :text

    .dynamic : {
        *(.dynamic)
    } :text :dynamic

    .bss : {
        *(.bss*)
        *(COMMON)
    } :text

    /DISCARD/ : {
        *(.comment)
        *(.note*)
        *(.eh_frame*)
        *(.ARM.*)
    }
}
</file>

<file path="kernel/virtio_blk.c">
/*
 * VibeOS Virtio Block Driver
 *
 * Implements virtio-blk for block device access on QEMU virt machine.
 * Based on virtio 1.0 spec (modern mode).
 */

#include "virtio_blk.h"
#include "printf.h"
#include "string.h"

// Virtio MMIO registers
#define VIRTIO_MMIO_BASE        0x0a000000
#define VIRTIO_MMIO_STRIDE      0x200

// Virtio MMIO register offsets
#define VIRTIO_MMIO_MAGIC           0x000
#define VIRTIO_MMIO_VERSION         0x004
#define VIRTIO_MMIO_DEVICE_ID       0x008
#define VIRTIO_MMIO_VENDOR_ID       0x00c
#define VIRTIO_MMIO_DEVICE_FEATURES 0x010
#define VIRTIO_MMIO_DEVICE_FEATURES_SEL 0x014
#define VIRTIO_MMIO_DRIVER_FEATURES 0x020
#define VIRTIO_MMIO_DRIVER_FEATURES_SEL 0x024
#define VIRTIO_MMIO_QUEUE_SEL       0x030
#define VIRTIO_MMIO_QUEUE_NUM_MAX   0x034
#define VIRTIO_MMIO_QUEUE_NUM       0x038
#define VIRTIO_MMIO_QUEUE_READY     0x044
#define VIRTIO_MMIO_QUEUE_NOTIFY    0x050
#define VIRTIO_MMIO_INTERRUPT_STATUS 0x060
#define VIRTIO_MMIO_INTERRUPT_ACK   0x064
#define VIRTIO_MMIO_STATUS          0x070
#define VIRTIO_MMIO_QUEUE_DESC_LOW  0x080
#define VIRTIO_MMIO_QUEUE_DESC_HIGH 0x084
#define VIRTIO_MMIO_QUEUE_AVAIL_LOW 0x090
#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH 0x094
#define VIRTIO_MMIO_QUEUE_USED_LOW  0x0a0
#define VIRTIO_MMIO_QUEUE_USED_HIGH 0x0a4
#define VIRTIO_MMIO_CONFIG          0x100

// Virtio status bits
#define VIRTIO_STATUS_ACK         1
#define VIRTIO_STATUS_DRIVER      2
#define VIRTIO_STATUS_DRIVER_OK   4
#define VIRTIO_STATUS_FEATURES_OK 8

// Virtio device types
#define VIRTIO_DEV_BLK  2

// Virtio block request types
#define VIRTIO_BLK_T_IN   0  // Read
#define VIRTIO_BLK_T_OUT  1  // Write

// Virtio block status codes
#define VIRTIO_BLK_S_OK     0
#define VIRTIO_BLK_S_IOERR  1
#define VIRTIO_BLK_S_UNSUPP 2

// Virtqueue structures
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} virtq_desc_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} virtq_avail_t;

typedef struct __attribute__((packed)) {
    uint32_t id;
    uint32_t len;
} virtq_used_elem_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    virtq_used_elem_t ring[];
} virtq_used_t;

// Virtio block request header
typedef struct __attribute__((packed)) {
    uint32_t type;
    uint32_t reserved;
    uint64_t sector;
} virtio_blk_req_t;

// Virtio block config (from device)
typedef struct __attribute__((packed)) {
    uint64_t capacity;  // Number of 512-byte sectors
    uint32_t size_max;
    uint32_t seg_max;
    // ... more fields we don't need
} virtio_blk_config_t;

// Driver state
static volatile uint32_t *blk_base = NULL;
static virtq_desc_t *desc = NULL;
static virtq_avail_t *avail = NULL;
static virtq_used_t *used = NULL;
static uint64_t device_capacity = 0;

#define QUEUE_SIZE 16
#define DESC_F_NEXT  1
#define DESC_F_WRITE 2

// Statically allocated memory for virtqueue (4KB aligned)
static uint8_t queue_mem[4096] __attribute__((aligned(4096)));

// Request header and status buffers
static virtio_blk_req_t req_header __attribute__((aligned(16)));
static uint8_t req_status __attribute__((aligned(16)));

// Memory barriers for device communication
static inline void mb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline uint32_t read32(volatile uint32_t *addr) {
    uint32_t val = *addr;
    mb();
    return val;
}

static inline void write32(volatile uint32_t *addr, uint32_t val) {
    mb();
    *addr = val;
    mb();
}

static volatile uint32_t *find_virtio_blk(void) {
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic == 0x74726976 && device_id == VIRTIO_DEV_BLK) {
            return base;
        }
    }

    return NULL;
}

int virtio_blk_init(void) {
    blk_base = find_virtio_blk();
    if (!blk_base) {
        printf("[BLK] No device found\n");
        return -1;
    }

    // Reset device
    write32(blk_base + VIRTIO_MMIO_STATUS/4, 0);
    while (read32(blk_base + VIRTIO_MMIO_STATUS/4) != 0) {
        asm volatile("nop");
    }

    // Acknowledge and set driver
    write32(blk_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK);
    write32(blk_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER);

    // Accept no special features
    write32(blk_base + VIRTIO_MMIO_DEVICE_FEATURES_SEL/4, 0);
    write32(blk_base + VIRTIO_MMIO_DRIVER_FEATURES_SEL/4, 0);
    write32(blk_base + VIRTIO_MMIO_DRIVER_FEATURES/4, 0);
    write32(blk_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK);

    uint32_t status = read32(blk_base + VIRTIO_MMIO_STATUS/4);
    if (!(status & VIRTIO_STATUS_FEATURES_OK)) {
        printf("[BLK] Feature negotiation failed\n");
        return -1;
    }

    // Read device capacity
    volatile uint8_t *config = (volatile uint8_t *)blk_base + VIRTIO_MMIO_CONFIG;
    device_capacity = *(volatile uint64_t *)config;

    // Setup virtqueue 0
    write32(blk_base + VIRTIO_MMIO_QUEUE_SEL/4, 0);
    uint32_t max_queue = read32(blk_base + VIRTIO_MMIO_QUEUE_NUM_MAX/4);
    if (max_queue < QUEUE_SIZE) {
        printf("[BLK] Queue too small\n");
        return -1;
    }

    write32(blk_base + VIRTIO_MMIO_QUEUE_NUM/4, QUEUE_SIZE);

    // Setup queue memory
    desc = (virtq_desc_t *)queue_mem;
    avail = (virtq_avail_t *)(queue_mem + QUEUE_SIZE * sizeof(virtq_desc_t));
    used = (virtq_used_t *)(queue_mem + 2048);

    uint64_t desc_addr = (uint64_t)desc;
    uint64_t avail_addr = (uint64_t)avail;
    uint64_t used_addr = (uint64_t)used;

    write32(blk_base + VIRTIO_MMIO_QUEUE_DESC_LOW/4, (uint32_t)desc_addr);
    write32(blk_base + VIRTIO_MMIO_QUEUE_DESC_HIGH/4, (uint32_t)(desc_addr >> 32));
    write32(blk_base + VIRTIO_MMIO_QUEUE_AVAIL_LOW/4, (uint32_t)avail_addr);
    write32(blk_base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH/4, (uint32_t)(avail_addr >> 32));
    write32(blk_base + VIRTIO_MMIO_QUEUE_USED_LOW/4, (uint32_t)used_addr);
    write32(blk_base + VIRTIO_MMIO_QUEUE_USED_HIGH/4, (uint32_t)(used_addr >> 32));

    avail->flags = 0;
    avail->idx = 0;

    write32(blk_base + VIRTIO_MMIO_QUEUE_READY/4, 1);
    write32(blk_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK | VIRTIO_STATUS_DRIVER_OK);

    status = read32(blk_base + VIRTIO_MMIO_STATUS/4);
    if (status & 0x40) {
        printf("[BLK] Device failure\n");
        return -1;
    }

    printf("[BLK] Ready (%d MB)\n", (uint32_t)(device_capacity / 2048));
    return 0;
}

// Perform a block request (read or write)
static int do_request(uint32_t type, uint64_t sector, uint32_t count, void *buf) {
    if (!blk_base) return -1;
    if (sector + count > device_capacity) return -1;

    // Setup request header
    req_header.type = type;
    req_header.reserved = 0;
    req_header.sector = sector;

    // Clear status
    req_status = 0xff;

    // Setup descriptor chain:
    // desc[0]: request header (device reads)
    // desc[1]: data buffer (device reads or writes depending on request type)
    // desc[2]: status byte (device writes)

    desc[0].addr = (uint64_t)&req_header;
    desc[0].len = sizeof(virtio_blk_req_t);
    desc[0].flags = DESC_F_NEXT;
    desc[0].next = 1;

    desc[1].addr = (uint64_t)buf;
    desc[1].len = count * 512;
    desc[1].flags = DESC_F_NEXT | (type == VIRTIO_BLK_T_IN ? DESC_F_WRITE : 0);
    desc[1].next = 2;

    desc[2].addr = (uint64_t)&req_status;
    desc[2].len = 1;
    desc[2].flags = DESC_F_WRITE;
    desc[2].next = 0;

    // Add to available ring
    mb();
    uint16_t old_used_idx = used->idx;
    uint16_t avail_slot = avail->idx % QUEUE_SIZE;
    avail->ring[avail_slot] = 0;  // First descriptor in chain
    mb();
    avail->idx++;
    mb();

    // Notify device
    write32(blk_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    // Poll for completion - wait for used->idx to change
    int timeout = 10000000;
    while (used->idx == old_used_idx && timeout > 0) {
        mb();
        timeout--;
    }

    if (timeout == 0) {
        printf("[BLK] Request timed out!\n");
        return -1;
    }

    // Ack interrupt
    write32(blk_base + VIRTIO_MMIO_INTERRUPT_ACK/4, read32(blk_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));

    // Check status
    if (req_status != VIRTIO_BLK_S_OK) {
        printf("[BLK] Request failed with status %d\n", req_status);
        return -1;
    }

    return 0;
}

int virtio_blk_read(uint64_t sector, uint32_t count, void *buf) {
    return do_request(VIRTIO_BLK_T_IN, sector, count, buf);
}

int virtio_blk_write(uint64_t sector, uint32_t count, const void *buf) {
    return do_request(VIRTIO_BLK_T_OUT, sector, count, (void *)buf);
}

uint64_t virtio_blk_get_capacity(void) {
    return device_capacity;
}
</file>

<file path="user/bin/snake.c">
/*
 * VibeOS Snake Game (Userspace)
 *
 * Classic snake game for the terminal.
 * Controls: WASD to move, Q to quit
 */

#include "vibe.h"

// Game board dimensions
#define BOARD_WIDTH  40
#define BOARD_HEIGHT 20
#define BOARD_X      10
#define BOARD_Y      2

// Maximum snake length
#define MAX_SNAKE_LEN 256

// Directions
#define DIR_UP    0
#define DIR_DOWN  1
#define DIR_LEFT  2
#define DIR_RIGHT 3

// Point structure
typedef struct {
    int x;
    int y;
} point_t;

// Game state
static kapi_t *api;
static point_t snake[MAX_SNAKE_LEN];
static int snake_len;
static int direction;
static int next_direction;
static point_t food;
static int score;
static int game_over;
static int high_score = 0;

// Random number generator
static uint32_t rand_state = 12345;

static uint32_t rand(void) {
    rand_state = rand_state * 1103515245 + 12345;
    return (rand_state >> 16) & 0x7FFF;
}

// Game speed delay in milliseconds
#define SNAKE_DELAY_MS 100

// Draw the border
static void draw_border(void) {
    api->set_color(COLOR_WHITE, COLOR_BLACK);

    // Top border
    api->set_cursor(BOARD_Y - 1, BOARD_X - 1);
    api->putc('+');
    for (int x = 0; x < BOARD_WIDTH; x++) {
        api->putc('-');
    }
    api->putc('+');

    // Side borders
    for (int y = 0; y < BOARD_HEIGHT; y++) {
        api->set_cursor(BOARD_Y + y, BOARD_X - 1);
        api->putc('|');
        api->set_cursor(BOARD_Y + y, BOARD_X + BOARD_WIDTH);
        api->putc('|');
    }

    // Bottom border
    api->set_cursor(BOARD_Y + BOARD_HEIGHT, BOARD_X - 1);
    api->putc('+');
    for (int x = 0; x < BOARD_WIDTH; x++) {
        api->putc('-');
    }
    api->putc('+');
}

// Draw the score
static void draw_score(void) {
    api->set_cursor(0, 0);
    api->set_color(COLOR_AMBER, COLOR_BLACK);
    api->puts("SNAKE");
    api->set_color(COLOR_WHITE, COLOR_BLACK);
    api->puts("  Score: ");
    api->print_int(score);
    api->puts("  High: ");
    api->print_int(high_score);
    api->puts("  [Q]uit");
    // Clear rest of line
    for (int i = 0; i < 20; i++) api->putc(' ');
}

// Place food at a random location
static void place_food(void) {
    int valid;
    do {
        valid = 1;
        food.x = rand() % BOARD_WIDTH;
        food.y = rand() % BOARD_HEIGHT;

        for (int i = 0; i < snake_len; i++) {
            if (snake[i].x == food.x && snake[i].y == food.y) {
                valid = 0;
                break;
            }
        }
    } while (!valid);
}

// Draw a cell
static void draw_cell(int x, int y, char c, uint32_t color) {
    api->set_cursor(BOARD_Y + y, BOARD_X + x);
    api->set_color(color, COLOR_BLACK);
    api->putc(c);
}

// Clear a cell
static void clear_cell(int x, int y) {
    api->set_cursor(BOARD_Y + y, BOARD_X + x);
    api->set_color(COLOR_BLACK, COLOR_BLACK);
    api->putc(' ');
}

// Draw the snake
static void draw_snake(void) {
    draw_cell(snake[0].x, snake[0].y, '@', COLOR_GREEN);
    for (int i = 1; i < snake_len; i++) {
        draw_cell(snake[i].x, snake[i].y, 'o', COLOR_GREEN);
    }
}

// Draw food
static void draw_food(void) {
    draw_cell(food.x, food.y, '*', COLOR_RED);
}

// Initialize the game
static void init_game(void) {
    api->clear();

    snake_len = 3;
    snake[0].x = BOARD_WIDTH / 2;
    snake[0].y = BOARD_HEIGHT / 2;
    snake[1].x = snake[0].x - 1;
    snake[1].y = snake[0].y;
    snake[2].x = snake[0].x - 2;
    snake[2].y = snake[0].y;

    direction = DIR_RIGHT;
    next_direction = DIR_RIGHT;
    score = 0;
    game_over = 0;

    rand_state = rand_state + snake[0].x * 31337;

    place_food();

    draw_border();
    draw_score();
    draw_snake();
    draw_food();
}

// Check for collision
static int check_collision(int x, int y) {
    if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT) {
        return 1;
    }
    for (int i = 1; i < snake_len; i++) {
        if (snake[i].x == x && snake[i].y == y) {
            return 1;
        }
    }
    return 0;
}

// Update game state
static void update_game(void) {
    direction = next_direction;

    point_t new_head = snake[0];
    switch (direction) {
        case DIR_UP:    new_head.y--; break;
        case DIR_DOWN:  new_head.y++; break;
        case DIR_LEFT:  new_head.x--; break;
        case DIR_RIGHT: new_head.x++; break;
    }

    if (check_collision(new_head.x, new_head.y)) {
        game_over = 1;
        return;
    }

    int ate_food = (new_head.x == food.x && new_head.y == food.y);

    if (!ate_food) {
        clear_cell(snake[snake_len - 1].x, snake[snake_len - 1].y);
    }

    if (ate_food && snake_len < MAX_SNAKE_LEN) {
        snake_len++;
    }
    for (int i = snake_len - 1; i > 0; i--) {
        snake[i] = snake[i - 1];
    }
    snake[0] = new_head;

    if (snake_len > 1) {
        draw_cell(snake[1].x, snake[1].y, 'o', COLOR_GREEN);
    }
    draw_cell(snake[0].x, snake[0].y, '@', COLOR_GREEN);

    if (ate_food) {
        score += 10;
        if (score > high_score) {
            high_score = score;
        }
        draw_score();
        place_food();
        draw_food();
    }
}

// Process input
static int process_input(void) {
    while (api->has_key()) {
        int c = api->getc();

        switch (c) {
            case 'q':
            case 'Q':
                return -1;

            case 'w':
            case 'W':
                if (direction != DIR_DOWN) next_direction = DIR_UP;
                break;
            case 's':
            case 'S':
                if (direction != DIR_UP) next_direction = DIR_DOWN;
                break;
            case 'a':
            case 'A':
                if (direction != DIR_RIGHT) next_direction = DIR_LEFT;
                break;
            case 'd':
            case 'D':
                if (direction != DIR_LEFT) next_direction = DIR_RIGHT;
                break;
        }
    }
    return 0;
}

// Show game over
static void show_game_over(void) {
    int center_y = BOARD_Y + BOARD_HEIGHT / 2;
    int center_x = BOARD_X + BOARD_WIDTH / 2 - 5;

    api->set_cursor(center_y - 1, center_x - 2);
    api->set_color(COLOR_RED, COLOR_BLACK);
    api->puts("  GAME OVER!  ");

    api->set_cursor(center_y + 1, center_x - 2);
    api->set_color(COLOR_WHITE, COLOR_BLACK);
    api->puts("  Score: ");
    api->print_int(score);
    api->puts("  ");

    api->set_cursor(center_y + 3, center_x - 4);
    api->set_color(COLOR_AMBER, COLOR_BLACK);
    api->puts("[R]estart  [Q]uit");
    api->set_color(COLOR_WHITE, COLOR_BLACK);
}

// Wait for restart or quit
static int wait_for_restart(void) {
    while (1) {
        if (api->has_key()) {
            int c = api->getc();
            if (c == 'r' || c == 'R') {
                return 1;
            }
            if (c == 'q' || c == 'Q') {
                return 0;
            }
        }
        api->sleep_ms(10);
    }
}

// Main entry point
int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    init_game();

    while (1) {
        if (process_input() < 0) {
            break;
        }

        update_game();

        if (game_over) {
            show_game_over();
            if (wait_for_restart()) {
                init_game();
                continue;
            } else {
                break;
            }
        }

        // Game tick - sleep controls game speed
        api->sleep_ms(SNAKE_DELAY_MS);
    }

    api->clear();
    api->set_color(COLOR_WHITE, COLOR_BLACK);

    return score;
}
</file>

<file path="user/lib/icons.h">
/*
 * VibeOS Icon Bitmaps
 *
 * 32x32 dock icons and 16x16 logo for GUI apps.
 * All bitmaps are 1-bit: 0 = transparent/white, 1 = black
 */

#ifndef ICONS_H
#define ICONS_H

// ============ VibeOS Logo (16x16 bitmap) ============
// A stylized "V" with a wave/vibe feel
static const unsigned char vibeos_logo[16 * 16] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,
    0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,
    0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,
    0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,
    0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// ============ Dock Icons (32x32 bitmaps) ============

// Snake icon - coiled snake
static const unsigned char icon_snake[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Tetris icon - falling blocks
static const unsigned char icon_tetris[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Calculator icon - cute retro calc
static const unsigned char icon_calc[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Files/Folder icon - classic Mac folder
static const unsigned char icon_files[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Terminal icon - classic CRT monitor with >_ prompt
static const unsigned char icon_term[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Music icon - musical note
static const unsigned char icon_music[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// System Monitor icon - bar chart / activity monitor
static const unsigned char icon_sysmon[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
    0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Browser icon - globe/world
static const unsigned char icon_browser[32 * 32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,
    0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
    0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
    0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
    0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
    0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
    0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

// Array of icon bitmap pointers for easy indexing
// Order must match dock_icons[] in desktop.c!
static const unsigned char *icon_bitmaps[] = {
    icon_snake,    // 0 - Snake
    icon_tetris,   // 1 - Tetris
    icon_calc,     // 2 - Calc
    icon_files,    // 3 - Files
    icon_music,    // 4 - Music
    icon_browser,  // 5 - Browser
    icon_term,     // 6 - Term
    icon_sysmon,   // 7 - SysMon
};

#define ICON_SNAKE   0
#define ICON_TETRIS  1
#define ICON_CALC    2
#define ICON_FILES   3
#define ICON_MUSIC   4
#define ICON_BROWSER 5
#define ICON_TERM    6
#define ICON_SYSMON  7

#endif // ICONS_H
</file>

<file path="kernel/fat32.h">
/*
 * VibeOS FAT32 Filesystem Driver
 *
 * Read/write FAT32 implementation for persistent storage.
 */

#ifndef FAT32_H
#define FAT32_H

#include <stdint.h>
#include <stddef.h>

// FAT32 directory entry attributes
#define FAT_ATTR_READ_ONLY  0x01
#define FAT_ATTR_HIDDEN     0x02
#define FAT_ATTR_SYSTEM     0x04
#define FAT_ATTR_VOLUME_ID  0x08
#define FAT_ATTR_DIRECTORY  0x10
#define FAT_ATTR_ARCHIVE    0x20
#define FAT_ATTR_LFN        0x0F  // Long filename entry

// Special cluster values
#define FAT32_EOC           0x0FFFFFF8  // End of cluster chain (>= this value)
#define FAT32_FREE          0x00000000
#define FAT32_BAD           0x0FFFFFF7

// FAT32 directory entry (32 bytes)
typedef struct __attribute__((packed)) {
    char name[11];          // 8.3 filename (space-padded)
    uint8_t attr;           // File attributes
    uint8_t nt_reserved;    // Reserved for Windows NT
    uint8_t create_time_tenth;
    uint16_t create_time;
    uint16_t create_date;
    uint16_t access_date;
    uint16_t cluster_hi;    // High 16 bits of first cluster
    uint16_t modify_time;
    uint16_t modify_date;
    uint16_t cluster_lo;    // Low 16 bits of first cluster
    uint32_t size;          // File size in bytes
} fat32_dirent_t;

// FAT32 long filename entry (32 bytes)
typedef struct __attribute__((packed)) {
    uint8_t order;          // Sequence number
    uint16_t name1[5];      // Characters 1-5
    uint8_t attr;           // Always 0x0F
    uint8_t type;           // Always 0
    uint8_t checksum;       // Checksum of short name
    uint16_t name2[6];      // Characters 6-11
    uint16_t cluster;       // Always 0
    uint16_t name3[2];      // Characters 12-13
} fat32_lfn_t;

// FAT32 filesystem info
typedef struct {
    uint32_t sectors_per_cluster;
    uint32_t bytes_per_sector;
    uint32_t reserved_sectors;
    uint32_t num_fats;
    uint32_t fat_size;          // Sectors per FAT
    uint32_t root_cluster;      // First cluster of root directory
    uint32_t data_start;        // First data sector
    uint32_t total_clusters;
} fat32_fs_t;

// Initialize FAT32 filesystem (reads from virtio-blk)
int fat32_init(void);

// Read a file's contents into buffer
// path: absolute path like "/bin/hello.elf"
// buf: buffer to read into
// size: max bytes to read
// Returns: bytes read, or -1 on error
int fat32_read_file(const char *path, void *buf, size_t size);

// Get file size
// Returns: file size in bytes, or -1 on error
int fat32_file_size(const char *path);

// Check if path is a directory
// Returns: 1 if directory, 0 if file, -1 if not found
int fat32_is_dir(const char *path);

// List directory contents
// path: directory path
// callback: called for each entry with (name, is_dir, size, user_data)
// Returns: 0 on success, -1 on error
typedef void (*fat32_dir_callback)(const char *name, int is_dir, uint32_t size, void *user_data);
int fat32_list_dir(const char *path, fat32_dir_callback callback, void *user_data);

// Get filesystem info
fat32_fs_t *fat32_get_fs_info(void);

// Write operations (new!)
// Create an empty file
// Returns 0 on success, -1 on error
int fat32_create_file(const char *path);

// Create a directory
// Returns 0 on success, -1 on error
int fat32_mkdir(const char *path);

// Write data to a file (creates if not exists, overwrites if exists)
// Returns bytes written, or -1 on error
int fat32_write_file(const char *path, const void *buf, size_t size);

// Delete a file (not directories)
// Returns 0 on success, -1 on error
int fat32_delete(const char *path);

// Delete an empty directory
// Returns 0 on success, -1 on error (including if not empty)
int fat32_delete_dir(const char *path);

// Delete a file or directory recursively
// Returns 0 on success, -1 on error
int fat32_delete_recursive(const char *path);

// Rename a file or directory (same directory only)
// oldpath: full path to existing file/dir
// newname: new filename (just the name, not full path)
// Returns 0 on success, -1 on error
int fat32_rename(const char *oldpath, const char *newname);

// Get disk space stats
// Returns total disk space in KB
int fat32_get_total_kb(void);

// Returns free disk space in KB (counts free clusters)
int fat32_get_free_kb(void);

#endif
</file>

<file path="kernel/memory.c">
/*
 * VibeOS Memory Management
 *
 * Simple first-fit heap allocator. Not the fastest, but easy to understand.
 * Each allocation has a header with size and free flag.
 *
 * RAM is detected at runtime by parsing the Device Tree Blob (DTB).
 */

#include "memory.h"
#include "dtb.h"
#include "printf.h"

// Detected RAM info (populated by memory_init)
uint64_t ram_base;
uint64_t ram_size;

// Heap bounds
uint64_t heap_start;
uint64_t heap_end;

// Block header - sits before each allocation
typedef struct block_header {
    size_t size;                    // Size of data area (not including header)
    uint8_t is_free;                // 1 if block is free, 0 if allocated
    struct block_header *next;      // Next block in list
} block_header_t;

#define HEADER_SIZE sizeof(block_header_t)
#define ALIGN_UP(x, align) (((x) + ((align) - 1)) & ~((align) - 1))

static block_header_t *free_list = NULL;

// Defined in linker script - end of BSS in RAM
extern uint64_t _bss_end;

// Stack location (must match boot.S!)
#define KERNEL_STACK_TOP 0x5F000000

// Leave some room below stack for safety (1MB)
#define STACK_BUFFER (1 * 1024 * 1024)

void memory_init(void) {
    // Parse DTB to get RAM info
    struct dtb_memory_info mem_info;
    if (dtb_parse((void *)DTB_ADDR, &mem_info) != 0) {
        // Fallback to safe defaults if DTB parsing fails
        printf("[MEM] WARNING: DTB parse failed, using defaults\n");
        ram_base = 0x40000000;
        ram_size = 256 * 1024 * 1024;  // 256MB
    } else {
        ram_base = mem_info.base;
        ram_size = mem_info.size;
    }

    printf("[MEM] RAM: base=0x%lx, size=%lu MB\n", ram_base, ram_size / (1024 * 1024));

    // Heap starts after BSS, aligned to 16 bytes
    // Add 64KB buffer after BSS for safety
    heap_start = ALIGN_UP((uint64_t)&_bss_end + 0x10000, 16);

    // Heap ends before the stack (with buffer)
    // Stack is at fixed address, so heap must stay below it
    uint64_t ram_end = ram_base + ram_size;
    uint64_t heap_max = KERNEL_STACK_TOP - STACK_BUFFER;

    // But also can't exceed actual RAM
    if (heap_max > ram_end) {
        heap_max = ram_end - STACK_BUFFER;
    }

    heap_end = heap_max;

    // Initialize with one giant free block
    free_list = (block_header_t *)heap_start;
    free_list->size = heap_end - heap_start - HEADER_SIZE;
    free_list->is_free = 1;
    free_list->next = NULL;

    printf("[MEM] Heap: 0x%lx - 0x%lx (%lu MB)\n",
           heap_start, heap_end, (heap_end - heap_start) / (1024 * 1024));
}

void *malloc(size_t size) {
    if (size == 0) return NULL;

    // Align size to 16 bytes
    size = ALIGN_UP(size, 16);

    block_header_t *current = free_list;

    // First-fit: find first block that's big enough
    while (current != NULL) {
        if (current->is_free && current->size >= size) {
            // Found a suitable block

            // Split if there's enough room for another block
            if (current->size >= size + HEADER_SIZE + 16) {
                // Create new block after this allocation
                block_header_t *new_block = (block_header_t *)((uint8_t *)current + HEADER_SIZE + size);
                new_block->size = current->size - size - HEADER_SIZE;
                new_block->is_free = 1;
                new_block->next = current->next;

                current->size = size;
                current->next = new_block;
            }

            current->is_free = 0;
            return (void *)((uint8_t *)current + HEADER_SIZE);
        }
        current = current->next;
    }

    // No suitable block found
    return NULL;
}

void free(void *ptr) {
    if (ptr == NULL) return;

    // Get header
    block_header_t *block = (block_header_t *)((uint8_t *)ptr - HEADER_SIZE);
    block->is_free = 1;

    // Coalesce adjacent free blocks
    block_header_t *current = free_list;
    while (current != NULL) {
        if (current->is_free && current->next != NULL && current->next->is_free) {
            // Merge with next block
            current->size += HEADER_SIZE + current->next->size;
            current->next = current->next->next;
            // Don't advance - check if we can merge again
        } else {
            current = current->next;
        }
    }
}

void *calloc(size_t nmemb, size_t size) {
    size_t total = nmemb * size;
    void *ptr = malloc(total);
    if (ptr != NULL) {
        // Zero the memory
        uint8_t *p = (uint8_t *)ptr;
        for (size_t i = 0; i < total; i++) {
            p[i] = 0;
        }
    }
    return ptr;
}

void *realloc(void *ptr, size_t size) {
    if (ptr == NULL) return malloc(size);
    if (size == 0) {
        free(ptr);
        return NULL;
    }

    block_header_t *block = (block_header_t *)((uint8_t *)ptr - HEADER_SIZE);

    // If current block is big enough, just return it
    if (block->size >= size) {
        return ptr;
    }

    // Otherwise allocate new block and copy
    void *new_ptr = malloc(size);
    if (new_ptr != NULL) {
        uint8_t *src = (uint8_t *)ptr;
        uint8_t *dst = (uint8_t *)new_ptr;
        for (size_t i = 0; i < block->size; i++) {
            dst[i] = src[i];
        }
        free(ptr);
    }
    return new_ptr;
}

size_t memory_used(void) {
    size_t used = 0;
    block_header_t *current = free_list;
    while (current != NULL) {
        if (!current->is_free) {
            used += current->size + HEADER_SIZE;
        }
        current = current->next;
    }
    return used;
}

size_t memory_free(void) {
    size_t free_mem = 0;
    block_header_t *current = free_list;
    while (current != NULL) {
        if (current->is_free) {
            free_mem += current->size;
        }
        current = current->next;
    }
    return free_mem;
}
</file>

<file path="kernel/process.h">
/*
 * VibeOS Process Management
 *
 * Cooperative multitasking - programs call yield() voluntarily.
 * Classic Mac OS / Windows 3.1 style.
 */

#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>
#include <stddef.h>

#define PROCESS_NAME_MAX 32
#define PROCESS_STACK_SIZE 0x10000  // 64KB per process
#define MAX_PROCESSES 16

// Process states
typedef enum {
    PROC_STATE_FREE = 0,     // Slot available
    PROC_STATE_READY,        // Ready to run
    PROC_STATE_RUNNING,      // Currently executing
    PROC_STATE_BLOCKED,      // Waiting for something
    PROC_STATE_ZOMBIE        // Exited, waiting to be cleaned up
} proc_state_t;

// Saved CPU context for context switching
typedef struct {
    // General purpose callee-saved registers
    uint64_t x19, x20, x21, x22, x23, x24, x25, x26, x27, x28;
    uint64_t x29;  // Frame pointer
    uint64_t x30;  // Link register (return address)
    uint64_t sp;   // Stack pointer
    // FPU state
    uint64_t fpcr;
    uint64_t fpsr;
    uint64_t _pad;  // Padding to align fp_regs to 16 bytes (offset 0x80)
    uint64_t fp_regs[64];  // q0-q31 (each 128-bit = 2 x 64-bit)
} __attribute__((aligned(16))) cpu_context_t;

typedef struct process {
    int pid;
    char name[PROCESS_NAME_MAX];
    proc_state_t state;

    // Memory
    uint64_t load_base;       // Where program code is loaded
    uint64_t load_size;       // Size of loaded code
    void *stack_base;         // Stack allocation base
    uint64_t stack_size;      // Stack size

    // Execution
    uint64_t entry;           // Entry point
    cpu_context_t context;    // Saved registers for context switch

    // Exit
    int exit_status;
    int parent_pid;           // Who spawned us
} process_t;

// Initialize process subsystem
void process_init(void);

// Create a new process from ELF path (does NOT start it yet)
int process_create(const char *path, int argc, char **argv);

// Start a created process (makes it ready to run)
int process_start(int pid);

// Execute and wait (old behavior - run to completion)
int process_exec(const char *path);
int process_exec_args(const char *path, int argc, char **argv);

// Exit current process
void process_exit(int status);

// Get current/specific process
process_t *process_current(void);
process_t *process_get(int pid);

// Scheduling
void process_yield(void);              // Give up CPU voluntarily
void process_schedule(void);           // Pick next process to run
void process_schedule_from_irq(void);  // Called from timer IRQ for preemption
int process_count_ready(void);         // Count runnable processes

// Context switch (implemented in assembly)
void context_switch(cpu_context_t *old_ctx, cpu_context_t *new_ctx);

// Get info about process by index (for sysmon)
// Returns 1 if slot is active, 0 if free
int process_get_info(int index, char *name, int name_size, int *state);

#endif
</file>

<file path="user/bin/files.c">
/*
 * VibeOS File Explorer
 *
 * A windowed file browser with right-click context menu.
 * Features: navigate dirs, create/rename/delete files and folders,
 * open with TextEdit, open terminal here.
 */

#include "../lib/vibe.h"
#include "../lib/gfx.h"

// Window dimensions
#define WIN_WIDTH  400
#define WIN_HEIGHT 350

// UI constants
#define PATH_BAR_HEIGHT 24
#define ITEM_HEIGHT     18
#define SCROLL_WIDTH    16
#define MAX_ITEMS       64
#define MAX_VISIBLE     ((WIN_HEIGHT - PATH_BAR_HEIGHT - 4) / ITEM_HEIGHT)

// Colors (1-bit style with some grays)
#define COLOR_BG        0x00FFFFFF
#define COLOR_FG        0x00000000
#define COLOR_SELECTED  0x00000000
#define COLOR_SEL_TEXT  0x00FFFFFF
#define COLOR_PATH_BG   0x00EEEEEE
#define COLOR_MENU_BG   0x00FFFFFF
#define COLOR_MENU_HL   0x00000000
#define COLOR_FOLDER    0x00FFCC00

// Context menu
#define MENU_ITEM_HEIGHT 18
#define MENU_WIDTH       140

typedef struct {
    char name[64];
    uint8_t is_dir;
} file_entry_t;

// Global state
static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;
static gfx_ctx_t gfx;

// File list
static file_entry_t items[MAX_ITEMS];
static int item_count = 0;
static int selected_idx = -1;
static int scroll_offset = 0;

// Current path
static char current_path[256];

// Context menu state
static int menu_visible = 0;
static int menu_x, menu_y;
static int menu_hover = -1;

// Rename/create state
static int renaming = 0;
static char rename_buf[64];
static int rename_cursor = 0;
static int creating_new = 0;      // 0 = renaming, 1 = new file, 2 = new folder
static int creating_idx = -1;     // Index of the fake "new" item in list

// Context menu items
static const char *menu_items[] = {
    "New File",
    "New Folder",
    "Rename",
    "Delete",
    "Open with TextEdit",
    "Open Terminal Here"
};
#define MENU_ITEM_COUNT 6

// ============ Drawing Helpers (macros wrapping gfx lib) ============

#define buf_fill_rect(x, y, w, h, c)          gfx_fill_rect(&gfx, x, y, w, h, c)
#define buf_draw_char(x, y, ch, fg, bg)       gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define buf_draw_string(x, y, s, fg, bg)      gfx_draw_string(&gfx, x, y, s, fg, bg)
#define buf_draw_string_clip(x, y, s, fg, bg, max_w) gfx_draw_string_clip(&gfx, x, y, s, fg, bg, max_w)
#define buf_draw_rect(x, y, w, h, c)          gfx_draw_rect(&gfx, x, y, w, h, c)

// Draw folder icon (small, 12x10)
static void draw_folder_icon(int x, int y, uint32_t bg) {
    // Folder tab
    buf_fill_rect(x, y, 5, 2, COLOR_FOLDER);
    // Folder body
    buf_fill_rect(x, y + 2, 12, 8, COLOR_FOLDER);
    // Border
    buf_draw_rect(x, y + 2, 12, 8, COLOR_FG);
}

// Draw file icon (small, 10x12)
static void draw_file_icon(int x, int y, uint32_t bg) {
    buf_fill_rect(x, y, 10, 12, COLOR_BG);
    buf_draw_rect(x, y, 10, 12, COLOR_FG);
    // Corner fold
    for (int i = 0; i < 3; i++) {
        if (x + 7 + i < win_w && y + i < win_h)
            win_buffer[(y + i) * win_w + x + 7 + i] = COLOR_FG;
    }
}

// ============ Recursive Delete (userspace implementation) ============

static int delete_recursive(const char *path) {
    // First try deleting as a file
    if (api->delete(path) == 0) {
        return 0;
    }

    // Try deleting as an empty directory
    if (api->delete_dir(path) == 0) {
        return 0;
    }

    // If that failed, it might be a non-empty directory
    // Open directory and iterate
    void *dir = api->open(path);
    if (!dir) {
        return -1;
    }

    char name[256];
    uint8_t type;
    char child_path[512];
    int idx = 0;

    // Collect all names first, then delete
    // (Can't delete while iterating - shifts indices)
    char all_names[4096];
    int name_offsets[128];
    int name_count = 0;
    int buf_pos = 0;

    while (api->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        idx++;

        // Skip . and ..
        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
            continue;
        }

        // Store name
        if (name_count < 128 && buf_pos + (int)strlen(name) + 1 < 4096) {
            name_offsets[name_count++] = buf_pos;
            strcpy(all_names + buf_pos, name);
            buf_pos += strlen(name) + 1;
        }
    }

    // Now delete all collected entries
    for (int i = 0; i < name_count; i++) {
        // Build child path
        strcpy(child_path, path);
        int plen = strlen(child_path);
        if (plen > 0 && child_path[plen - 1] != '/') {
            child_path[plen] = '/';
            child_path[plen + 1] = '\0';
        }
        int clen = strlen(child_path);
        strcpy(child_path + clen, all_names + name_offsets[i]);

        // Recursively delete child
        delete_recursive(child_path);
    }

    // Now directory should be empty, delete it as directory
    return api->delete_dir(path);
}

// ============ File Operations ============

static void refresh_directory(void) {
    item_count = 0;
    selected_idx = -1;

    void *dir = api->open(current_path);
    if (!dir || !api->is_dir(dir)) {
        return;
    }

    // Add ".." if not at root
    if (strcmp(current_path, "/") != 0) {
        strcpy(items[item_count].name, "..");
        items[item_count].is_dir = 1;
        item_count++;
    }

    // Read directory entries
    char name[64];
    uint8_t type;
    int idx = 0;

    while (item_count < MAX_ITEMS && api->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        // Skip . and ..
        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
            idx++;
            continue;
        }

        strcpy(items[item_count].name, name);
        items[item_count].is_dir = (type == 2);  // VFS_DIRECTORY = 2
        item_count++;
        idx++;
    }

    scroll_offset = 0;
}

static void navigate_to(const char *path) {
    strncpy_safe(current_path, path, sizeof(current_path));
    refresh_directory();
}

static void navigate_up(void) {
    if (strcmp(current_path, "/") == 0) return;

    // Find last slash
    char *last_slash = current_path;
    for (char *p = current_path; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    if (last_slash == current_path) {
        // Go to root
        current_path[1] = '\0';
    } else {
        *last_slash = '\0';
    }

    refresh_directory();
}

static void enter_selected(void) {
    if (selected_idx < 0 || selected_idx >= item_count) return;

    file_entry_t *item = &items[selected_idx];

    if (strcmp(item->name, "..") == 0) {
        navigate_up();
        return;
    }

    if (item->is_dir) {
        // Enter directory
        char new_path[256];
        if (strcmp(current_path, "/") == 0) {
            strcpy(new_path, "/");
            strcat(new_path, item->name);
        } else {
            strcpy(new_path, current_path);
            strcat(new_path, "/");
            strcat(new_path, item->name);
        }
        navigate_to(new_path);
    }
}

static void build_item_path(int idx, char *out, size_t out_size) {
    if (strcmp(current_path, "/") == 0) {
        strcpy(out, "/");
        strcat(out, items[idx].name);
    } else {
        strcpy(out, current_path);
        strcat(out, "/");
        strcat(out, items[idx].name);
    }
}

// ============ Context Menu Actions ============

static void action_new_file(void) {
    // Add a fake entry at the end and start renaming it
    if (item_count >= MAX_ITEMS) return;

    creating_idx = item_count;
    strcpy(items[item_count].name, "");
    items[item_count].is_dir = 0;
    item_count++;

    selected_idx = creating_idx;
    renaming = 1;
    creating_new = 1;  // New file
    rename_buf[0] = '\0';
    rename_cursor = 0;

    // Scroll to show new item if needed
    if (selected_idx >= scroll_offset + MAX_VISIBLE) {
        scroll_offset = selected_idx - MAX_VISIBLE + 1;
    }
}

static void action_new_folder(void) {
    // Add a fake entry at the end and start renaming it
    if (item_count >= MAX_ITEMS) return;

    creating_idx = item_count;
    strcpy(items[item_count].name, "");
    items[item_count].is_dir = 1;
    item_count++;

    selected_idx = creating_idx;
    renaming = 1;
    creating_new = 2;  // New folder
    rename_buf[0] = '\0';
    rename_cursor = 0;

    // Scroll to show new item if needed
    if (selected_idx >= scroll_offset + MAX_VISIBLE) {
        scroll_offset = selected_idx - MAX_VISIBLE + 1;
    }
}

static void action_rename(void) {
    if (selected_idx < 0 || selected_idx >= item_count) return;
    if (strcmp(items[selected_idx].name, "..") == 0) return;

    renaming = 1;
    creating_new = 0;  // Just renaming
    strcpy(rename_buf, items[selected_idx].name);
    rename_cursor = strlen(rename_buf);
}

static void action_delete(void) {
    if (selected_idx < 0 || selected_idx >= item_count) return;
    if (strcmp(items[selected_idx].name, "..") == 0) return;

    char path[256];
    build_item_path(selected_idx, path, sizeof(path));

    // Use userspace recursive delete - works for both files and directories
    delete_recursive(path);

    refresh_directory();
}

static void action_open_textedit(void) {
    if (selected_idx < 0 || selected_idx >= item_count) return;
    if (items[selected_idx].is_dir) return;

    char path[256];
    build_item_path(selected_idx, path, sizeof(path));

    // Launch textedit with the file
    char *argv[2];
    argv[0] = "/bin/textedit";
    argv[1] = path;
    api->exec_args("/bin/textedit", 2, argv);
}

static void action_open_terminal(void) {
    // Set cwd to current path and launch terminal
    api->set_cwd(current_path);
    api->exec("/bin/term");
}

static void do_menu_action(int item) {
    menu_visible = 0;

    switch (item) {
        case 0: action_new_file(); break;
        case 1: action_new_folder(); break;
        case 2: action_rename(); break;
        case 3: action_delete(); break;
        case 4: action_open_textedit(); break;
        case 5: action_open_terminal(); break;
    }
}

static void finish_rename(void) {
    if (!renaming) return;

    renaming = 0;

    // Empty name - cancel
    if (strlen(rename_buf) == 0) {
        if (creating_new) {
            // Remove the fake entry we added
            item_count--;
            creating_new = 0;
            creating_idx = -1;
        }
        return;
    }

    if (creating_new) {
        // Actually create the file/folder now
        char path[256];
        strcpy(path, current_path);
        if (strcmp(path, "/") != 0) strcat(path, "/");
        strcat(path, rename_buf);

        if (creating_new == 1) {
            api->create(path);
        } else {
            api->mkdir(path);
        }

        creating_new = 0;
        creating_idx = -1;
        refresh_directory();
    } else {
        // Renaming existing item
        if (strcmp(rename_buf, items[selected_idx].name) == 0) return;

        char path[256];
        build_item_path(selected_idx, path, sizeof(path));

        api->rename(path, rename_buf);
        refresh_directory();
    }
}

static void cancel_rename(void) {
    renaming = 0;

    if (creating_new) {
        // Remove the fake entry we added
        item_count--;
        creating_new = 0;
        creating_idx = -1;
    }
}

// ============ Drawing ============

static void draw_path_bar(void) {
    buf_fill_rect(0, 0, win_w, PATH_BAR_HEIGHT, COLOR_PATH_BG);
    buf_draw_rect(0, 0, win_w, PATH_BAR_HEIGHT, COLOR_FG);

    // Draw path
    buf_draw_string_clip(4, 4, current_path, COLOR_FG, COLOR_PATH_BG, win_w - 8);
}

static void draw_item(int idx, int y) {
    file_entry_t *item = &items[idx];
    int is_selected = (idx == selected_idx);

    uint32_t bg = is_selected ? COLOR_SELECTED : COLOR_BG;
    uint32_t fg = is_selected ? COLOR_SEL_TEXT : COLOR_FG;

    // Background
    buf_fill_rect(0, y, win_w - SCROLL_WIDTH, ITEM_HEIGHT, bg);

    // Icon
    int icon_x = 4;
    int icon_y = y + 2;
    if (item->is_dir) {
        draw_folder_icon(icon_x, icon_y, bg);
    } else {
        draw_file_icon(icon_x, icon_y, bg);
    }

    // Name
    int text_x = 20;
    int text_y = y + 1;

    if (renaming && idx == selected_idx) {
        // Draw rename input box
        buf_fill_rect(text_x, y, win_w - SCROLL_WIDTH - text_x - 4, ITEM_HEIGHT, COLOR_BG);
        buf_draw_rect(text_x, y, win_w - SCROLL_WIDTH - text_x - 4, ITEM_HEIGHT, COLOR_FG);
        buf_draw_string_clip(text_x + 2, text_y, rename_buf, COLOR_FG, COLOR_BG, win_w - SCROLL_WIDTH - text_x - 8);

        // Cursor
        int cursor_x = text_x + 2 + rename_cursor * 8;
        for (int cy = y + 2; cy < y + ITEM_HEIGHT - 2; cy++) {
            if (cursor_x < win_w)
                win_buffer[cy * win_w + cursor_x] = COLOR_FG;
        }
    } else {
        buf_draw_string_clip(text_x, text_y, item->name, fg, bg, win_w - SCROLL_WIDTH - text_x - 4);
    }
}

static void draw_file_list(void) {
    int y = PATH_BAR_HEIGHT + 2;

    // Background
    buf_fill_rect(0, PATH_BAR_HEIGHT, win_w, win_h - PATH_BAR_HEIGHT, COLOR_BG);

    // Items
    for (int i = 0; i < MAX_VISIBLE && (scroll_offset + i) < item_count; i++) {
        draw_item(scroll_offset + i, y);
        y += ITEM_HEIGHT;
    }

    // Scroll bar area
    buf_fill_rect(win_w - SCROLL_WIDTH, PATH_BAR_HEIGHT, SCROLL_WIDTH, win_h - PATH_BAR_HEIGHT, COLOR_PATH_BG);
    buf_draw_rect(win_w - SCROLL_WIDTH, PATH_BAR_HEIGHT, SCROLL_WIDTH, win_h - PATH_BAR_HEIGHT, COLOR_FG);

    // Scroll thumb
    if (item_count > MAX_VISIBLE) {
        int track_h = win_h - PATH_BAR_HEIGHT - 4;
        int thumb_h = (MAX_VISIBLE * track_h) / item_count;
        if (thumb_h < 20) thumb_h = 20;
        int thumb_y = PATH_BAR_HEIGHT + 2 + (scroll_offset * track_h) / item_count;

        buf_fill_rect(win_w - SCROLL_WIDTH + 2, thumb_y, SCROLL_WIDTH - 4, thumb_h, COLOR_FG);
    }
}

static void draw_context_menu(void) {
    if (!menu_visible) return;

    int menu_h = MENU_ITEM_COUNT * MENU_ITEM_HEIGHT + 4;

    // Adjust position if menu goes off screen
    int mx = menu_x;
    int my = menu_y;
    if (mx + MENU_WIDTH > win_w) mx = win_w - MENU_WIDTH;
    if (my + menu_h > win_h) my = win_h - menu_h;

    // Background with border
    buf_fill_rect(mx, my, MENU_WIDTH, menu_h, COLOR_MENU_BG);
    buf_draw_rect(mx, my, MENU_WIDTH, menu_h, COLOR_FG);
    buf_draw_rect(mx + 1, my + 1, MENU_WIDTH - 2, menu_h - 2, COLOR_FG);

    // Items
    for (int i = 0; i < MENU_ITEM_COUNT; i++) {
        int item_y = my + 2 + i * MENU_ITEM_HEIGHT;
        uint32_t bg = (i == menu_hover) ? COLOR_MENU_HL : COLOR_MENU_BG;
        uint32_t fg = (i == menu_hover) ? COLOR_SEL_TEXT : COLOR_FG;

        buf_fill_rect(mx + 2, item_y, MENU_WIDTH - 4, MENU_ITEM_HEIGHT, bg);
        buf_draw_string(mx + 6, item_y + 1, menu_items[i], fg, bg);
    }
}

static void draw_all(void) {
    draw_path_bar();
    draw_file_list();
    draw_context_menu();
    api->window_invalidate(window_id);
}

// ============ Input Handling ============

static int item_at_point(int x, int y) {
    if (y < PATH_BAR_HEIGHT + 2) return -1;
    if (x > win_w - SCROLL_WIDTH) return -1;

    int row = (y - PATH_BAR_HEIGHT - 2) / ITEM_HEIGHT;
    int idx = scroll_offset + row;

    if (idx >= 0 && idx < item_count) return idx;
    return -1;
}

static int menu_item_at_point(int x, int y) {
    if (!menu_visible) return -1;

    int menu_h = MENU_ITEM_COUNT * MENU_ITEM_HEIGHT + 4;
    int mx = menu_x;
    int my = menu_y;
    if (mx + MENU_WIDTH > win_w) mx = win_w - MENU_WIDTH;
    if (my + menu_h > win_h) my = win_h - menu_h;

    if (x < mx || x >= mx + MENU_WIDTH) return -1;
    if (y < my + 2 || y >= my + menu_h - 2) return -1;

    return (y - my - 2) / MENU_ITEM_HEIGHT;
}

static void handle_key(int key) {
    if (renaming) {
        if (key == '\r' || key == '\n') {
            finish_rename();
        } else if (key == 27) {  // Escape
            cancel_rename();
        } else if (key == '\b' || key == 127) {  // Backspace
            if (rename_cursor > 0) {
                for (int i = rename_cursor - 1; rename_buf[i]; i++) {
                    rename_buf[i] = rename_buf[i + 1];
                }
                rename_cursor--;
            }
        } else if (key >= 32 && key < 127 && rename_cursor < 62) {
            // Insert character
            int len = strlen(rename_buf);
            for (int i = len + 1; i > rename_cursor; i--) {
                rename_buf[i] = rename_buf[i - 1];
            }
            rename_buf[rename_cursor++] = (char)key;
        }
        return;
    }

    // Close menu on any key
    if (menu_visible) {
        menu_visible = 0;
        return;
    }

    // Navigation keys
    if (key == 0x100) {  // Up
        if (selected_idx > 0) {
            selected_idx--;
            if (selected_idx < scroll_offset) scroll_offset = selected_idx;
        }
    } else if (key == 0x101) {  // Down
        if (selected_idx < item_count - 1) {
            selected_idx++;
            if (selected_idx >= scroll_offset + MAX_VISIBLE)
                scroll_offset = selected_idx - MAX_VISIBLE + 1;
        }
    } else if (key == '\r' || key == '\n') {
        enter_selected();
    } else if (key == '\b' || key == 127) {  // Backspace - go up
        navigate_up();
    }
}

// ============ Main ============

int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    if (!api->window_create) {
        api->puts("files: window API not available\n");
        return 1;
    }

    // Create window
    window_id = api->window_create(100, 80, WIN_WIDTH, WIN_HEIGHT + 18, "Files");
    if (window_id < 0) {
        api->puts("files: failed to create window\n");
        return 1;
    }

    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buffer) {
        api->puts("files: failed to get window buffer\n");
        api->window_destroy(window_id);
        return 1;
    }

    // Initialize graphics context
    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);

    // Initialize with cwd
    api->get_cwd(current_path, sizeof(current_path));
    refresh_directory();

    // Initial draw
    draw_all();

    // Event loop
    int running = 1;
    int last_click_time = 0;
    int last_click_idx = -1;

    while (running) {
        int event_type, data1, data2, data3;
        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;

                case WIN_EVENT_MOUSE_DOWN: {
                    int x = data1, y = data2;
                    int btn = data3;

                    // Check context menu click
                    if (menu_visible) {
                        int mi = menu_item_at_point(x, y);
                        if (mi >= 0) {
                            do_menu_action(mi);
                        } else {
                            menu_visible = 0;
                        }
                        draw_all();
                        break;
                    }

                    // Cancel rename on click elsewhere
                    if (renaming) {
                        finish_rename();
                        draw_all();
                    }

                    // Right click - show context menu
                    if (btn & MOUSE_BTN_RIGHT) {
                        int idx = item_at_point(x, y);
                        if (idx >= 0) selected_idx = idx;
                        menu_x = x;
                        menu_y = y;
                        menu_visible = 1;
                        menu_hover = -1;
                        draw_all();
                        break;
                    }

                    // Left click
                    int idx = item_at_point(x, y);
                    if (idx >= 0) {
                        // Double-click detection
                        int current_time = (int)api->get_uptime_ticks();
                        if (idx == last_click_idx && (current_time - last_click_time) < 50) {
                            // Double click
                            enter_selected();
                        } else {
                            selected_idx = idx;
                            last_click_idx = idx;
                            last_click_time = current_time;
                        }
                    } else {
                        selected_idx = -1;
                    }
                    draw_all();
                    break;
                }

                case WIN_EVENT_MOUSE_MOVE: {
                    if (menu_visible) {
                        int mi = menu_item_at_point(data1, data2);
                        if (mi != menu_hover) {
                            menu_hover = mi;
                            draw_all();
                        }
                    }
                    break;
                }

                case WIN_EVENT_KEY:
                    handle_key(data1);
                    draw_all();
                    break;

                case WIN_EVENT_RESIZE:
                    // Re-fetch buffer with new dimensions
                    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
                    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);
                    draw_all();
                    break;
            }
        }

        // Yield to other processes
        api->yield();
    }

    api->window_destroy(window_id);
    return 0;
}
</file>

<file path="user/bin/rm.c">
/*
 * rm - remove files and directories
 */

#include "../lib/vibe.h"

static kapi_t *api;

static void out_puts(const char *s) {
    if (api->stdio_puts) api->stdio_puts(s);
    else api->puts(s);
}

// Simple strlen
static int str_len(const char *s) {
    int len = 0;
    while (*s++) len++;
    return len;
}

// Simple strcmp
static int str_cmp(const char *a, const char *b) {
    while (*a && *a == *b) { a++; b++; }
    return *a - *b;
}

// Simple strcpy
static void str_cpy(char *dst, const char *src) {
    while ((*dst++ = *src++));
}

// Recursive delete implementation in userspace
static int delete_recursive(const char *path) {
    // First try deleting as a file
    if (api->delete(path) == 0) {
        return 0;
    }

    // Try deleting as an empty directory
    if (api->delete_dir(path) == 0) {
        return 0;
    }

    // If that failed, it might be a non-empty directory
    // Open directory and iterate
    void *dir = api->open(path);
    if (!dir) {
        return -1;
    }

    char name[256];
    unsigned char type;
    char child_path[512];
    int idx = 0;

    // Collect all names first, then delete
    // (Can't delete while iterating - shifts indices)
    char all_names[4096];
    int name_offsets[128];
    int name_count = 0;
    int buf_pos = 0;

    while (api->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        idx++;

        // Skip . and ..
        if (str_cmp(name, ".") == 0 || str_cmp(name, "..") == 0) {
            continue;
        }

        // Store name
        if (name_count < 128 && buf_pos + str_len(name) + 1 < 4096) {
            name_offsets[name_count++] = buf_pos;
            str_cpy(all_names + buf_pos, name);
            buf_pos += str_len(name) + 1;
        }
    }

    // Now delete all collected entries
    for (int i = 0; i < name_count; i++) {
        // Build child path
        str_cpy(child_path, path);
        int plen = str_len(child_path);
        if (plen > 0 && child_path[plen - 1] != '/') {
            child_path[plen] = '/';
            child_path[plen + 1] = '\0';
        }
        int clen = str_len(child_path);
        str_cpy(child_path + clen, all_names + name_offsets[i]);

        // Recursively delete child
        delete_recursive(child_path);
    }

    // Now directory should be empty, delete it as directory
    return api->delete_dir(path);
}

int main(kapi_t *k, int argc, char **argv) {
    api = k;

    if (argc < 2) {
        out_puts("Usage: rm [-r] <file> [...]\n");
        return 1;
    }

    int status = 0;
    int recursive = 0;
    int start_idx = 1;

    // Check for -r flag
    if (argc >= 2 && argv[1][0] == '-' && argv[1][1] == 'r' && argv[1][2] == '\0') {
        recursive = 1;
        start_idx = 2;
    }

    if (start_idx >= argc) {
        out_puts("Usage: rm [-r] <file> [...]\n");
        return 1;
    }

    for (int i = start_idx; i < argc; i++) {
        int result;
        if (recursive) {
            result = delete_recursive(argv[i]);
        } else {
            result = k->delete(argv[i]);
        }

        if (result < 0) {
            out_puts("rm: cannot remove '");
            out_puts(argv[i]);
            out_puts("'");
            if (!recursive) {
                out_puts(" (directory? use -r)");
            }
            out_puts("\n");
            status = 1;
        }
    }

    return status;
}
</file>

<file path="user/bin/sysmon.c">
/*
 * VibeOS System Monitor
 *
 * Classic Mac-style system monitor showing system stats.
 * Shows: uptime, date/time, memory, disk, processes, sound status.
 */

#include "../lib/vibe.h"
#include "../lib/gfx.h"

static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;
static gfx_ctx_t gfx;

// Window content dimensions
#define CONTENT_W 280
#define CONTENT_H 450

// Process states (must match kernel)
#define PROC_STATE_FREE    0
#define PROC_STATE_READY   1
#define PROC_STATE_RUNNING 2
#define PROC_STATE_BLOCKED 3
#define PROC_STATE_ZOMBIE  4

#define MAX_PROCESSES 16

// Drawing macros
#define buf_fill_rect(x, y, w, h, c)     gfx_fill_rect(&gfx, x, y, w, h, c)
#define buf_draw_char(x, y, ch, fg, bg)  gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define buf_draw_string(x, y, s, fg, bg) gfx_draw_string(&gfx, x, y, s, fg, bg)
#define buf_draw_rect(x, y, w, h, c)     gfx_draw_rect(&gfx, x, y, w, h, c)

// ============ Formatting Helpers ============

static void format_num(char *buf, unsigned long n) {
    if (n == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return;
    }
    char tmp[20];
    int i = 0;
    while (n > 0) {
        tmp[i++] = '0' + (n % 10);
        n /= 10;
    }
    int j = 0;
    while (i > 0) {
        buf[j++] = tmp[--i];
    }
    buf[j] = '\0';
}

static void format_size_mb(char *buf, unsigned long bytes) {
    unsigned long mb = bytes / (1024 * 1024);
    unsigned long remainder = (bytes % (1024 * 1024)) * 10 / (1024 * 1024);

    format_num(buf, mb);
    int len = strlen(buf);
    buf[len] = '.';
    buf[len+1] = '0' + remainder;
    buf[len+2] = ' ';
    buf[len+3] = 'M';
    buf[len+4] = 'B';
    buf[len+5] = '\0';
}

static void format_size_kb(char *buf, int kb) {
    if (kb >= 1024) {
        // Show as MB
        int mb = kb / 1024;
        int remainder = ((kb % 1024) * 10) / 1024;
        format_num(buf, mb);
        int len = strlen(buf);
        buf[len] = '.';
        buf[len+1] = '0' + remainder;
        buf[len+2] = ' ';
        buf[len+3] = 'M';
        buf[len+4] = 'B';
        buf[len+5] = '\0';
    } else {
        format_num(buf, kb);
        int len = strlen(buf);
        buf[len] = ' ';
        buf[len+1] = 'K';
        buf[len+2] = 'B';
        buf[len+3] = '\0';
    }
}

static void format_uptime(char *buf, unsigned long ticks) {
    unsigned long total_seconds = ticks / 100;
    unsigned long hours = total_seconds / 3600;
    unsigned long minutes = (total_seconds % 3600) / 60;
    unsigned long seconds = total_seconds % 60;

    char tmp[8];
    int pos = 0;

    if (hours > 0) {
        format_num(tmp, hours);
        for (int i = 0; tmp[i]; i++) buf[pos++] = tmp[i];
        buf[pos++] = 'h';
        buf[pos++] = ' ';
    }

    format_num(tmp, minutes);
    for (int i = 0; tmp[i]; i++) buf[pos++] = tmp[i];
    buf[pos++] = 'm';
    buf[pos++] = ' ';

    format_num(tmp, seconds);
    for (int i = 0; tmp[i]; i++) buf[pos++] = tmp[i];
    buf[pos++] = 's';
    buf[pos] = '\0';
}

static void format_datetime(char *buf, int year, int month, int day,
                            int hour, int minute, int second) {
    // Format: YYYY-MM-DD HH:MM:SS
    int pos = 0;

    // Year
    buf[pos++] = '0' + (year / 1000) % 10;
    buf[pos++] = '0' + (year / 100) % 10;
    buf[pos++] = '0' + (year / 10) % 10;
    buf[pos++] = '0' + year % 10;
    buf[pos++] = '-';

    // Month
    buf[pos++] = '0' + (month / 10) % 10;
    buf[pos++] = '0' + month % 10;
    buf[pos++] = '-';

    // Day
    buf[pos++] = '0' + (day / 10) % 10;
    buf[pos++] = '0' + day % 10;
    buf[pos++] = ' ';

    // Hour
    buf[pos++] = '0' + (hour / 10) % 10;
    buf[pos++] = '0' + hour % 10;
    buf[pos++] = ':';

    // Minute
    buf[pos++] = '0' + (minute / 10) % 10;
    buf[pos++] = '0' + minute % 10;
    buf[pos++] = ':';

    // Second
    buf[pos++] = '0' + (second / 10) % 10;
    buf[pos++] = '0' + second % 10;

    buf[pos] = '\0';
}

// ============ Drawing ============

static void draw_progress_bar(int x, int y, int w, int h, int percent) {
    // Background
    buf_fill_rect(x, y, w, h, COLOR_WHITE);
    buf_draw_rect(x, y, w, h, COLOR_BLACK);

    // Fill with diagonal stripes
    int fill_w = (w - 2) * percent / 100;
    if (fill_w > 0) {
        for (int py = y + 1; py < y + h - 1; py++) {
            for (int px = x + 1; px < x + 1 + fill_w; px++) {
                if ((px + py) % 2 == 0) {
                    win_buffer[py * win_w + px] = COLOR_BLACK;
                }
            }
        }
    }
}

static void draw_section_header(int y, const char *title) {
    // Draw a line with title
    buf_fill_rect(8, y, CONTENT_W - 16, 1, COLOR_BLACK);
    buf_fill_rect(8, y + 2, CONTENT_W - 16, 1, COLOR_BLACK);

    // Clear area for text
    int text_w = strlen(title) * 8 + 8;
    buf_fill_rect(12, y - 1, text_w, 5, COLOR_WHITE);

    // Draw title
    buf_draw_string(16, y - 6, title, COLOR_BLACK, COLOR_WHITE);
}

static void draw_label_value(int y, const char *label, const char *value) {
    buf_draw_string(16, y, label, COLOR_BLACK, COLOR_WHITE);
    buf_draw_string(120, y, value, COLOR_BLACK, COLOR_WHITE);
}

static void draw_all(void) {
    // Clear background
    buf_fill_rect(0, 0, win_w, win_h, COLOR_WHITE);

    char buf[64];
    int y = 8;

    // ============ Overview Section ============
    draw_section_header(y + 4, "Overview");
    y += 16;

    // Uptime
    unsigned long ticks = api->get_uptime_ticks();
    format_uptime(buf, ticks);
    draw_label_value(y, "Uptime:", buf);
    y += 16;

    // Date/Time
    int year, month, day, hour, minute, second, weekday;
    api->get_datetime(&year, &month, &day, &hour, &minute, &second, &weekday);
    format_datetime(buf, year, month, day, hour, minute, second);
    draw_label_value(y, "Time:", buf);
    y += 20;

    // ============ Memory Section ============
    draw_section_header(y + 4, "Memory");
    y += 16;

    // RAM total
    size_t ram_total = api->get_ram_total();
    format_size_mb(buf, ram_total);
    draw_label_value(y, "RAM Total:", buf);
    y += 16;

    // Heap used/free
    size_t mem_used = api->get_mem_used();
    size_t mem_free = api->get_mem_free();
    size_t mem_total = mem_used + mem_free;
    int mem_percent = (int)((mem_used * 100) / mem_total);

    format_size_mb(buf, mem_used);
    draw_label_value(y, "Heap Used:", buf);
    y += 16;

    format_size_mb(buf, mem_free);
    draw_label_value(y, "Heap Free:", buf);
    y += 16;

    // Memory progress bar
    buf_draw_string(16, y, "Heap:", COLOR_BLACK, COLOR_WHITE);
    draw_progress_bar(70, y, CONTENT_W - 86, 12, mem_percent);

    // Show percentage
    format_num(buf, mem_percent);
    int blen = strlen(buf);
    buf[blen] = '%';
    buf[blen+1] = '\0';
    buf_draw_string(CONTENT_W - 32, y, buf, COLOR_BLACK, COLOR_WHITE);
    y += 20;

    // ============ Disk Section ============
    draw_section_header(y + 4, "Disk");
    y += 16;

    int disk_total = api->get_disk_total();
    format_size_kb(buf, disk_total);
    draw_label_value(y, "Size:", buf);
    y += 20;

    // ============ Processes Section ============
    draw_section_header(y + 4, "Processes");
    y += 16;

    int proc_count = api->get_process_count();
    format_num(buf, proc_count);
    strcat(buf, " active");
    draw_label_value(y, "Count:", buf);
    y += 16;

    // List active processes (no limit)
    const char *state_names[] = { "-", "Ready", "Run", "Block", "Zombie" };
    int shown = 0;
    for (int i = 0; i < MAX_PROCESSES; i++) {
        char name[32];
        int state;
        if (api->get_process_info(i, name, sizeof(name), &state)) {
            // Truncate long names
            if (strlen(name) > 12) {
                name[12] = '\0';
            }
            buf_draw_string(16, y, name, COLOR_BLACK, COLOR_WHITE);

            const char *state_str = (state >= 0 && state <= 4) ? state_names[state] : "?";
            buf_draw_string(130, y, state_str, COLOR_BLACK, COLOR_WHITE);
            y += 14;
            shown++;
        }
    }
    if (shown == 0) {
        buf_draw_string(16, y, "(none)", COLOR_BLACK, COLOR_WHITE);
        y += 14;
    }
    y += 6;

    // ============ Sound Section ============
    draw_section_header(y + 4, "Sound");
    y += 16;

    const char *sound_status;
    if (api->sound_is_playing()) {
        sound_status = "Playing";
    } else if (api->sound_is_paused()) {
        sound_status = "Paused";
    } else {
        sound_status = "Idle";
    }
    draw_label_value(y, "Status:", sound_status);

    api->window_invalidate(window_id);
}

// ============ CLI Output ============

static void print_cli(void) {
    char buf[64];

    // Helper to print output
    void (*out)(const char *) = api->stdio_puts ? api->stdio_puts : api->puts;

    out("=== System Monitor ===\n\n");

    // Uptime
    unsigned long ticks = api->get_uptime_ticks();
    format_uptime(buf, ticks);
    out("Uptime:     ");
    out(buf);
    out("\n");

    // Date/Time
    int year, month, day, hour, minute, second, weekday;
    api->get_datetime(&year, &month, &day, &hour, &minute, &second, &weekday);
    format_datetime(buf, year, month, day, hour, minute, second);
    out("Time:       ");
    out(buf);
    out("\n\n");

    // RAM
    size_t ram_total = api->get_ram_total();
    format_size_mb(buf, ram_total);
    out("RAM Total:  ");
    out(buf);
    out("\n");

    // Heap
    size_t mem_used = api->get_mem_used();
    size_t mem_free = api->get_mem_free();
    size_t mem_total = mem_used + mem_free;
    int mem_percent = (int)((mem_used * 100) / mem_total);

    format_size_mb(buf, mem_used);
    out("Heap Used:  ");
    out(buf);
    out("\n");

    format_size_mb(buf, mem_free);
    out("Heap Free:  ");
    out(buf);
    out(" (");
    format_num(buf, mem_percent);
    out(buf);
    out("% used)\n\n");

    // Disk
    int disk_total = api->get_disk_total();
    format_size_kb(buf, disk_total);
    out("Disk Size:  ");
    out(buf);
    out("\n\n");

    // Processes
    int proc_count = api->get_process_count();
    out("Processes:  ");
    format_num(buf, proc_count);
    out(buf);
    out(" active\n");

    const char *state_names[] = { "-", "Ready", "Run", "Block", "Zombie" };
    for (int i = 0; i < MAX_PROCESSES; i++) {
        char name[32];
        int state;
        if (api->get_process_info(i, name, sizeof(name), &state)) {
            out("  ");
            out(name);
            // Pad to 16 chars
            int pad = 16 - strlen(name);
            while (pad-- > 0) out(" ");
            const char *state_str = (state >= 0 && state <= 4) ? state_names[state] : "?";
            out(state_str);
            out("\n");
        }
    }
    out("\n");

    // Sound
    out("Sound:      ");
    if (api->sound_is_playing()) {
        out("Playing\n");
    } else if (api->sound_is_paused()) {
        out("Paused\n");
    } else {
        out("Idle\n");
    }
}

// ============ Main ============

int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    // If no window API, run as CLI tool
    if (!api->window_create) {
        print_cli();
        return 0;
    }

    // Create window
    window_id = api->window_create(250, 100, CONTENT_W, CONTENT_H + 18, "System Monitor");
    if (window_id < 0) {
        api->puts("sysmon: failed to create window\n");
        return 1;
    }

    // Get buffer
    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buffer) {
        api->puts("sysmon: failed to get window buffer\n");
        api->window_destroy(window_id);
        return 1;
    }

    // Initialize graphics context
    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);

    // Initial draw
    draw_all();

    // Event loop with periodic refresh
    int running = 1;
    int refresh_counter = 0;

    while (running) {
        int event_type, data1, data2, data3;
        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;
                case WIN_EVENT_KEY:
                    if (data1 == 'q' || data1 == 'Q' || data1 == 27) {
                        running = 0;
                    }
                    break;
                case WIN_EVENT_RESIZE:
                    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
                    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);
                    draw_all();
                    break;
            }
        }

        // Refresh display every ~1 second (60 frames * 16ms)
        refresh_counter++;
        if (refresh_counter >= 60) {
            refresh_counter = 0;
            draw_all();
        }

        api->yield();
    }

    api->window_destroy(window_id);
    return 0;
}
</file>

<file path="user/bin/term.c">
/*
 * term - VibeOS Terminal Emulator
 *
 * A windowed terminal that runs vibesh inside a desktop window.
 * Features:
 *   - Scrollback buffer (configurable lines)
 *   - Mouse wheel scrolling
 *   - Ctrl+C handling
 *   - Form feed (\f) for clear screen
 */

#include "../lib/vibe.h"

// Terminal dimensions (characters)
#define TERM_COLS 80
#define TERM_ROWS 24

// Scrollback buffer size (total lines including visible)
#define SCROLLBACK_LINES 500

// Character size
#define CHAR_WIDTH 8
#define CHAR_HEIGHT 16

// Window dimensions
#define WIN_WIDTH  (TERM_COLS * CHAR_WIDTH)
#define WIN_HEIGHT (TERM_ROWS * CHAR_HEIGHT)

// Colors (1-bit style)
#define TERM_BG 0x00FFFFFF
#define TERM_FG 0x00000000

// Global state
static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;

// Scrollback buffer - ring buffer of lines
static char scrollback[SCROLLBACK_LINES][TERM_COLS];
static int scroll_head = 0;      // Next line to write to
static int scroll_count = 0;     // Total lines in buffer
static int scroll_offset = 0;    // How many lines scrolled back (0 = at bottom)

// Cursor position (relative to current write position, not view)
static int cursor_row = 0;       // Row within visible area
static int cursor_col = 0;

// Input buffer (ring buffer for keyboard input) - uses int for special keys
#define INPUT_BUF_SIZE 256
static int input_buffer[INPUT_BUF_SIZE];
static int input_head = 0;
static int input_tail = 0;

// Flag to track if shell is still running
static int shell_running = 1;

// ============ Scrollback Buffer Management ============

// Get the line index in scrollback buffer for a given display row
// row 0 is top of display, row TERM_ROWS-1 is bottom
static int get_line_index(int display_row) {
    // The visible area shows lines from (scroll_head - scroll_count + scroll_offset) to end
    // Actually, let's think about this differently:
    // - scroll_head points to where the NEXT line will be written
    // - The most recent line written is at scroll_head - 1
    // - The bottom of the display (when scroll_offset=0) shows the most recent lines

    // Bottom line of display = scroll_head - 1 - scroll_offset
    // Top line of display = bottom - TERM_ROWS + 1

    int bottom_line = scroll_head - 1 - scroll_offset;
    int target_line = bottom_line - (TERM_ROWS - 1 - display_row);

    // Wrap around
    while (target_line < 0) target_line += SCROLLBACK_LINES;
    target_line = target_line % SCROLLBACK_LINES;

    return target_line;
}

// Get pointer to a line in scrollback
static char *get_line(int display_row) {
    int idx = get_line_index(display_row);
    return scrollback[idx];
}

// Get the current write line (cursor row)
static char *get_write_line(void) {
    // Current write position is at scroll_head - (TERM_ROWS - cursor_row)
    int idx = scroll_head - (TERM_ROWS - cursor_row);
    while (idx < 0) idx += SCROLLBACK_LINES;
    idx = idx % SCROLLBACK_LINES;
    return scrollback[idx];
}

// Add a new line (scroll the terminal content up)
static void new_line(void) {
    // Clear the new line
    for (int i = 0; i < TERM_COLS; i++) {
        scrollback[scroll_head][i] = ' ';
    }

    scroll_head = (scroll_head + 1) % SCROLLBACK_LINES;
    if (scroll_count < SCROLLBACK_LINES) {
        scroll_count++;
    }

    // If we were scrolled back, stay at the same view position
    // (effectively scroll_offset increases by 1)
    // But if scroll_offset is 0, we stay at bottom
    if (scroll_offset > 0 && scroll_offset < scroll_count - TERM_ROWS) {
        scroll_offset++;
    }
}

// Clear the entire scrollback and screen
static void clear_all(void) {
    for (int i = 0; i < SCROLLBACK_LINES; i++) {
        for (int j = 0; j < TERM_COLS; j++) {
            scrollback[i][j] = ' ';
        }
    }
    scroll_head = TERM_ROWS;  // Leave room for visible area
    scroll_count = TERM_ROWS;
    scroll_offset = 0;
    cursor_row = 0;
    cursor_col = 0;
}

// ============ Drawing Functions ============

static void draw_char_at(int row, int col, char c) {
    if (row < 0 || row >= TERM_ROWS || col < 0 || col >= TERM_COLS) return;

    int px = col * CHAR_WIDTH;
    int py = row * CHAR_HEIGHT;

    const uint8_t *glyph = &api->font_data[(unsigned char)c * 16];

    for (int y = 0; y < CHAR_HEIGHT; y++) {
        for (int x = 0; x < CHAR_WIDTH; x++) {
            uint32_t color = (glyph[y] & (0x80 >> x)) ? TERM_FG : TERM_BG;
            int idx = (py + y) * win_w + (px + x);
            if (idx >= 0 && idx < win_w * win_h) {
                win_buffer[idx] = color;
            }
        }
    }
}

static void draw_cursor(void) {
    // Only draw cursor if we're at the bottom (not scrolled back)
    if (scroll_offset != 0) return;

    // Draw cursor as inverse block
    int px = cursor_col * CHAR_WIDTH;
    int py = cursor_row * CHAR_HEIGHT;

    for (int y = 0; y < CHAR_HEIGHT; y++) {
        for (int x = 0; x < CHAR_WIDTH; x++) {
            int idx = (py + y) * win_w + (px + x);
            if (idx >= 0 && idx < win_w * win_h) {
                // Invert the pixel
                win_buffer[idx] = win_buffer[idx] == TERM_BG ? TERM_FG : TERM_BG;
            }
        }
    }
}

static void redraw_screen(void) {
    // Clear buffer
    for (int i = 0; i < win_w * win_h; i++) {
        win_buffer[i] = TERM_BG;
    }

    // Draw all characters from scrollback
    for (int row = 0; row < TERM_ROWS; row++) {
        char *line = get_line(row);
        for (int col = 0; col < TERM_COLS; col++) {
            char c = line[col];
            if (c && c != ' ') {
                draw_char_at(row, col, c);
            }
        }
    }

    // Draw scrollback indicator if scrolled back
    if (scroll_offset > 0) {
        // Draw a small indicator in top-right
        char indicator[16];
        int lines_back = scroll_offset;
        // Simple integer to string
        int i = 0;
        indicator[i++] = '[';
        if (lines_back >= 100) indicator[i++] = '0' + (lines_back / 100) % 10;
        if (lines_back >= 10) indicator[i++] = '0' + (lines_back / 10) % 10;
        indicator[i++] = '0' + lines_back % 10;
        indicator[i++] = ']';
        indicator[i] = '\0';

        // Draw at top right, inverted
        int start_col = TERM_COLS - i;
        for (int j = 0; j < i && indicator[j]; j++) {
            // Draw inverted
            int px = (start_col + j) * CHAR_WIDTH;
            int py = 0;
            const uint8_t *glyph = &api->font_data[(unsigned char)indicator[j] * 16];
            for (int y = 0; y < CHAR_HEIGHT; y++) {
                for (int x = 0; x < CHAR_WIDTH; x++) {
                    uint32_t color = (glyph[y] & (0x80 >> x)) ? TERM_BG : TERM_FG;
                    int idx = (py + y) * win_w + (px + x);
                    if (idx >= 0 && idx < win_w * win_h) {
                        win_buffer[idx] = color;
                    }
                }
            }
        }
    }

    // Draw cursor
    draw_cursor();

    // Tell desktop to redraw
    api->window_invalidate(window_id);
}

// ============ Terminal Operations ============

static void term_putc(char c) {
    if (c == '\f') {
        // Form feed - clear screen
        clear_all();
        return;
    }

    if (c == '\n') {
        cursor_col = 0;
        cursor_row++;
        if (cursor_row >= TERM_ROWS) {
            cursor_row = TERM_ROWS - 1;
            new_line();
        }
        // Jump to bottom when outputting
        scroll_offset = 0;
        return;
    }

    if (c == '\r') {
        cursor_col = 0;
        return;
    }

    if (c == '\b') {
        if (cursor_col > 0) {
            cursor_col--;
        }
        return;
    }

    if (c == '\t') {
        cursor_col = (cursor_col + 8) & ~7;
        if (cursor_col >= TERM_COLS) {
            cursor_col = 0;
            cursor_row++;
            if (cursor_row >= TERM_ROWS) {
                cursor_row = TERM_ROWS - 1;
                new_line();
            }
        }
        return;
    }

    if (c >= 32 && c < 127) {
        // Printable character - write to current line
        char *line = get_write_line();
        line[cursor_col] = c;
        cursor_col++;
        if (cursor_col >= TERM_COLS) {
            cursor_col = 0;
            cursor_row++;
            if (cursor_row >= TERM_ROWS) {
                cursor_row = TERM_ROWS - 1;
                new_line();
            }
        }
        // Jump to bottom when outputting
        scroll_offset = 0;
    }
}

static void term_puts(const char *s) {
    while (*s) {
        term_putc(*s++);
    }
}

// ============ Stdio Hooks ============

static void stdio_hook_putc(char c) {
    term_putc(c);
    redraw_screen();
}

static void stdio_hook_puts(const char *s) {
    term_puts(s);
    redraw_screen();
}

static int stdio_hook_getc(void) {
    if (input_head == input_tail) {
        return -1;  // No input available
    }
    int c = input_buffer[input_head];
    input_head = (input_head + 1) % INPUT_BUF_SIZE;
    return c;
}

static int stdio_hook_has_key(void) {
    return input_head != input_tail;
}

// Add a key to input buffer
static void input_push(int c) {
    int next = (input_tail + 1) % INPUT_BUF_SIZE;
    if (next != input_head) {  // Not full
        input_buffer[input_tail] = c;
        input_tail = next;
    }
}

// ============ Scrolling ============

static void scroll_up(int lines) {
    // Scroll view back (show older content)
    int max_offset = scroll_count - TERM_ROWS;
    if (max_offset < 0) max_offset = 0;

    scroll_offset += lines;
    if (scroll_offset > max_offset) {
        scroll_offset = max_offset;
    }

    redraw_screen();
}

static void scroll_down(int lines) {
    // Scroll view forward (show newer content)
    scroll_offset -= lines;
    if (scroll_offset < 0) {
        scroll_offset = 0;
    }

    redraw_screen();
}

static void scroll_to_bottom(void) {
    scroll_offset = 0;
    redraw_screen();
}

// ============ Main ============

int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    // Check if window API is available
    if (!api->window_create) {
        api->puts("term: no window manager available\n");
        return 1;
    }

    // Create window
    window_id = api->window_create(50, 50, WIN_WIDTH, WIN_HEIGHT, "Terminal");
    if (window_id < 0) {
        api->puts("term: failed to create window\n");
        return 1;
    }

    // Get window buffer
    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buffer) {
        api->puts("term: failed to get window buffer\n");
        api->window_destroy(window_id);
        return 1;
    }

    // Initialize scrollback buffer
    clear_all();

    // Clear window to background color
    for (int i = 0; i < win_w * win_h; i++) {
        win_buffer[i] = TERM_BG;
    }

    // Register stdio hooks
    api->stdio_putc = stdio_hook_putc;
    api->stdio_puts = stdio_hook_puts;
    api->stdio_getc = stdio_hook_getc;
    api->stdio_has_key = stdio_hook_has_key;

    // Initial draw
    redraw_screen();

    // Spawn vibesh - it will use our stdio hooks
    int shell_pid = api->spawn("/bin/vibesh");
    if (shell_pid < 0) {
        term_puts("Failed to start shell!\n");
        redraw_screen();
    }

    // Track last mouse Y for scroll detection
    int last_mouse_y = -1;
    int mouse_scrolling = 0;

    // Main event loop
    while (shell_running) {
        // Poll window events
        int event_type, data1, data2, data3;
        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            if (event_type == WIN_EVENT_CLOSE) {
                shell_running = 0;
                break;
            }

            if (event_type == WIN_EVENT_KEY) {
                // Key pressed - add to input buffer (data1 is int, preserves special keys)
                input_push(data1);

                // If we're scrolled back and user types, jump to bottom
                if (scroll_offset > 0) {
                    scroll_to_bottom();
                }
            }

            if (event_type == WIN_EVENT_MOUSE_DOWN) {
                // Start tracking for scroll
                last_mouse_y = data2;  // data2 is y position
                mouse_scrolling = 1;
            }

            if (event_type == WIN_EVENT_MOUSE_UP) {
                mouse_scrolling = 0;
            }

            if (event_type == WIN_EVENT_MOUSE_MOVE) {
                // Check for scroll gesture (drag with button held)
                // data3 contains button state
                if (mouse_scrolling && (data3 & MOUSE_BTN_LEFT)) {
                    int dy = data2 - last_mouse_y;
                    if (dy < -CHAR_HEIGHT) {
                        // Dragged down = scroll up (show older)
                        scroll_up(1);
                        last_mouse_y = data2;
                    } else if (dy > CHAR_HEIGHT) {
                        // Dragged up = scroll down (show newer)
                        scroll_down(1);
                        last_mouse_y = data2;
                    }
                }
            }

            if (event_type == WIN_EVENT_RESIZE) {
                // Re-fetch buffer with new dimensions
                win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
                redraw_screen();
            }
        }

        // Yield to other processes
        api->yield();
    }

    // Clean up stdio hooks
    api->stdio_putc = 0;
    api->stdio_puts = 0;
    api->stdio_getc = 0;
    api->stdio_has_key = 0;

    // Destroy window
    api->window_destroy(window_id);

    return 0;
}
</file>

<file path="user/bin/textedit.c">
/*
 * VibeOS TextEdit
 *
 * Simple text editor in a window. No modes, just type.
 * Usage: textedit [filename]
 */

#include "../lib/vibe.h"
#include "../lib/gfx.h"

static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;
static gfx_ctx_t gfx;

// Editor dimensions
#define WINDOW_W 500
#define WINDOW_H 350
#define TITLE_BAR_H 18
#define GUTTER_W 40      // Line number gutter width
#define CONTENT_X (GUTTER_W + 4)
#define CONTENT_Y 4
#define CHAR_W 8
#define CHAR_H 16

// Colors for syntax highlighting
#define COLOR_GUTTER_BG   0x00EEEEEE
#define COLOR_GUTTER_FG   0x00888888
#define COLOR_KEYWORD     0x000000AA  // Dark blue
#define COLOR_COMMENT     0x00008800  // Dark green
#define COLOR_STRING      0x00AA0000  // Dark red
#define COLOR_NUMBER      0x00AA00AA  // Purple

// Text buffer
#define MAX_LINES 256
#define MAX_LINE_LEN 256
#define MAX_TEXT_SIZE (MAX_LINES * MAX_LINE_LEN)

static char text_buffer[MAX_TEXT_SIZE];
static int text_len = 0;
static int cursor_pos = 0;
static int scroll_offset = 0;  // First visible line

// Current file
static char current_file[256];
static int modified = 0;

// Save As modal state
static int save_as_mode = 0;
static char save_as_buf[256];
static int save_as_len = 0;

// Syntax highlighting
static int syntax_c = 0;  // Is this a .c or .h file?

// C keywords
static const char *c_keywords[] = {
    "auto", "break", "case", "char", "const", "continue", "default", "do",
    "double", "else", "enum", "extern", "float", "for", "goto", "if",
    "int", "long", "register", "return", "short", "signed", "sizeof", "static",
    "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while",
    "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t",
    "size_t", "NULL", "true", "false",
    0
};

// Visible area
static int visible_cols;
static int visible_rows;

// Check if filename ends with extension
static int ends_with(const char *str, const char *suffix) {
    int str_len = strlen(str);
    int suf_len = strlen(suffix);
    if (suf_len > str_len) return 0;
    for (int i = 0; i < suf_len; i++) {
        if (str[str_len - suf_len + i] != suffix[i]) return 0;
    }
    return 1;
}

static void detect_syntax(const char *filename) {
    syntax_c = 0;
    if (!filename || !filename[0]) return;

    if (ends_with(filename, ".c") || ends_with(filename, ".h") ||
        ends_with(filename, ".C") || ends_with(filename, ".H")) {
        syntax_c = 1;
    }
}

// ============ Drawing Helpers (macros wrapping gfx lib) ============

#define buf_fill_rect(x, y, w, h, c)     gfx_fill_rect(&gfx, x, y, w, h, c)
#define buf_draw_char(x, y, ch, fg, bg)  gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define buf_draw_string(x, y, s, fg, bg) gfx_draw_string(&gfx, x, y, s, fg, bg)

// ============ Text Buffer Helpers ============

// Get line number and column from cursor position
static void cursor_to_line_col(int pos, int *line, int *col) {
    *line = 0;
    *col = 0;
    for (int i = 0; i < pos && i < text_len; i++) {
        if (text_buffer[i] == '\n') {
            (*line)++;
            *col = 0;
        } else {
            (*col)++;
        }
    }
}

// Get cursor position from line and column
static int line_col_to_cursor(int line, int col) {
    int current_line = 0;
    int current_col = 0;
    int i;

    for (i = 0; i < text_len; i++) {
        if (current_line == line && current_col == col) {
            return i;
        }
        if (text_buffer[i] == '\n') {
            if (current_line == line) {
                // Requested column is past end of line
                return i;
            }
            current_line++;
            current_col = 0;
        } else {
            current_col++;
        }
    }

    // End of buffer
    return i;
}

// Get start of line containing pos
static int line_start(int pos) {
    while (pos > 0 && text_buffer[pos - 1] != '\n') {
        pos--;
    }
    return pos;
}

// Get end of line containing pos
static int line_end(int pos) {
    while (pos < text_len && text_buffer[pos] != '\n') {
        pos++;
    }
    return pos;
}

// Count total lines
static int count_lines(void) {
    int lines = 1;
    for (int i = 0; i < text_len; i++) {
        if (text_buffer[i] == '\n') lines++;
    }
    return lines;
}

// Insert character at cursor
static void insert_char(char c) {
    if (text_len >= MAX_TEXT_SIZE - 1) return;

    // Shift everything after cursor
    for (int i = text_len; i > cursor_pos; i--) {
        text_buffer[i] = text_buffer[i - 1];
    }
    text_buffer[cursor_pos] = c;
    text_len++;
    cursor_pos++;
    modified = 1;
}

// Delete character before cursor (backspace)
static void delete_char_before(void) {
    if (cursor_pos == 0) return;

    // Shift everything after cursor back
    for (int i = cursor_pos - 1; i < text_len - 1; i++) {
        text_buffer[i] = text_buffer[i + 1];
    }
    text_len--;
    cursor_pos--;
    modified = 1;
}

// Delete character at cursor (delete key)
static void delete_char_at(void) {
    if (cursor_pos >= text_len) return;

    for (int i = cursor_pos; i < text_len - 1; i++) {
        text_buffer[i] = text_buffer[i + 1];
    }
    text_len--;
    modified = 1;
}

// ============ File Operations ============

static void load_file(const char *path) {
    detect_syntax(path);

    void *file = api->open(path);
    if (!file) {
        text_len = 0;
        cursor_pos = 0;
        return;
    }

    if (api->is_dir(file)) {
        text_len = 0;
        cursor_pos = 0;
        return;
    }

    int bytes = api->read(file, text_buffer, MAX_TEXT_SIZE - 1, 0);
    if (bytes > 0) {
        text_len = bytes;
        text_buffer[text_len] = '\0';
    } else {
        text_len = 0;
    }
    cursor_pos = 0;
    modified = 0;
}

static int save_failed = 0;  // Show error in status bar

static void open_save_as(void) {
    save_as_mode = 1;
    save_as_len = 0;
    save_as_buf[0] = '\0';
    // Pre-fill with current filename if exists
    if (current_file[0]) {
        for (int i = 0; current_file[i] && i < 255; i++) {
            save_as_buf[i] = current_file[i];
            save_as_len++;
        }
        save_as_buf[save_as_len] = '\0';
    }
}

static void do_save(const char *path) {
    void *file = api->open(path);
    if (!file) {
        file = api->create(path);
    }
    if (!file) {
        save_failed = 1;
        return;
    }

    api->write(file, text_buffer, text_len);

    // Update current filename
    int i;
    for (i = 0; path[i] && i < 255; i++) {
        current_file[i] = path[i];
    }
    current_file[i] = '\0';

    // Update syntax highlighting for new filename
    detect_syntax(current_file);

    // Update window title
    api->window_set_title(window_id, current_file);

    modified = 0;
    save_failed = 0;
}

static void save_file(void) {
    if (current_file[0] == '\0') {
        // No filename - open Save As dialog
        open_save_as();
        return;
    }

    do_save(current_file);
}

// ============ Drawing ============

static void draw_save_as_modal(void) {
    // Modal dimensions
    int modal_w = 300;
    int modal_h = 80;
    int modal_x = (win_w - modal_w) / 2;
    int modal_y = (win_h - modal_h) / 2;

    // Draw shadow
    buf_fill_rect(modal_x + 3, modal_y + 3, modal_w, modal_h, 0x00888888);

    // Draw modal background
    buf_fill_rect(modal_x, modal_y, modal_w, modal_h, COLOR_WHITE);

    // Draw border
    buf_fill_rect(modal_x, modal_y, modal_w, 1, COLOR_BLACK);
    buf_fill_rect(modal_x, modal_y + modal_h - 1, modal_w, 1, COLOR_BLACK);
    buf_fill_rect(modal_x, modal_y, 1, modal_h, COLOR_BLACK);
    buf_fill_rect(modal_x + modal_w - 1, modal_y, 1, modal_h, COLOR_BLACK);

    // Draw title
    buf_draw_string(modal_x + 8, modal_y + 8, "Save As:", COLOR_BLACK, COLOR_WHITE);

    // Draw text input box
    int input_x = modal_x + 8;
    int input_y = modal_y + 28;
    int input_w = modal_w - 16;
    int input_h = 20;

    buf_fill_rect(input_x, input_y, input_w, input_h, COLOR_WHITE);
    buf_fill_rect(input_x, input_y, input_w, 1, COLOR_BLACK);
    buf_fill_rect(input_x, input_y + input_h - 1, input_w, 1, COLOR_BLACK);
    buf_fill_rect(input_x, input_y, 1, input_h, COLOR_BLACK);
    buf_fill_rect(input_x + input_w - 1, input_y, 1, input_h, COLOR_BLACK);

    // Draw filename text
    buf_draw_string(input_x + 4, input_y + 2, save_as_buf, COLOR_BLACK, COLOR_WHITE);

    // Draw cursor
    int cursor_x = input_x + 4 + save_as_len * CHAR_W;
    buf_fill_rect(cursor_x, input_y + 2, CHAR_W, CHAR_H, COLOR_BLACK);

    // Draw hint
    buf_draw_string(modal_x + 8, modal_y + 56, "Enter=Save  Esc=Cancel", COLOR_BLACK, COLOR_WHITE);
}

// Draw a line number right-aligned in the gutter
static void draw_line_number(int screen_row, int line_num) {
    char num_str[8];
    int n = line_num;
    int len = 0;

    // Convert number to string
    if (n == 0) {
        num_str[len++] = '0';
    } else {
        char tmp[8];
        int ti = 0;
        while (n > 0) {
            tmp[ti++] = '0' + (n % 10);
            n /= 10;
        }
        while (ti > 0) {
            num_str[len++] = tmp[--ti];
        }
    }
    num_str[len] = '\0';

    // Right-align: draw at (GUTTER_W - 8 - len * CHAR_W)
    int x = GUTTER_W - 8 - len * CHAR_W;
    int y = CONTENT_Y + screen_row * CHAR_H;
    buf_draw_string(x, y, num_str, COLOR_GUTTER_FG, COLOR_GUTTER_BG);
}

static void draw_all(void) {
    // Clear background (white)
    buf_fill_rect(0, 0, win_w, win_h, COLOR_WHITE);

    // Draw gutter background
    buf_fill_rect(0, 0, GUTTER_W, win_h, COLOR_GUTTER_BG);
    // Gutter separator line
    buf_fill_rect(GUTTER_W - 1, 0, 1, win_h, 0x00CCCCCC);

    // Draw border
    buf_fill_rect(0, 0, win_w, 1, COLOR_BLACK);
    buf_fill_rect(0, win_h - 1, win_w, 1, COLOR_BLACK);
    buf_fill_rect(0, 0, 1, win_h, COLOR_BLACK);
    buf_fill_rect(win_w - 1, 0, 1, win_h, COLOR_BLACK);

    // Get cursor line/col for scroll adjustment
    int cursor_line, cursor_col;
    cursor_to_line_col(cursor_pos, &cursor_line, &cursor_col);

    // Adjust scroll to keep cursor visible
    if (cursor_line < scroll_offset) {
        scroll_offset = cursor_line;
    } else if (cursor_line >= scroll_offset + visible_rows) {
        scroll_offset = cursor_line - visible_rows + 1;
    }

    // Draw line numbers for visible rows
    int total_lines = count_lines();
    for (int row = 0; row < visible_rows; row++) {
        int line_num = scroll_offset + row + 1;  // 1-indexed
        if (line_num <= total_lines) {
            draw_line_number(row, line_num);
        }
    }

    // Draw text with syntax highlighting
    int current_line = 0;
    int col = 0;

    // Syntax highlighting state
    int in_line_comment = 0;
    int in_block_comment = 0;
    int in_string = 0;
    char string_char = 0;

    for (int i = 0; i <= text_len; i++) {
        // Draw cursor
        if (i == cursor_pos && current_line >= scroll_offset && current_line < scroll_offset + visible_rows) {
            int cy = CONTENT_Y + (current_line - scroll_offset) * CHAR_H;
            int cx = CONTENT_X + col * CHAR_W;
            // Inverse block cursor
            buf_fill_rect(cx, cy, CHAR_W, CHAR_H, COLOR_BLACK);
            if (i < text_len && text_buffer[i] != '\n') {
                buf_draw_char(cx, cy, text_buffer[i], COLOR_WHITE, COLOR_BLACK);
            }
        }

        if (i >= text_len) break;

        char c = text_buffer[i];

        if (c == '\n') {
            in_line_comment = 0;
            current_line++;
            col = 0;
        } else {
            // Determine color for this character
            uint32_t fg_color = COLOR_BLACK;

            if (syntax_c) {
                // Check for comment start/end
                if (!in_string && !in_line_comment && !in_block_comment) {
                    if (c == '/' && i + 1 < text_len && text_buffer[i + 1] == '/') {
                        in_line_comment = 1;
                    } else if (c == '/' && i + 1 < text_len && text_buffer[i + 1] == '*') {
                        in_block_comment = 1;
                    }
                }

                // Check for string start
                if (!in_line_comment && !in_block_comment && !in_string) {
                    if (c == '"' || c == '\'') {
                        in_string = 1;
                        string_char = c;
                    }
                } else if (in_string && c == string_char) {
                    // Check for escape
                    if (i == 0 || text_buffer[i - 1] != '\\') {
                        // String ends after this char, color it as string
                        fg_color = COLOR_STRING;
                        // Draw this char, then reset
                        if (current_line >= scroll_offset && current_line < scroll_offset + visible_rows) {
                            if (i != cursor_pos) {
                                int cy = CONTENT_Y + (current_line - scroll_offset) * CHAR_H;
                                int cx = CONTENT_X + col * CHAR_W;
                                if (cx + CHAR_W <= win_w - CONTENT_X) {
                                    buf_draw_char(cx, cy, c, fg_color, COLOR_WHITE);
                                }
                            }
                        }
                        col++;
                        in_string = 0;
                        continue;
                    }
                }

                // Check for block comment end
                if (in_block_comment && c == '*' && i + 1 < text_len && text_buffer[i + 1] == '/') {
                    // Will end after next char
                }
                if (in_block_comment && i > 0 && text_buffer[i - 1] == '*' && c == '/') {
                    in_block_comment = 0;
                }

                // Set color based on state
                if (in_line_comment || in_block_comment) {
                    fg_color = COLOR_COMMENT;
                } else if (in_string) {
                    fg_color = COLOR_STRING;
                } else {
                    // Check for keywords
                    int is_word_start = (i == 0 || !((text_buffer[i-1] >= 'a' && text_buffer[i-1] <= 'z') ||
                                                     (text_buffer[i-1] >= 'A' && text_buffer[i-1] <= 'Z') ||
                                                     (text_buffer[i-1] >= '0' && text_buffer[i-1] <= '9') ||
                                                     text_buffer[i-1] == '_'));
                    if (is_word_start && ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_')) {
                        // Extract word
                        char word[32];
                        int wi = 0;
                        for (int j = i; j < text_len && wi < 31; j++) {
                            char wc = text_buffer[j];
                            if ((wc >= 'a' && wc <= 'z') || (wc >= 'A' && wc <= 'Z') ||
                                (wc >= '0' && wc <= '9') || wc == '_') {
                                word[wi++] = wc;
                            } else {
                                break;
                            }
                        }
                        word[wi] = '\0';

                        // Check if it's a keyword
                        for (int k = 0; c_keywords[k]; k++) {
                            if (strcmp(word, c_keywords[k]) == 0) {
                                fg_color = COLOR_KEYWORD;
                                break;
                            }
                        }
                    }

                    // Check for numbers
                    if (c >= '0' && c <= '9') {
                        int is_num_start = (i == 0 || !((text_buffer[i-1] >= 'a' && text_buffer[i-1] <= 'z') ||
                                                        (text_buffer[i-1] >= 'A' && text_buffer[i-1] <= 'Z') ||
                                                        text_buffer[i-1] == '_'));
                        if (is_num_start) {
                            fg_color = COLOR_NUMBER;
                        }
                    }
                }
            }

            // Only draw if in visible area and not at cursor (cursor already drawn)
            if (current_line >= scroll_offset && current_line < scroll_offset + visible_rows) {
                if (i != cursor_pos) {
                    int cy = CONTENT_Y + (current_line - scroll_offset) * CHAR_H;
                    int cx = CONTENT_X + col * CHAR_W;
                    if (cx + CHAR_W <= win_w - CONTENT_X) {
                        buf_draw_char(cx, cy, c, fg_color, COLOR_WHITE);
                    }
                }
            }
            col++;
        }
    }

    // Draw status bar at bottom
    int status_y = win_h - CHAR_H - 2;
    buf_fill_rect(1, status_y - 1, win_w - 2, CHAR_H + 2, 0x00DDDDDD);

    // Status text: filename and position
    char status[64];
    int si = 0;

    // Save failed indicator
    if (save_failed) {
        const char *err = "[No filename] ";
        for (int i = 0; err[i]; i++) status[si++] = err[i];
    }

    // Modified indicator
    if (modified) {
        status[si++] = '*';
    }

    // Filename
    const char *fname = current_file[0] ? current_file : "untitled";
    for (int i = 0; fname[i] && si < 40; i++) {
        status[si++] = fname[i];
    }

    status[si++] = ' ';
    status[si++] = '-';
    status[si++] = ' ';
    status[si++] = 'L';

    // Line number
    char num[8];
    int n = cursor_line + 1;
    int ni = 0;
    if (n == 0) {
        num[ni++] = '0';
    } else {
        char tmp[8];
        int ti = 0;
        while (n > 0) {
            tmp[ti++] = '0' + (n % 10);
            n /= 10;
        }
        while (ti > 0) {
            num[ni++] = tmp[--ti];
        }
    }
    for (int i = 0; i < ni && si < 60; i++) {
        status[si++] = num[i];
    }

    status[si++] = ':';

    // Column number
    n = cursor_col + 1;
    ni = 0;
    if (n == 0) {
        num[ni++] = '0';
    } else {
        char tmp[8];
        int ti = 0;
        while (n > 0) {
            tmp[ti++] = '0' + (n % 10);
            n /= 10;
        }
        while (ti > 0) {
            num[ni++] = tmp[--ti];
        }
    }
    for (int i = 0; i < ni && si < 63; i++) {
        status[si++] = num[i];
    }

    status[si] = '\0';

    buf_draw_string(4, status_y, status, COLOR_BLACK, 0x00DDDDDD);

    // Draw Save As modal if active
    if (save_as_mode) {
        draw_save_as_modal();
    }

    api->window_invalidate(window_id);
}

// ============ Input Handling ============

static void handle_save_as_key(int key) {
    switch (key) {
        case '\r':
        case '\n':
            // Confirm save
            if (save_as_len > 0) {
                save_as_buf[save_as_len] = '\0';
                do_save(save_as_buf);
                save_as_mode = 0;
            }
            break;

        case 0x1B: // Escape - cancel
            save_as_mode = 0;
            break;

        case 8: // Backspace
            if (save_as_len > 0) {
                save_as_len--;
                save_as_buf[save_as_len] = '\0';
            }
            break;

        default:
            // Add printable characters
            if (key >= 32 && key < 127 && save_as_len < 250) {
                save_as_buf[save_as_len++] = (char)key;
                save_as_buf[save_as_len] = '\0';
            }
            break;
    }
}

static void handle_key(int key) {
    // If Save As modal is open, handle those keys
    if (save_as_mode) {
        handle_save_as_key(key);
        return;
    }

    int line, col;

    switch (key) {
        case '\r':
        case '\n':
            insert_char('\n');
            break;

        case 8:   // Backspace
            delete_char_before();
            break;

        case 0x106: // Delete key
            delete_char_at();
            break;

        case 0x1B: // Escape - could use for menu later
            break;

        case '\t': // Tab - insert 4 spaces
            insert_char(' ');
            insert_char(' ');
            insert_char(' ');
            insert_char(' ');
            break;

        // Arrow keys (special codes from keyboard driver)
        case 0x100: // Up
            cursor_to_line_col(cursor_pos, &line, &col);
            if (line > 0) {
                cursor_pos = line_col_to_cursor(line - 1, col);
            }
            break;

        case 0x101: // Down
            cursor_to_line_col(cursor_pos, &line, &col);
            cursor_pos = line_col_to_cursor(line + 1, col);
            if (cursor_pos > text_len) cursor_pos = text_len;
            break;

        case 0x102: // Left
            if (cursor_pos > 0) cursor_pos--;
            break;

        case 0x103: // Right
            if (cursor_pos < text_len) cursor_pos++;
            break;

        case 0x104: // Home
            cursor_pos = line_start(cursor_pos);
            break;

        case 0x105: // End
            cursor_pos = line_end(cursor_pos);
            break;

        case 19: // Ctrl+S
            save_file();
            break;

        default:
            if (key >= 32 && key < 127) {
                char c = (char)key;

                // Auto-close brackets and quotes
                char close_char = 0;
                switch (c) {
                    case '(': close_char = ')'; break;
                    case '[': close_char = ']'; break;
                    case '{': close_char = '}'; break;
                    case '"': close_char = '"'; break;
                    case '\'': close_char = '\''; break;
                }

                if (close_char) {
                    insert_char(c);
                    insert_char(close_char);
                    cursor_pos--;  // Move cursor between the pair
                } else {
                    insert_char(c);
                }
            }
            break;
    }
}

// ============ Main ============

int main(kapi_t *kapi, int argc, char **argv) {
    api = kapi;

    // Initialize
    text_len = 0;
    cursor_pos = 0;
    scroll_offset = 0;
    modified = 0;
    current_file[0] = '\0';

    // Load file if specified
    if (argc > 1) {
        // Copy filename
        int i;
        for (i = 0; argv[1][i] && i < 255; i++) {
            current_file[i] = argv[1][i];
        }
        current_file[i] = '\0';
        load_file(current_file);
    }

    // Check for window API
    if (!api->window_create) {
        api->puts("textedit: window API not available (run from desktop)\n");
        return 1;
    }

    // Create window
    const char *title = current_file[0] ? current_file : "TextEdit";
    window_id = api->window_create(50, 50, WINDOW_W, WINDOW_H + TITLE_BAR_H, title);
    if (window_id < 0) {
        api->puts("textedit: failed to create window\n");
        return 1;
    }

    // Get buffer
    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buffer) {
        api->puts("textedit: failed to get window buffer\n");
        api->window_destroy(window_id);
        return 1;
    }

    // Initialize graphics context
    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);

    // Calculate visible area
    visible_cols = (win_w - CONTENT_X * 2) / CHAR_W;
    visible_rows = (win_h - CONTENT_Y * 2 - CHAR_H - 4) / CHAR_H;  // Account for status bar

    // Initial draw
    draw_all();

    // Event loop
    int running = 1;
    while (running) {
        int event_type, data1, data2, data3;
        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;

                case WIN_EVENT_KEY:
                    handle_key(data1);
                    draw_all();
                    break;

                case WIN_EVENT_RESIZE:
                    // Re-fetch buffer with new dimensions
                    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
                    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);
                    // Recalculate visible area
                    visible_cols = (win_w - CONTENT_X * 2) / CHAR_W;
                    visible_rows = (win_h - CONTENT_Y * 2 - CHAR_H - 4) / CHAR_H;
                    draw_all();
                    break;
            }
        }

        // Yield to other processes
        api->yield();
    }

    api->window_destroy(window_id);
    return 0;
}
</file>

<file path="user/bin/vibesh.c">
/*
 * vibesh - VibeOS Shell
 *
 * A userspace shell for VibeOS with readline-like editing.
 *
 * Features:
 *   - Command history (up/down arrows)
 *   - !! to repeat last command
 *   - Ctrl+U: Clear line before cursor
 *   - Ctrl+D: Exit shell (EOF)
 *   - Ctrl+L: Clear screen
 *   - Ctrl+C: Clear current line
 *   - Ctrl+R: Reverse search history
 *   - Tab: Command/path completion
 *
 * Builtins:
 *   cd <dir>    - Change directory
 *   exit        - Exit shell
 *   help        - Show help
 *   clear       - Clear screen
 */

#include "../lib/vibe.h"

// Shell limits
#define CMD_MAX     256
#define MAX_ARGS    16
#define PATH_MAX    256
#define HISTORY_SIZE 50

// Global API pointer
static kapi_t *k;

// Command buffer
static char cmd_buf[CMD_MAX];
static int cmd_pos;
static int cmd_len;  // Total length of command (for cursor movement)

// History
static char history[HISTORY_SIZE][CMD_MAX];
static int history_count = 0;
static int history_pos = 0;  // Current position when browsing history

// Reverse search state
static int search_mode = 0;
static char search_buf[CMD_MAX];
static int search_pos = 0;
static int search_match = -1;  // Index in history of current match

// ============ I/O Helpers (use stdio hooks if available) ============

static void sh_putc(char c) {
    if (k->stdio_putc) {
        k->stdio_putc(c);
    } else {
        k->putc(c);
    }
}

static void sh_puts(const char *s) {
    if (k->stdio_puts) {
        k->stdio_puts(s);
    } else {
        k->puts(s);
    }
}

static int sh_getc(void) {
    if (k->stdio_getc) {
        return k->stdio_getc();
    } else {
        return k->getc();
    }
}

static int sh_has_key(void) {
    if (k->stdio_has_key) {
        return k->stdio_has_key();
    } else {
        return k->has_key();
    }
}

static void sh_set_color(uint32_t fg, uint32_t bg) {
    // Only set color for console (not for terminal - it's B&W)
    if (!k->stdio_putc) {
        k->set_color(fg, bg);
    }
}

static void sh_clear(void) {
    if (!k->stdio_putc) {
        k->clear();
    } else {
        // For terminal, send clear escape or just print newlines
        // We'll have terminal handle \f (form feed) as clear
        sh_putc('\f');
    }
}

// ============ History Management ============

static void history_add(const char *cmd) {
    if (!cmd[0]) return;  // Don't add empty commands

    // Don't add duplicates of the last command
    if (history_count > 0 && strcmp(history[history_count - 1], cmd) == 0) {
        return;
    }

    // Add to history
    if (history_count < HISTORY_SIZE) {
        strncpy_safe(history[history_count], cmd, CMD_MAX);
        history_count++;
    } else {
        // Shift everything up and add at the end
        for (int i = 0; i < HISTORY_SIZE - 1; i++) {
            strncpy_safe(history[i], history[i + 1], CMD_MAX);
        }
        strncpy_safe(history[HISTORY_SIZE - 1], cmd, CMD_MAX);
    }
}

static const char *history_get(int index) {
    if (index < 0 || index >= history_count) return NULL;
    return history[index];
}

// Search history backwards for a match
static int history_search(const char *pattern, int start_from) {
    if (!pattern[0]) return -1;

    for (int i = start_from; i >= 0; i--) {
        // Check if pattern is a substring of history[i]
        const char *h = history[i];
        const char *p = pattern;
        const char *found = NULL;

        for (const char *s = h; *s; s++) {
            if (*s == *p) {
                if (!found) found = s;
                p++;
                if (!*p) break;  // Found complete match
            } else if (found) {
                // Reset search
                found = NULL;
                p = pattern;
            }
        }

        if (found && !*p) {
            return i;  // Found match
        }
    }
    return -1;
}

// ============ Line Editing ============

// Redraw the current line from cursor position
static void redraw_from_cursor(void) {
    // Print from cmd_pos to end
    for (int i = cmd_pos; i < cmd_len; i++) {
        sh_putc(cmd_buf[i]);
    }
    // Clear any leftover characters and move cursor back
    sh_putc(' ');
    for (int i = cmd_len; i >= cmd_pos; i--) {
        sh_putc('\b');
    }
}

// Clear the current line display and redraw
static void redraw_line(const char *prompt) {
    // Move to start of line
    sh_putc('\r');
    // Print prompt
    sh_puts(prompt);
    // Print command
    for (int i = 0; i < cmd_len; i++) {
        sh_putc(cmd_buf[i]);
    }
    // Clear rest of line (in case old content was longer)
    for (int i = 0; i < 10; i++) sh_putc(' ');
    for (int i = 0; i < 10; i++) sh_putc('\b');
    // Move cursor to correct position
    for (int i = cmd_len; i > cmd_pos; i--) {
        sh_putc('\b');
    }
}

// Clear line contents (Ctrl+U behavior)
static void clear_line(void) {
    // Move cursor to start
    while (cmd_pos > 0) {
        sh_putc('\b');
        cmd_pos--;
    }
    // Clear display
    for (int i = 0; i < cmd_len; i++) {
        sh_putc(' ');
    }
    for (int i = 0; i < cmd_len; i++) {
        sh_putc('\b');
    }
    cmd_len = 0;
    cmd_buf[0] = '\0';
}

// Set line to a string (for history navigation)
static void set_line(const char *str, const char *prompt) {
    clear_line();
    strncpy_safe(cmd_buf, str, CMD_MAX);
    cmd_len = strlen(cmd_buf);
    cmd_pos = cmd_len;
    // Redraw
    redraw_line(prompt);
}

// ============ Tab Completion ============

// Find common prefix length of two strings
static int common_prefix(const char *a, const char *b) {
    int i = 0;
    while (a[i] && b[i] && a[i] == b[i]) i++;
    return i;
}

static void do_tab_completion(const char *prompt) {
    // Find the word being completed
    int word_start = cmd_pos;
    while (word_start > 0 && cmd_buf[word_start - 1] != ' ') {
        word_start--;
    }

    char word[PATH_MAX];
    int word_len = cmd_pos - word_start;
    for (int i = 0; i < word_len && i < PATH_MAX - 1; i++) {
        word[i] = cmd_buf[word_start + i];
    }
    word[word_len] = '\0';

    // Determine if this is a path or command completion
    int is_path = (word[0] == '/' || word[0] == '.' || word_start > 0);

    // Get directory and prefix to match
    char dir_path[PATH_MAX];
    char prefix[PATH_MAX];

    if (is_path) {
        // Find last /
        int last_slash = -1;
        for (int i = 0; word[i]; i++) {
            if (word[i] == '/') last_slash = i;
        }

        if (last_slash >= 0) {
            // Copy directory part
            for (int i = 0; i <= last_slash; i++) {
                dir_path[i] = word[i];
            }
            dir_path[last_slash + 1] = '\0';
            // Copy prefix part
            strcpy(prefix, word + last_slash + 1);
        } else {
            // Current directory
            k->get_cwd(dir_path, PATH_MAX);
            strcpy(prefix, word);
        }
    } else {
        // Command completion - look in /bin
        strcpy(dir_path, "/bin");
        strcpy(prefix, word);
    }

    // Open directory
    void *dir = k->open(dir_path);
    if (!dir || !k->is_dir(dir)) return;

    // Find matches
    char matches[10][PATH_MAX];  // Up to 10 matches
    int match_count = 0;
    int prefix_len = strlen(prefix);

    char name[256];
    uint8_t type;
    int idx = 0;

    while (match_count < 10 && k->readdir(dir, idx, name, sizeof(name), &type) == 0) {
        idx++;
        if (name[0] == '.') continue;  // Skip hidden files

        // Check if name starts with prefix
        if (strncmp(name, prefix, prefix_len) == 0) {
            strcpy(matches[match_count], name);
            match_count++;
        }
    }

    if (match_count == 0) {
        return;  // No matches
    }

    if (match_count == 1) {
        // Single match - complete it
        const char *match = matches[0];
        int match_len = strlen(match);

        // Insert the rest of the match
        for (int i = prefix_len; i < match_len; i++) {
            if (cmd_len < CMD_MAX - 1) {
                // Shift rest of line right
                for (int j = cmd_len; j >= cmd_pos; j--) {
                    cmd_buf[j + 1] = cmd_buf[j];
                }
                cmd_buf[cmd_pos] = match[i];
                cmd_pos++;
                cmd_len++;
                sh_putc(match[i]);
            }
        }

        // Add trailing / for directories or space for files/commands
        // Check if it's a directory
        char full_path[PATH_MAX];
        strcpy(full_path, dir_path);
        if (full_path[strlen(full_path) - 1] != '/') strcat(full_path, "/");
        strcat(full_path, match);
        void *node = k->open(full_path);

        char suffix = (node && k->is_dir(node)) ? '/' : ' ';
        if (cmd_len < CMD_MAX - 1) {
            for (int j = cmd_len; j >= cmd_pos; j--) {
                cmd_buf[j + 1] = cmd_buf[j];
            }
            cmd_buf[cmd_pos] = suffix;
            cmd_pos++;
            cmd_len++;
            sh_putc(suffix);
        }

        redraw_from_cursor();
    } else {
        // Multiple matches - complete common prefix and show options

        // Find common prefix
        int common = strlen(matches[0]);
        for (int i = 1; i < match_count; i++) {
            int c = common_prefix(matches[0], matches[i]);
            if (c < common) common = c;
        }

        // Insert common prefix beyond what's typed
        for (int i = prefix_len; i < common; i++) {
            if (cmd_len < CMD_MAX - 1) {
                for (int j = cmd_len; j >= cmd_pos; j--) {
                    cmd_buf[j + 1] = cmd_buf[j];
                }
                cmd_buf[cmd_pos] = matches[0][i];
                cmd_pos++;
                cmd_len++;
                sh_putc(matches[0][i]);
            }
        }

        // Show all matches
        sh_putc('\n');
        for (int i = 0; i < match_count; i++) {
            sh_puts(matches[i]);
            sh_puts("  ");
        }
        sh_putc('\n');

        // Redraw prompt and line
        redraw_line(prompt);
    }
}

// ============ Command Parsing ============

// Parse command line into argc/argv
static int parse_command(char *cmd, char *argv[], int max_args) {
    int argc = 0;
    char *p = cmd;

    while (*p && argc < max_args) {
        // Skip whitespace
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        if (*p == '\0') break;

        // Found start of argument
        argv[argc++] = p;

        // Find end of argument
        while (*p && *p != ' ' && *p != '\t') {
            p++;
        }

        // Null-terminate this argument
        if (*p) {
            *p++ = '\0';
        }
    }

    return argc;
}

// Build prompt string
static void get_prompt(char *prompt_buf, int size) {
    char cwd[PATH_MAX];
    k->get_cwd(cwd, PATH_MAX);

    // Simple prompt: "cwd $ "
    int i = 0;
    for (int j = 0; cwd[j] && i < size - 4; j++) {
        prompt_buf[i++] = cwd[j];
    }
    prompt_buf[i++] = ' ';
    prompt_buf[i++] = '$';
    prompt_buf[i++] = ' ';
    prompt_buf[i] = '\0';
}

// Print the shell prompt with colors
static void print_prompt(void) {
    char cwd[PATH_MAX];
    k->get_cwd(cwd, PATH_MAX);

    sh_set_color(COLOR_CYAN, COLOR_BLACK);
    sh_puts(cwd);
    sh_set_color(COLOR_WHITE, COLOR_BLACK);
    sh_puts(" $ ");
}

// ============ Builtins ============

static int builtin_cd(int argc, char *argv[]) {
    if (argc < 2) {
        if (k->set_cwd("/home/user") < 0) {
            sh_set_color(COLOR_RED, COLOR_BLACK);
            sh_puts("cd: failed\n");
            sh_set_color(COLOR_WHITE, COLOR_BLACK);
            return 1;
        }
    } else {
        if (k->set_cwd(argv[1]) < 0) {
            sh_set_color(COLOR_RED, COLOR_BLACK);
            sh_puts("cd: ");
            sh_puts(argv[1]);
            sh_puts(": No such directory\n");
            sh_set_color(COLOR_WHITE, COLOR_BLACK);
            return 1;
        }
    }
    return 0;
}

static void builtin_help(void) {
    sh_puts("vibesh - VibeOS Shell\n\n");
    sh_puts("Builtins:\n");
    sh_puts("  cd <dir>    Change directory\n");
    sh_puts("  exit        Exit shell\n");
    sh_puts("  clear       Clear screen\n");
    sh_puts("  help        Show this help\n");
    sh_puts("\nLine editing:\n");
    sh_puts("  Up/Down     Browse command history\n");
    sh_puts("  Tab         Complete command or path\n");
    sh_puts("  Ctrl+C      Clear current line\n");
    sh_puts("  Ctrl+U      Clear line before cursor\n");
    sh_puts("  Ctrl+L      Clear screen\n");
    sh_puts("  Ctrl+R      Reverse search history\n");
    sh_puts("  Ctrl+D      Exit shell\n");
    sh_puts("  !!          Repeat last command\n");
    sh_puts("\nExternal commands in /bin:\n");
    sh_puts("  echo, ls, cat, pwd, mkdir, touch, rm, ...\n");
}

// ============ Command Execution ============

static int exec_external(int argc, char *argv[]) {
    char path[PATH_MAX];

    if (argv[0][0] == '/' || argv[0][0] == '.') {
        strncpy_safe(path, argv[0], PATH_MAX);
    } else {
        strcpy(path, "/bin/");
        strcat(path, argv[0]);
    }

    void *file = k->open(path);
    if (!file) {
        sh_set_color(COLOR_RED, COLOR_BLACK);
        sh_puts(argv[0]);
        sh_puts(": command not found\n");
        sh_set_color(COLOR_WHITE, COLOR_BLACK);
        return 127;
    }

    int result = k->exec_args(path, argc, argv);
    return result;
}

static int execute_command(char *cmd) {
    // Handle !! expansion
    if (cmd[0] == '!' && cmd[1] == '!') {
        if (history_count == 0) {
            sh_puts("!!: no previous command\n");
            return 1;
        }
        // Replace !! with last command
        char expanded[CMD_MAX];
        strncpy_safe(expanded, history[history_count - 1], CMD_MAX);
        // Append anything after !!
        if (cmd[2]) {
            strcat(expanded, cmd + 2);
        }
        strncpy_safe(cmd, expanded, CMD_MAX);
        // Show what we're running
        sh_puts(cmd);
        sh_putc('\n');
    }

    char *argv[MAX_ARGS];
    int argc = parse_command(cmd, argv, MAX_ARGS);

    if (argc == 0) {
        return 0;
    }

    // Builtins
    if (strcmp(argv[0], "cd") == 0) {
        return builtin_cd(argc, argv);
    }

    if (strcmp(argv[0], "exit") == 0) {
        return -1;  // Signal to exit
    }

    if (strcmp(argv[0], "help") == 0) {
        builtin_help();
        return 0;
    }

    if (strcmp(argv[0], "clear") == 0) {
        sh_clear();
        return 0;
    }

    return exec_external(argc, argv);
}

// ============ Input Handling ============

static int read_line(void) {
    cmd_pos = 0;
    cmd_len = 0;
    cmd_buf[0] = '\0';
    history_pos = history_count;  // Start at end of history
    search_mode = 0;

    char prompt[PATH_MAX + 8];
    get_prompt(prompt, sizeof(prompt));

    while (1) {
        int c = sh_getc();

        if (c < 0) {
            k->yield();
            continue;
        }

        // Handle reverse search mode
        if (search_mode) {
            if (c == '\r' || c == '\n') {
                // Accept the match
                search_mode = 0;
                sh_putc('\n');
                return 0;
            } else if (c == 27 || c == 3) {  // Escape or Ctrl+C
                // Cancel search
                search_mode = 0;
                clear_line();
                sh_putc('\r');
                print_prompt();
                continue;
            } else if (c == 18) {  // Ctrl+R again - search further back
                if (search_match > 0) {
                    search_match = history_search(search_buf, search_match - 1);
                    if (search_match >= 0) {
                        strncpy_safe(cmd_buf, history[search_match], CMD_MAX);
                        cmd_len = strlen(cmd_buf);
                        cmd_pos = cmd_len;
                    }
                }
                // Redraw search line
                sh_putc('\r');
                sh_puts("(reverse-i-search)`");
                sh_puts(search_buf);
                sh_puts("': ");
                sh_puts(cmd_buf);
                sh_puts("   ");  // Clear extra
                continue;
            } else if (c == '\b' || c == 127) {  // Backspace
                if (search_pos > 0) {
                    search_pos--;
                    search_buf[search_pos] = '\0';
                    // Re-search
                    search_match = history_search(search_buf, history_count - 1);
                    if (search_match >= 0) {
                        strncpy_safe(cmd_buf, history[search_match], CMD_MAX);
                        cmd_len = strlen(cmd_buf);
                        cmd_pos = cmd_len;
                    } else {
                        cmd_buf[0] = '\0';
                        cmd_len = 0;
                        cmd_pos = 0;
                    }
                }
                // Redraw
                sh_putc('\r');
                sh_puts("(reverse-i-search)`");
                sh_puts(search_buf);
                sh_puts("': ");
                sh_puts(cmd_buf);
                sh_puts("      ");
                continue;
            } else if (c >= 32 && c < 127) {
                // Add to search
                if (search_pos < CMD_MAX - 1) {
                    search_buf[search_pos++] = c;
                    search_buf[search_pos] = '\0';
                    // Search
                    search_match = history_search(search_buf, history_count - 1);
                    if (search_match >= 0) {
                        strncpy_safe(cmd_buf, history[search_match], CMD_MAX);
                        cmd_len = strlen(cmd_buf);
                        cmd_pos = cmd_len;
                    }
                }
                // Redraw
                sh_putc('\r');
                sh_puts("(reverse-i-search)`");
                sh_puts(search_buf);
                sh_puts("': ");
                sh_puts(cmd_buf);
                sh_puts("   ");
                continue;
            }
            continue;
        }

        // Normal mode
        if (c == '\r' || c == '\n') {
            sh_putc('\n');
            cmd_buf[cmd_len] = '\0';
            return 0;
        }

        // Ctrl+C - clear line
        if (c == 3) {
            sh_puts("^C\n");
            print_prompt();
            cmd_pos = 0;
            cmd_len = 0;
            cmd_buf[0] = '\0';
            continue;
        }

        // Ctrl+D - exit (EOF)
        if (c == 4) {
            if (cmd_len == 0) {
                sh_puts("exit\n");
                strcpy(cmd_buf, "exit");
                return 0;
            }
            // If there's content, Ctrl+D does nothing (or could delete char)
            continue;
        }

        // Ctrl+L - clear screen
        if (c == 12) {
            sh_clear();
            print_prompt();
            for (int i = 0; i < cmd_len; i++) {
                sh_putc(cmd_buf[i]);
            }
            for (int i = cmd_len; i > cmd_pos; i--) {
                sh_putc('\b');
            }
            continue;
        }

        // Ctrl+U - clear line before cursor
        if (c == 21) {
            // Delete from start to cursor
            int to_delete = cmd_pos;
            if (to_delete > 0) {
                // Move cursor to start
                for (int i = 0; i < cmd_pos; i++) {
                    sh_putc('\b');
                }
                // Shift remaining content
                for (int i = cmd_pos; i <= cmd_len; i++) {
                    cmd_buf[i - to_delete] = cmd_buf[i];
                }
                cmd_len -= to_delete;
                cmd_pos = 0;
                // Redraw
                for (int i = 0; i < cmd_len; i++) {
                    sh_putc(cmd_buf[i]);
                }
                // Clear old chars
                for (int i = 0; i < to_delete; i++) {
                    sh_putc(' ');
                }
                // Move back
                for (int i = 0; i < cmd_len + to_delete; i++) {
                    sh_putc('\b');
                }
            }
            continue;
        }

        // Ctrl+R - reverse search
        if (c == 18) {
            search_mode = 1;
            search_pos = 0;
            search_buf[0] = '\0';
            search_match = -1;
            sh_putc('\r');
            sh_puts("(reverse-i-search)`': ");
            // Clear rest of line
            for (int i = 0; i < 40; i++) sh_putc(' ');
            for (int i = 0; i < 40; i++) sh_putc('\b');
            continue;
        }

        // Tab - completion
        if (c == '\t') {
            do_tab_completion(prompt);
            continue;
        }

        // Backspace
        if (c == '\b' || c == 127) {
            if (cmd_pos > 0) {
                cmd_pos--;
                // Shift everything after cursor left
                for (int i = cmd_pos; i < cmd_len; i++) {
                    cmd_buf[i] = cmd_buf[i + 1];
                }
                cmd_len--;
                sh_putc('\b');
                redraw_from_cursor();
            }
            continue;
        }

        // Arrow keys (special codes >= 0x100)
        if (c == KEY_UP) {
            // Go back in history
            if (history_pos > 0) {
                history_pos--;
                set_line(history[history_pos], prompt);
            }
            continue;
        }

        if (c == KEY_DOWN) {
            // Go forward in history
            if (history_pos < history_count - 1) {
                history_pos++;
                set_line(history[history_pos], prompt);
            } else if (history_pos == history_count - 1) {
                history_pos = history_count;
                set_line("", prompt);
            }
            continue;
        }

        if (c == KEY_LEFT) {
            if (cmd_pos > 0) {
                cmd_pos--;
                sh_putc('\b');
            }
            continue;
        }

        if (c == KEY_RIGHT) {
            if (cmd_pos < cmd_len) {
                sh_putc(cmd_buf[cmd_pos]);
                cmd_pos++;
            }
            continue;
        }

        if (c == KEY_HOME) {
            while (cmd_pos > 0) {
                sh_putc('\b');
                cmd_pos--;
            }
            continue;
        }

        if (c == KEY_END) {
            while (cmd_pos < cmd_len) {
                sh_putc(cmd_buf[cmd_pos]);
                cmd_pos++;
            }
            continue;
        }

        if (c == KEY_DELETE) {
            // Delete character under cursor
            if (cmd_pos < cmd_len) {
                for (int i = cmd_pos; i < cmd_len; i++) {
                    cmd_buf[i] = cmd_buf[i + 1];
                }
                cmd_len--;
                redraw_from_cursor();
            }
            continue;
        }

        // Escape - ignore (could handle escape sequences later)
        if (c == 27) {
            continue;
        }

        // Regular character
        if (c >= 32 && c < 127 && cmd_len < CMD_MAX - 1) {
            // Insert at cursor position
            for (int i = cmd_len; i >= cmd_pos; i--) {
                cmd_buf[i + 1] = cmd_buf[i];
            }
            cmd_buf[cmd_pos] = (char)c;
            cmd_pos++;
            cmd_len++;

            // Redraw from cursor
            for (int i = cmd_pos - 1; i < cmd_len; i++) {
                sh_putc(cmd_buf[i]);
            }
            // Move cursor back to position
            for (int i = cmd_len; i > cmd_pos; i--) {
                sh_putc('\b');
            }
        }
    }
}

// ============ Main ============

int main(kapi_t *api, int argc, char **argv) {
    (void)argc;
    (void)argv;

    k = api;

    // Print banner
    sh_set_color(COLOR_GREEN, COLOR_BLACK);
    sh_puts("vibesh ");
    sh_set_color(COLOR_WHITE, COLOR_BLACK);
    sh_puts("- VibeOS Shell\n");
    sh_puts("Type 'help' for commands.\n\n");

    // Main loop
    while (1) {
        print_prompt();

        if (read_line() < 0) {
            break;
        }

        // Add to history before executing
        if (cmd_buf[0] && !(cmd_buf[0] == '!' && cmd_buf[1] == '!')) {
            history_add(cmd_buf);
        }

        int result = execute_command(cmd_buf);

        // If !! was used, add the expanded command to history
        if (cmd_buf[0] && cmd_buf[0] != '!') {
            // Already added or will be added next iteration
        }

        if (result == -1) {
            break;
        }
    }

    sh_puts("Goodbye!\n");
    return 0;
}
</file>

<file path="linker.ld">
/*
 * VibeOS Linker Script
 *
 * Memory layout for QEMU virt machine (aarch64)
 * Using -bios mode: flash starts at 0x0, RAM at 0x40000000
 * We boot at EL3 with full hardware access
 *
 * Code runs from flash (0x0), data/BSS in RAM
 *
 * IMPORTANT: QEMU places the DTB at 0x40000000 (start of RAM).
 * We start our RAM usage at 0x40010000 to preserve the DTB.
 * DTB is typically ~8-16KB, so 64KB buffer is plenty.
 */

ENTRY(_start)

MEMORY
{
    FLASH (rx)  : ORIGIN = 0x00000000, LENGTH = 64M
    /* Skip first 2MB of RAM - that's where the DTB lives (can be up to 1MB+) */
    RAM   (rwx) : ORIGIN = 0x40200000, LENGTH = 256M - 2M
}

SECTIONS
{
    /* Boot code at start of flash */
    .text.boot : {
        *(.text.boot)
    } > FLASH

    /* Rest of code in flash */
    .text : {
        *(.text)
        *(.text.*)
    } > FLASH

    /* Read-only data in flash */
    .rodata : ALIGN(8) {
        *(.rodata)
        *(.rodata.*)
    } > FLASH

    /* End of flash content - save for data copy (must be 8-byte aligned for ldr) */
    . = ALIGN(8);
    _data_load = .;

    /* Initialized data - loaded from flash, runs in RAM */
    .data : AT(_data_load) {
        _data_start = .;
        *(.data)
        *(.data.*)
        _data_end = .;
    } > RAM

    /* BSS section (uninitialized data) in RAM */
    .bss : {
        _bss_start = .;
        *(.bss)
        *(.bss.*)
        *(COMMON)
        _bss_end = .;
    } > RAM

    /* Discard unneeded sections */
    /DISCARD/ : {
        *(.comment)
        *(.note.*)
        *(.eh_frame)
        *(.stack)
    }
}
</file>

<file path="user/bin/calc.c">
/*
 * VibeOS Calculator
 *
 * Floating-point calculator that runs in a desktop window.
 * Uses the window API to create and manage its window.
 */

#include "vibe.h"
#include "../lib/gfx.h"

static kapi_t *api;
static int window_id = -1;
static uint32_t *win_buffer;
static int win_w, win_h;
static gfx_ctx_t gfx;

// Calculator state - now using doubles!
static double display_value = 0.0;
static double pending_value = 0.0;
static char pending_op = 0;
static int clear_on_digit = 0;
static int has_decimal = 0;      // Are we entering decimal digits?
static double decimal_place = 0.1;  // Current decimal place (0.1, 0.01, etc.)

// Button layout
#define BTN_W 40
#define BTN_H 30
#define BTN_PAD 4
#define DISPLAY_H 30

static const char button_labels[4][4][3] = {
    { "7", "8", "9", "/" },
    { "4", "5", "6", "*" },
    { "1", "2", "3", "-" },
    { ".", "0", "=", "+" }
};

// ============ Drawing Helpers (macros wrapping gfx lib) ============

#define buf_fill_rect(x, y, w, h, c)     gfx_fill_rect(&gfx, x, y, w, h, c)
#define buf_draw_char(x, y, ch, fg, bg)  gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define buf_draw_string(x, y, s, fg, bg) gfx_draw_string(&gfx, x, y, s, fg, bg)
#define buf_draw_rect(x, y, w, h, c)     gfx_draw_rect(&gfx, x, y, w, h, c)

// ============ Float to String ============

// Simple float to string conversion (no sprintf with %f available)
static void float_to_str(double val, char *buf, int buf_size) {
    int idx = 0;

    // Handle negative
    if (val < 0) {
        buf[idx++] = '-';
        val = -val;
    }

    // Get integer part
    long long int_part = (long long)val;
    double frac_part = val - (double)int_part;

    // Convert integer part
    char int_buf[20];
    int int_idx = 0;
    if (int_part == 0) {
        int_buf[int_idx++] = '0';
    } else {
        while (int_part > 0 && int_idx < 19) {
            int_buf[int_idx++] = '0' + (int_part % 10);
            int_part /= 10;
        }
    }

    // Reverse integer part into buffer
    while (int_idx > 0 && idx < buf_size - 1) {
        buf[idx++] = int_buf[--int_idx];
    }

    // Add decimal point and fractional part (up to 6 digits)
    if (frac_part > 0.0000001 && idx < buf_size - 8) {
        buf[idx++] = '.';

        int frac_digits = 0;
        while (frac_part > 0.0000001 && frac_digits < 6 && idx < buf_size - 1) {
            frac_part *= 10;
            int digit = (int)frac_part;
            buf[idx++] = '0' + digit;
            frac_part -= digit;
            frac_digits++;
        }

        // Remove trailing zeros
        while (idx > 0 && buf[idx-1] == '0') {
            idx--;
        }
        // Remove decimal point if no fractional digits
        if (idx > 0 && buf[idx-1] == '.') {
            idx--;
        }
    }

    buf[idx] = '\0';
}

// ============ Drawing ============

static void draw_display(void) {
    // Display background
    buf_fill_rect(BTN_PAD, BTN_PAD, win_w - BTN_PAD * 2, DISPLAY_H, 0x00EEEEEE);
    buf_draw_rect(BTN_PAD, BTN_PAD, win_w - BTN_PAD * 2, DISPLAY_H, COLOR_BLACK);

    // Format number
    char buf[24];
    float_to_str(display_value, buf, sizeof(buf));

    // Right-align in display
    int text_len = strlen(buf);
    int text_x = win_w - BTN_PAD * 2 - text_len * 8 - 4;
    buf_draw_string(text_x, BTN_PAD + 8, buf, COLOR_BLACK, 0x00EEEEEE);
}

static void draw_button(int row, int col, int pressed) {
    int x = BTN_PAD + col * (BTN_W + BTN_PAD);
    int y = DISPLAY_H + BTN_PAD * 2 + row * (BTN_H + BTN_PAD);

    uint32_t bg = pressed ? 0x00888888 : 0x00CCCCCC;
    uint32_t fg = COLOR_BLACK;

    // Button face
    buf_fill_rect(x, y, BTN_W, BTN_H, bg);
    buf_draw_rect(x, y, BTN_W, BTN_H, COLOR_BLACK);

    // 3D effect
    if (!pressed) {
        // Top and left highlight
        for (int i = 0; i < BTN_W - 1; i++) {
            if (x + 1 + i < win_w && y + 1 < win_h)
                win_buffer[(y + 1) * win_w + x + 1 + i] = COLOR_WHITE;
        }
        for (int i = 0; i < BTN_H - 1; i++) {
            if (x + 1 < win_w && y + 1 + i < win_h)
                win_buffer[(y + 1 + i) * win_w + x + 1] = COLOR_WHITE;
        }
    }

    // Label
    const char *label = button_labels[row][col];
    int label_len = strlen(label);
    int lx = x + (BTN_W - label_len * 8) / 2;
    int ly = y + (BTN_H - 16) / 2;
    buf_draw_string(lx, ly, label, fg, bg);
}

static void draw_all(void) {
    // Clear background
    buf_fill_rect(0, 0, win_w, win_h, 0x00DDDDDD);

    // Display
    draw_display();

    // Buttons
    for (int row = 0; row < 4; row++) {
        for (int col = 0; col < 4; col++) {
            draw_button(row, col, 0);
        }
    }

    api->window_invalidate(window_id);
}

// ============ Calculator Logic ============

static void do_op(void) {
    switch (pending_op) {
        case '+': display_value = pending_value + display_value; break;
        case '-': display_value = pending_value - display_value; break;
        case '*': display_value = pending_value * display_value; break;
        case '/':
            if (display_value != 0.0)
                display_value = pending_value / display_value;
            break;
    }
    pending_op = 0;
}

static void button_click(int row, int col) {
    const char *label = button_labels[row][col];
    char c = label[0];

    if (c >= '0' && c <= '9') {
        int digit = c - '0';
        if (clear_on_digit) {
            display_value = digit;
            clear_on_digit = 0;
            has_decimal = 0;
            decimal_place = 0.1;
        } else if (has_decimal) {
            display_value = display_value + digit * decimal_place;
            decimal_place *= 0.1;
        } else {
            display_value = display_value * 10.0 + digit;
        }
    } else if (c == '.') {
        if (!has_decimal) {
            has_decimal = 1;
            decimal_place = 0.1;
            if (clear_on_digit) {
                display_value = 0.0;
                clear_on_digit = 0;
            }
        }
    } else if (c == '=') {
        if (pending_op) {
            do_op();
        }
        clear_on_digit = 1;
        has_decimal = 0;
    } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        if (pending_op) {
            do_op();
        }
        pending_value = display_value;
        pending_op = c;
        clear_on_digit = 1;
        has_decimal = 0;
    }
}

// Clear function (C button replaced with .)
static void clear_calc(void) {
    display_value = 0.0;
    pending_value = 0.0;
    pending_op = 0;
    clear_on_digit = 0;
    has_decimal = 0;
    decimal_place = 0.1;
}

// ============ Input Handling ============

static int button_at_point(int x, int y) {
    // Returns button index (row * 4 + col) or -1
    int bx = x - BTN_PAD;
    int by = y - (DISPLAY_H + BTN_PAD * 2);

    if (bx < 0 || by < 0) return -1;

    int col = bx / (BTN_W + BTN_PAD);
    int row = by / (BTN_H + BTN_PAD);

    if (row < 0 || row >= 4 || col < 0 || col >= 4) return -1;

    // Check if actually within button bounds (not in padding)
    int btn_x = BTN_PAD + col * (BTN_W + BTN_PAD);
    int btn_y = DISPLAY_H + BTN_PAD * 2 + row * (BTN_H + BTN_PAD);
    if (x < btn_x || x >= btn_x + BTN_W) return -1;
    if (y < btn_y || y >= btn_y + BTN_H) return -1;

    return row * 4 + col;
}

// ============ Main ============

int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    // Wait for window API to be available (desktop must be running)
    if (!api->window_create) {
        api->puts("calc: window API not available (desktop not running?)\n");
        return 1;
    }

    // Calculate window size
    int content_w = BTN_PAD * 2 + 4 * BTN_W + 3 * BTN_PAD;
    int content_h = DISPLAY_H + BTN_PAD * 3 + 4 * BTN_H + 3 * BTN_PAD;

    // Create window (add title bar height in desktop)
    window_id = api->window_create(200, 100, content_w, content_h + 18, "Calculator");
    if (window_id < 0) {
        api->puts("calc: failed to create window\n");
        return 1;
    }

    // Get buffer
    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
    if (!win_buffer) {
        api->puts("calc: failed to get window buffer\n");
        api->window_destroy(window_id);
        return 1;
    }

    // Initialize graphics context
    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);

    // Initial draw
    draw_all();

    // Event loop
    int running = 1;
    while (running) {
        int event_type, data1, data2, data3;
        while (api->window_poll_event(window_id, &event_type, &data1, &data2, &data3)) {
            switch (event_type) {
                case WIN_EVENT_CLOSE:
                    running = 0;
                    break;

                case WIN_EVENT_MOUSE_DOWN: {
                    int btn = button_at_point(data1, data2);
                    if (btn >= 0) {
                        int row = btn / 4;
                        int col = btn % 4;
                        draw_button(row, col, 1);  // Pressed
                        api->window_invalidate(window_id);
                    }
                    break;
                }

                case WIN_EVENT_MOUSE_UP: {
                    int btn = button_at_point(data1, data2);
                    if (btn >= 0) {
                        int row = btn / 4;
                        int col = btn % 4;
                        button_click(row, col);
                    }
                    draw_all();  // Redraw with button unpressed
                    break;
                }

                case WIN_EVENT_KEY: {
                    char c = (char)data1;
                    // Map keys to buttons
                    if (c >= '0' && c <= '9') {
                        int digit = c - '0';
                        int row = (9 - digit) / 3;
                        int col = (digit - 1) % 3;
                        if (digit == 0) { row = 3; col = 1; }
                        button_click(row, col);
                        draw_all();
                    } else if (c == '.') { button_click(3, 0); draw_all(); }
                    else if (c == '+') { button_click(3, 3); draw_all(); }
                    else if (c == '-') { button_click(2, 3); draw_all(); }
                    else if (c == '*') { button_click(1, 3); draw_all(); }
                    else if (c == '/') { button_click(0, 3); draw_all(); }
                    else if (c == '=' || c == '\r' || c == '\n') { button_click(3, 2); draw_all(); }
                    else if (c == 'c' || c == 'C') { clear_calc(); draw_all(); }
                    else if (c == 'q' || c == 'Q') { running = 0; }
                    break;
                }

                case WIN_EVENT_RESIZE:
                    // Re-fetch buffer with new dimensions
                    win_buffer = api->window_get_buffer(window_id, &win_w, &win_h);
                    gfx_init(&gfx, win_buffer, win_w, win_h, api->font_data);
                    draw_all();
                    break;
            }
        }

        // Yield to other processes
        api->yield();
    }

    api->window_destroy(window_id);
    return 0;
}
</file>

<file path="boot/boot.S">
/*
 * VibeOS - aarch64 Bootloader
 *
 * Entry point for the kernel. Sets up the stack and jumps to C code.
 * Targets QEMU virt machine.
 */

.section ".text.boot"

.global _start

_start:
    // Get the CPU ID - only CPU 0 should initialize
    mrs     x0, mpidr_el1
    and     x0, x0, #0xFF
    cbz     x0, primary_cpu

    // Secondary CPUs go to sleep
secondary_cpu:
    wfe
    b       secondary_cpu

primary_cpu:
    // Debug: print current EL to UART
    mov     x1, #0x09000000
    mov     w2, #'E'
    str     w2, [x1]
    mov     w2, #'L'
    str     w2, [x1]

    // Check current exception level
    mrs     x0, CurrentEL
    lsr     x0, x0, #2          // CurrentEL is in bits [3:2]

    // Print EL number
    add     w2, w0, #'0'
    str     w2, [x1]
    mov     w2, #'\n'
    str     w2, [x1]

    cmp     x0, #3
    b.eq    drop_from_el3
    cmp     x0, #2
    b.eq    drop_from_el2
    cmp     x0, #1
    b.eq    at_el1
    // Unknown EL, hang
    b       secondary_cpu

drop_from_el3:
    // Debug: print '3'
    mov     x1, #0x09000000
    mov     w2, #'3'
    str     w2, [x1]

    // We're at EL3 (Secure) - drop DIRECTLY to EL1 (skip EL2)
    // Stay in Secure world so we have full GIC access

    // Configure SCR_EL3 (Secure Configuration Register)
    // Bit 10 (RW): Lower ELs are AArch64
    // Bit 0 (NS): Non-secure bit (0 = SECURE)
    // Don't set HCE since we're skipping EL2
    mov     x0, #0x430          // RW=1, NS=0 (secure), no HCE
    msr     scr_el3, x0
    isb

    mov     w2, #'a'
    str     w2, [x1]

    // Initialize SCTLR_EL1 to safe defaults (caches off, MMU off)
    mrs     x0, sctlr_el1
    bic     x0, x0, #(1 << 0)   // Clear M bit (MMU off)
    bic     x0, x0, #(1 << 2)   // Clear C bit (data cache off)
    bic     x0, x0, #(1 << 12)  // Clear I bit (instruction cache off)
    msr     sctlr_el1, x0
    isb

    mov     w2, #'b'
    str     w2, [x1]

    // Set up SPSR for EL1h (EL1 with SP_EL1, all exceptions masked)
    mov     x0, #0x3c5          // DAIF masked, EL1h
    msr     spsr_el3, x0

    mov     w2, #'c'
    str     w2, [x1]

    // Set return address to at_el1
    adr     x0, at_el1
    msr     elr_el3, x0

    mov     w2, #'d'
    str     w2, [x1]

    // Return directly to EL1
    eret

drop_from_el2:
    // Debug: print '2'
    mov     x1, #0x09000000
    mov     w2, #'2'
    str     w2, [x1]

    // We're at EL2, need to drop to EL1

    // Enable AArch64 for EL1
    mov     x0, #(1 << 31)      // RW=1: EL1 is AArch64
    msr     hcr_el2, x0

    // Set up SPSR for EL1h (EL1 with SP_EL1)
    mov     x0, #0x3c5          // DAIF masked, EL1h
    msr     spsr_el2, x0

    // Set return address to at_el1
    adr     x0, at_el1
    msr     elr_el2, x0

    mov     w2, #'\n'
    str     w2, [x1]

    // Return to EL1
    eret

at_el1:
    // x9 = UART base for debug output
    mov     x9, #0x09000000

    // Debug: confirm we're at EL1
    mov     w10, #'!'
    str     w10, [x9]
    mov     w10, #'1'
    str     w10, [x9]
    mov     w10, #'\n'
    str     w10, [x9]

    // Enable FPU/SIMD (set CPACR_EL1.FPEN = 0b11)
    mov     w10, #'F'
    str     w10, [x9]
    mov     x0, #(3 << 20)        // FPEN bits [21:20] = 0b11
    msr     cpacr_el1, x0
    isb
    mov     w10, #'f'
    str     w10, [x9]

    // Set up the stack pointer (stack grows downward)
    // Note: DTB is at 0x40000000, our RAM starts at 0x40010000 (linker.ld)
    // Stack at 0x5F000000 - near end of 512MB RAM (ends at 0x60000000)
    mov     w10, #'S'
    str     w10, [x9]
    ldr     x0, =0x5F000000       // Stack top in RAM (above heap and programs)
    mov     sp, x0
    mov     w10, #'s'
    str     w10, [x9]

    // Copy .data section from flash (LMA) to RAM (VMA)
    mov     w10, #'D'
    str     w10, [x9]
    ldr     x0, =_data_load       // Source (in flash)
    ldr     x1, =_data_start      // Dest (in RAM)
    ldr     x2, =_data_end        // End of dest
copy_data:
    cmp     x1, x2
    b.ge    data_done
    ldr     x3, [x0], #8
    str     x3, [x1], #8
    b       copy_data
data_done:
    mov     w10, #'d'
    str     w10, [x9]

    // Clear BSS section (in RAM)
    mov     w10, #'B'
    str     w10, [x9]
    ldr     x0, =_bss_start
    ldr     x1, =_bss_end
clear_bss:
    cmp     x0, x1
    b.ge    bss_done
    str     xzr, [x0], #8
    b       clear_bss
bss_done:
    mov     w10, #'b'
    str     w10, [x9]

    // Install exception vector table
    mov     w10, #'V'
    str     w10, [x9]
    ldr     x0, =exception_vectors
    msr     vbar_el1, x0
    isb
    mov     w10, #'v'
    str     w10, [x9]

    // Jump to kernel main
    mov     w10, #'K'
    str     w10, [x9]
    bl      kernel_main

    // If kernel_main returns, halt
halt:
    wfe
    b       halt

// Stack is in its own section, placed after BSS by linker
.section ".stack", "aw", @nobits
.align 16
_stack_bottom:
    .skip 0x10000  // 64KB stack
_stack_top:
</file>

<file path="kernel/keyboard.c">
/*
 * VibeOS Virtio Keyboard Driver
 *
 * Implements virtio-input for keyboard input on QEMU virt machine.
 * Virtio MMIO devices start at 0x0a000000 with 0x200 stride.
 */

#include "keyboard.h"
#include "printf.h"
#include "string.h"

// Virtio MMIO registers
#define VIRTIO_MMIO_BASE        0x0a000000
#define VIRTIO_MMIO_STRIDE      0x200

// Virtio MMIO register offsets
#define VIRTIO_MMIO_MAGIC           0x000
#define VIRTIO_MMIO_VERSION         0x004
#define VIRTIO_MMIO_DEVICE_ID       0x008
#define VIRTIO_MMIO_VENDOR_ID       0x00c
#define VIRTIO_MMIO_DEVICE_FEATURES 0x010
#define VIRTIO_MMIO_DRIVER_FEATURES 0x020
#define VIRTIO_MMIO_QUEUE_SEL       0x030
#define VIRTIO_MMIO_QUEUE_NUM_MAX   0x034
#define VIRTIO_MMIO_QUEUE_NUM       0x038
#define VIRTIO_MMIO_QUEUE_ALIGN     0x03c   // Legacy only
#define VIRTIO_MMIO_QUEUE_PFN       0x040   // Legacy only - page frame number
#define VIRTIO_MMIO_QUEUE_READY     0x044   // Modern only
#define VIRTIO_MMIO_QUEUE_NOTIFY    0x050
#define VIRTIO_MMIO_INTERRUPT_STATUS 0x060
#define VIRTIO_MMIO_INTERRUPT_ACK   0x064
#define VIRTIO_MMIO_STATUS          0x070
// Modern only registers (version 2):
#define VIRTIO_MMIO_QUEUE_DESC_LOW  0x080
#define VIRTIO_MMIO_QUEUE_DESC_HIGH 0x084
#define VIRTIO_MMIO_QUEUE_AVAIL_LOW 0x090
#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH 0x094
#define VIRTIO_MMIO_QUEUE_USED_LOW  0x0a0
#define VIRTIO_MMIO_QUEUE_USED_HIGH 0x0a4

// Virtio status bits
#define VIRTIO_STATUS_ACK       1
#define VIRTIO_STATUS_DRIVER    2
#define VIRTIO_STATUS_DRIVER_OK 4
#define VIRTIO_STATUS_FEATURES_OK 8

// Virtio device types
#define VIRTIO_DEV_INPUT        18

// Virtio input event types (Linux input event codes)
#define EV_KEY      0x01

// Key states
#define KEY_RELEASED 0
#define KEY_PRESSED  1

// Virtio input event structure
typedef struct __attribute__((packed)) {
    uint16_t type;
    uint16_t code;
    uint32_t value;
} virtio_input_event_t;

// Virtqueue structures
typedef struct __attribute__((packed)) {
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} virtq_desc_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} virtq_avail_t;

typedef struct __attribute__((packed)) {
    uint32_t id;
    uint32_t len;
} virtq_used_elem_t;

typedef struct __attribute__((packed)) {
    uint16_t flags;
    uint16_t idx;
    virtq_used_elem_t ring[];
} virtq_used_t;

// Keyboard state
static volatile uint32_t *kbd_base = NULL;
static virtq_desc_t *desc = NULL;
static virtq_avail_t *avail = NULL;
static virtq_used_t *used = NULL;
static virtio_input_event_t *events = NULL;
static uint16_t last_used_idx = 0;
static int kbd_device_index = -1;  // Which virtio device slot (for IRQ calculation)

// Virtio MMIO IRQs start at 48 (SPI 16) on QEMU virt
#define VIRTIO_IRQ_BASE 48

#define QUEUE_SIZE 16
#define DESC_F_WRITE 2

// Key buffer (int to support extended keycodes > 127)
#define KEY_BUF_SIZE 32
static volatile int key_buffer[KEY_BUF_SIZE];
static volatile int key_buf_read = 0;
static volatile int key_buf_write = 0;

// Are we using interrupt-driven mode?
static int irq_mode = 0;

// Legacy virtio queue layout requires specific alignment and contiguous layout
// For queue size N:
//   Descriptor table: N * 16 bytes, 16-byte aligned
//   Available ring: 6 + 2*N bytes, 2-byte aligned
//   Used ring: 6 + 8*N bytes, 4-byte aligned (starts at page boundary for legacy)
// We use 4KB page for simplicity with queue size 16
static uint8_t queue_mem[4096] __attribute__((aligned(4096)));
static virtio_input_event_t event_bufs[QUEUE_SIZE] __attribute__((aligned(16)));

// Scancode to ASCII (simple US layout, lowercase)
// Scancode 1 = ESC (ASCII 27)
static const char scancode_to_ascii[128] = {
    0, 27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b', '\t',
    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n', 0, 'a', 's',
    'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`', 0, '\\', 'z', 'x', 'c', 'v',
    'b', 'n', 'm', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1',
    '2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// Scancode to ASCII with shift (US layout)
static const char scancode_to_ascii_shift[128] = {
    0, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '\b', '\t',
    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\n', 0, 'A', 'S',
    'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0, '|', 'Z', 'X', 'C', 'V',
    'B', 'N', 'M', '<', '>', '?', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1',
    '2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// Modifier key scancodes
#define KEY_LEFTSHIFT  42
#define KEY_RIGHTSHIFT 54
#define KEY_LEFTCTRL   29
#define KEY_RIGHTCTRL  97

// Arrow key scancodes (Linux input event codes)
#define KEY_UP_ARROW    103
#define KEY_LEFT_ARROW  105
#define KEY_RIGHT_ARROW 106
#define KEY_DOWN_ARROW  108
#define KEY_HOME        102
#define KEY_END         107
#define KEY_DELETE      111

// Special key codes returned by keyboard_getc() (values >= 128)
#define SPECIAL_KEY_UP     0x100
#define SPECIAL_KEY_DOWN   0x101
#define SPECIAL_KEY_LEFT   0x102
#define SPECIAL_KEY_RIGHT  0x103
#define SPECIAL_KEY_HOME   0x104
#define SPECIAL_KEY_END    0x105
#define SPECIAL_KEY_DELETE 0x106

// Modifier state
static int shift_held = 0;
static int ctrl_held = 0;

// Memory barriers for device communication
static inline void mb(void) {
    asm volatile("dsb sy" ::: "memory");
}

static inline uint32_t read32(volatile uint32_t *addr) {
    uint32_t val = *addr;
    mb();
    return val;
}

static inline void write32(volatile uint32_t *addr, uint32_t val) {
    mb();
    *addr = val;
    mb();
}

// Virtio-input config registers (offset from base + 0x100)
#define VIRTIO_INPUT_CFG_SELECT  0x100
#define VIRTIO_INPUT_CFG_SUBSEL  0x101
#define VIRTIO_INPUT_CFG_SIZE    0x102
#define VIRTIO_INPUT_CFG_DATA    0x108

// Config select values
#define VIRTIO_INPUT_CFG_ID_NAME    0x01
#define VIRTIO_INPUT_CFG_ID_DEVIDS  0x03

static volatile uint32_t *find_virtio_input(void) {
    printf("[KBD] Scanning virtio devices...\n");

    // Scan virtio MMIO devices
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);
        volatile uint8_t *base8 = (volatile uint8_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic == 0x74726976 && device_id != 0) {
            printf("[KBD]   Device %d: type=%d", i, device_id);

            if (device_id == VIRTIO_DEV_INPUT) {
                // Query the input device name
                base8[VIRTIO_INPUT_CFG_SELECT] = VIRTIO_INPUT_CFG_ID_NAME;
                base8[VIRTIO_INPUT_CFG_SUBSEL] = 0;
                mb();

                uint8_t size = base8[VIRTIO_INPUT_CFG_SIZE];
                if (size > 0 && size < 64) {
                    printf(" name=\"");
                    for (int j = 0; j < size && j < 32; j++) {
                        char c = base8[VIRTIO_INPUT_CFG_DATA + j];
                        if (c >= 32 && c < 127) printf("%c", c);
                    }
                    printf("\"");
                }
            }
            printf("\n");
        }
    }

    // Now find the keyboard specifically (not tablet!)
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);
        volatile uint8_t *base8 = (volatile uint8_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);

        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);

        if (magic == 0x74726976 && device_id == VIRTIO_DEV_INPUT) {
            // Check if this is a keyboard by looking at the name
            base8[VIRTIO_INPUT_CFG_SELECT] = VIRTIO_INPUT_CFG_ID_NAME;
            base8[VIRTIO_INPUT_CFG_SUBSEL] = 0;
            mb();

            // Read full name
            char name[32] = {0};
            uint8_t size = base8[VIRTIO_INPUT_CFG_SIZE];
            for (int j = 0; j < 31 && j < size; j++) {
                name[j] = base8[VIRTIO_INPUT_CFG_DATA + j];
            }

            // Look for "Keyboard" in the name (QEMU Virtio Keyboard)
            // Skip if it's a Tablet
            int is_keyboard = 0;
            for (int j = 0; name[j] && name[j+7]; j++) {
                if (name[j] == 'K' && name[j+1] == 'e' && name[j+2] == 'y' &&
                    name[j+3] == 'b' && name[j+4] == 'o' && name[j+5] == 'a' &&
                    name[j+6] == 'r' && name[j+7] == 'd') {
                    is_keyboard = 1;
                    break;
                }
            }

            if (is_keyboard) {
                printf("[KBD] Selected: %s (device %d)\n", name, i);
                kbd_device_index = i;
                return base;
            }
        }
    }

    // Fallback: return first virtio-input device
    for (int i = 0; i < 32; i++) {
        volatile uint32_t *base = (volatile uint32_t *)(VIRTIO_MMIO_BASE + i * VIRTIO_MMIO_STRIDE);
        uint32_t magic = read32(base + VIRTIO_MMIO_MAGIC/4);
        uint32_t device_id = read32(base + VIRTIO_MMIO_DEVICE_ID/4);
        if (magic == 0x74726976 && device_id == VIRTIO_DEV_INPUT) {
            kbd_device_index = i;
            return base;
        }
    }

    return NULL;
}

int keyboard_init(void) {
    printf("[KBD] Initializing keyboard...\n");

    kbd_base = find_virtio_input();
    if (!kbd_base) {
        printf("[KBD] No virtio-input device found\n");
        return -1;
    }

    printf("[KBD] Found virtio-input at %p\n", kbd_base);

    // Check virtio version
    uint32_t version = read32(kbd_base + VIRTIO_MMIO_VERSION/4);
    printf("[KBD] Virtio version: %d\n", version);

    // Reset device
    write32(kbd_base + VIRTIO_MMIO_STATUS/4, 0);

    // Wait for reset
    while (read32(kbd_base + VIRTIO_MMIO_STATUS/4) != 0) {
        asm volatile("nop");
    }
    printf("[KBD] Device reset complete\n");

    // Acknowledge
    write32(kbd_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK);

    // Driver loaded
    write32(kbd_base + VIRTIO_MMIO_STATUS/4, VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER);

    // Read device features
    uint32_t dev_features = read32(kbd_base + VIRTIO_MMIO_DEVICE_FEATURES/4);
    printf("[KBD] Device features: 0x%x\n", dev_features);

    // Accept no special features for now
    write32(kbd_base + VIRTIO_MMIO_DRIVER_FEATURES/4, 0);

    // Features OK (modern virtio v2)
    write32(kbd_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK);

    // Select queue 0 (eventq)
    write32(kbd_base + VIRTIO_MMIO_QUEUE_SEL/4, 0);

    uint32_t max_queue = read32(kbd_base + VIRTIO_MMIO_QUEUE_NUM_MAX/4);
    printf("[KBD] Max queue size: %d\n", max_queue);

    if (max_queue < QUEUE_SIZE) {
        printf("[KBD] Queue too small\n");
        return -1;
    }

    // Set queue size
    write32(kbd_base + VIRTIO_MMIO_QUEUE_NUM/4, QUEUE_SIZE);
    printf("[KBD] Set queue size to %d\n", QUEUE_SIZE);

    // Legacy virtio queue layout (contiguous in memory):
    // Offset 0: Descriptor table (N * 16 bytes)
    // Offset 256 (16*16): Available ring (6 + 2*N bytes)
    // Offset 512 (aligned): Padding
    // Offset 2048 (page aligned): Used ring (6 + 8*N bytes)
    printf("[KBD] Using queue memory at %p\n", queue_mem);

    desc = (virtq_desc_t *)queue_mem;
    // Available ring right after descriptors
    avail = (virtq_avail_t *)(queue_mem + QUEUE_SIZE * sizeof(virtq_desc_t));
    // Used ring at offset that maintains alignment (legacy uses QUEUE_ALIGN)
    // For legacy MMIO, used ring should be at next page-aligned offset
    // With QUEUE_SIZE=16: desc=256 bytes, avail=6+32=38 bytes
    // Used ring starts at aligned offset (typically align to QUEUE_ALIGN which is usually 4096)
    used = (virtq_used_t *)(queue_mem + 2048);
    events = event_bufs;
    printf("[KBD] desc=%p avail=%p used=%p events=%p\n", desc, avail, used, events);

    // For MODERN mode (version 2), use separate address registers
    uint64_t desc_addr = (uint64_t)desc;
    uint64_t avail_addr = (uint64_t)avail;
    uint64_t used_addr = (uint64_t)used;
    printf("[KBD] Setting queue addresses (modern mode)...\n");

    write32(kbd_base + VIRTIO_MMIO_QUEUE_DESC_LOW/4, (uint32_t)desc_addr);
    write32(kbd_base + VIRTIO_MMIO_QUEUE_DESC_HIGH/4, (uint32_t)(desc_addr >> 32));
    write32(kbd_base + VIRTIO_MMIO_QUEUE_AVAIL_LOW/4, (uint32_t)avail_addr);
    write32(kbd_base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH/4, (uint32_t)(avail_addr >> 32));
    write32(kbd_base + VIRTIO_MMIO_QUEUE_USED_LOW/4, (uint32_t)used_addr);
    write32(kbd_base + VIRTIO_MMIO_QUEUE_USED_HIGH/4, (uint32_t)(used_addr >> 32));
    printf("[KBD] Queue addresses set\n");

    // Initialize descriptors with buffers for receiving events
    printf("[KBD] Initializing descriptors...\n");
    for (int i = 0; i < QUEUE_SIZE; i++) {
        desc[i].addr = (uint64_t)&events[i];
        desc[i].len = sizeof(virtio_input_event_t);
        desc[i].flags = DESC_F_WRITE;  // Device writes to this buffer
        desc[i].next = 0;
    }
    printf("[KBD] Descriptors initialized\n");

    // Add all descriptors to available ring
    printf("[KBD] Setting avail->flags...\n");
    avail->flags = 0;
    printf("[KBD] avail->flags = 0 done\n");

    printf("[KBD] Filling available ring...\n");
    for (int i = 0; i < QUEUE_SIZE; i++) {
        avail->ring[i] = i;
        printf("[KBD]   ring[%d] = %d\n", i, i);
    }
    printf("[KBD] Ring filled\n");

    avail->idx = QUEUE_SIZE;
    printf("[KBD] Available ring set up\n");

    // Queue ready (modern virtio v2)
    printf("[KBD] Setting queue ready...\n");
    write32(kbd_base + VIRTIO_MMIO_QUEUE_READY/4, 1);

    printf("[KBD] Setting driver OK...\n");
    // Driver OK (modern mode - includes FEATURES_OK)
    write32(kbd_base + VIRTIO_MMIO_STATUS/4,
            VIRTIO_STATUS_ACK | VIRTIO_STATUS_DRIVER | VIRTIO_STATUS_FEATURES_OK | VIRTIO_STATUS_DRIVER_OK);

    printf("[KBD] Notifying device...\n");
    // Notify device
    write32(kbd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    // Check final status
    uint32_t status = read32(kbd_base + VIRTIO_MMIO_STATUS/4);
    printf("[KBD] Final status: 0x%x\n", status);

    if (status & 0x40) {
        printf("[KBD] ERROR: Device reported failure!\n");
        return -1;
    }

    printf("[KBD] Keyboard initialized!\n");
    return 0;
}

static void process_events(void) {
    if (!kbd_base) return;
    if (!used) return;  // Safety check

    // Check for new events
    mb();  // Ensure we see device updates
    uint16_t current_used = used->idx;
    while (last_used_idx != current_used) {
        uint16_t idx = last_used_idx % QUEUE_SIZE;
        uint32_t desc_idx = used->ring[idx].id;

        virtio_input_event_t *ev = &events[desc_idx];

        // Process key event
        if (ev->type == EV_KEY) {
            uint16_t code = ev->code;

            // Track modifier key state
            if (code == KEY_LEFTSHIFT || code == KEY_RIGHTSHIFT) {
                shift_held = (ev->value != KEY_RELEASED);
            }
            else if (code == KEY_LEFTCTRL || code == KEY_RIGHTCTRL) {
                ctrl_held = (ev->value != KEY_RELEASED);
            }
            // Key press
            else if (ev->value == KEY_PRESSED) {
                int key = 0;

                // Check for special keys first
                switch (code) {
                    case KEY_UP_ARROW:    key = SPECIAL_KEY_UP; break;
                    case KEY_DOWN_ARROW:  key = SPECIAL_KEY_DOWN; break;
                    case KEY_LEFT_ARROW:  key = SPECIAL_KEY_LEFT; break;
                    case KEY_RIGHT_ARROW: key = SPECIAL_KEY_RIGHT; break;
                    case KEY_HOME:        key = SPECIAL_KEY_HOME; break;
                    case KEY_END:         key = SPECIAL_KEY_END; break;
                    case KEY_DELETE:      key = SPECIAL_KEY_DELETE; break;
                    default:
                        // Regular key
                        if (code < 128) {
                            if (shift_held) {
                                key = scancode_to_ascii_shift[code];
                            } else {
                                key = scancode_to_ascii[code];
                            }
                            // Apply Ctrl modifier (Ctrl+A = 1, Ctrl+S = 19, etc.)
                            if (ctrl_held && key >= 'a' && key <= 'z') {
                                key = key - 'a' + 1;
                            } else if (ctrl_held && key >= 'A' && key <= 'Z') {
                                key = key - 'A' + 1;
                            }
                        }
                        break;
                }

                if (key != 0) {
                    // Add to buffer
                    int next = (key_buf_write + 1) % KEY_BUF_SIZE;
                    if (next != key_buf_read) {
                        key_buffer[key_buf_write] = key;
                        key_buf_write = next;
                    }
                }
            }
        }

        // Re-add descriptor to available ring
        uint16_t avail_idx = avail->idx % QUEUE_SIZE;
        avail->ring[avail_idx] = desc_idx;
        avail->idx++;

        last_used_idx++;
    }

    // Notify device we added buffers
    write32(kbd_base + VIRTIO_MMIO_QUEUE_NOTIFY/4, 0);

    // Ack interrupt (in case we use interrupts later)
    write32(kbd_base + VIRTIO_MMIO_INTERRUPT_ACK/4, read32(kbd_base + VIRTIO_MMIO_INTERRUPT_STATUS/4));
}

int keyboard_has_key(void) {
    process_events();
    return key_buf_read != key_buf_write;
}

int keyboard_getc(void) {
    process_events();

    if (key_buf_read == key_buf_write) {
        return -1;
    }

    int c = key_buffer[key_buf_read];
    key_buf_read = (key_buf_read + 1) % KEY_BUF_SIZE;
    return c;
}

// Get the keyboard's IRQ number
uint32_t keyboard_get_irq(void) {
    if (kbd_device_index < 0) {
        return 0;  // Not initialized
    }
    return VIRTIO_IRQ_BASE + kbd_device_index;
}

// IRQ handler - called from irq.c
static int irq_count = 0;
void keyboard_irq_handler(void) {
    irq_count++;
    if (irq_count <= 5) {
        printf("[KBD] IRQ! (count=%d)\n", irq_count);
    }
    process_events();
}
</file>

<file path="user/bin/tetris.c">
/*
 * VibeOS Tetris (Userspace)
 *
 * Classic falling blocks game.
 * Controls: A/D to move, W to rotate, S to drop, Space for hard drop, Q to quit
 */

#include "vibe.h"

// Board dimensions
#define BOARD_WIDTH  10
#define BOARD_HEIGHT 20
#define BOARD_X      25
#define BOARD_Y      2

// Piece types
#define NUM_PIECES 7

// The 7 tetrominos (I, O, T, S, Z, J, L)
static const uint8_t pieces[NUM_PIECES][4][4][4] = {
    // I piece
    {
        {{0,0,0,0}, {1,1,1,1}, {0,0,0,0}, {0,0,0,0}},
        {{0,0,1,0}, {0,0,1,0}, {0,0,1,0}, {0,0,1,0}},
        {{0,0,0,0}, {0,0,0,0}, {1,1,1,1}, {0,0,0,0}},
        {{0,1,0,0}, {0,1,0,0}, {0,1,0,0}, {0,1,0,0}},
    },
    // O piece
    {
        {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
    },
    // T piece
    {
        {{0,1,0,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,0,0}, {0,1,1,0}, {0,1,0,0}, {0,0,0,0}},
        {{0,0,0,0}, {1,1,1,0}, {0,1,0,0}, {0,0,0,0}},
        {{0,1,0,0}, {1,1,0,0}, {0,1,0,0}, {0,0,0,0}},
    },
    // S piece
    {
        {{0,1,1,0}, {1,1,0,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,0,0}, {0,1,1,0}, {0,0,1,0}, {0,0,0,0}},
        {{0,0,0,0}, {0,1,1,0}, {1,1,0,0}, {0,0,0,0}},
        {{1,0,0,0}, {1,1,0,0}, {0,1,0,0}, {0,0,0,0}},
    },
    // Z piece
    {
        {{1,1,0,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,0,1,0}, {0,1,1,0}, {0,1,0,0}, {0,0,0,0}},
        {{0,0,0,0}, {1,1,0,0}, {0,1,1,0}, {0,0,0,0}},
        {{0,1,0,0}, {1,1,0,0}, {1,0,0,0}, {0,0,0,0}},
    },
    // J piece
    {
        {{1,0,0,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,1,0}, {0,1,0,0}, {0,1,0,0}, {0,0,0,0}},
        {{0,0,0,0}, {1,1,1,0}, {0,0,1,0}, {0,0,0,0}},
        {{0,1,0,0}, {0,1,0,0}, {1,1,0,0}, {0,0,0,0}},
    },
    // L piece
    {
        {{0,0,1,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}},
        {{0,1,0,0}, {0,1,0,0}, {0,1,1,0}, {0,0,0,0}},
        {{0,0,0,0}, {1,1,1,0}, {1,0,0,0}, {0,0,0,0}},
        {{1,1,0,0}, {0,1,0,0}, {0,1,0,0}, {0,0,0,0}},
    },
};

// Piece colors
static const uint32_t piece_colors[NUM_PIECES] = {
    0x00FFFF,  // I - cyan
    0xFFFF00,  // O - yellow
    0xFF00FF,  // T - magenta
    0x00FF00,  // S - green
    0xFF0000,  // Z - red
    0x0000FF,  // J - blue
    0xFFA500,  // L - orange
};

// Game state
static kapi_t *api;
static uint8_t board[BOARD_HEIGHT][BOARD_WIDTH];
static uint32_t board_colors[BOARD_HEIGHT][BOARD_WIDTH];
static int current_piece;
static int current_rotation;
static int current_x;
static int current_y;
static int next_piece;
static int score;
static int lines;
static int level;
static int game_over;
static int high_score = 0;

// Random number generator
static uint32_t rand_state = 54321;

static uint32_t rand(void) {
    rand_state = rand_state * 1103515245 + 12345;
    return (rand_state >> 16) & 0x7FFF;
}

// Game speed delay in milliseconds
#define TETRIS_TICK_MS 16  // ~60fps

// Draw the border
static void draw_border(void) {
    api->set_color(COLOR_WHITE, COLOR_BLACK);

    // Top border
    api->set_cursor(BOARD_Y - 1, BOARD_X - 1);
    api->putc('+');
    for (int x = 0; x < BOARD_WIDTH * 2; x++) {
        api->putc('-');
    }
    api->putc('+');

    // Side borders
    for (int y = 0; y < BOARD_HEIGHT; y++) {
        api->set_cursor(BOARD_Y + y, BOARD_X - 1);
        api->putc('|');
        api->set_cursor(BOARD_Y + y, BOARD_X + BOARD_WIDTH * 2);
        api->putc('|');
    }

    // Bottom border
    api->set_cursor(BOARD_Y + BOARD_HEIGHT, BOARD_X - 1);
    api->putc('+');
    for (int x = 0; x < BOARD_WIDTH * 2; x++) {
        api->putc('-');
    }
    api->putc('+');
}

// Draw the info panel
static void draw_info(void) {
    int info_x = BOARD_X + BOARD_WIDTH * 2 + 4;

    api->set_cursor(BOARD_Y, info_x);
    api->set_color(COLOR_AMBER, COLOR_BLACK);
    api->puts("TETRIS");

    api->set_cursor(BOARD_Y + 2, info_x);
    api->set_color(COLOR_WHITE, COLOR_BLACK);
    api->puts("Score: ");
    api->print_int(score);
    api->puts("    ");

    api->set_cursor(BOARD_Y + 3, info_x);
    api->puts("Lines: ");
    api->print_int(lines);
    api->puts("    ");

    api->set_cursor(BOARD_Y + 4, info_x);
    api->puts("Level: ");
    api->print_int(level);
    api->puts("    ");

    api->set_cursor(BOARD_Y + 5, info_x);
    api->puts("High:  ");
    api->print_int(high_score);
    api->puts("    ");

    api->set_cursor(BOARD_Y + 7, info_x);
    api->puts("Next:");

    // Draw next piece
    for (int y = 0; y < 4; y++) {
        api->set_cursor(BOARD_Y + 8 + y, info_x);
        for (int x = 0; x < 4; x++) {
            if (pieces[next_piece][0][y][x]) {
                api->set_color(piece_colors[next_piece], COLOR_BLACK);
                api->puts("[]");
            } else {
                api->puts("  ");
            }
        }
    }

    api->set_cursor(BOARD_Y + 14, info_x);
    api->set_color(COLOR_WHITE, COLOR_BLACK);
    api->puts("Controls:");

    api->set_cursor(BOARD_Y + 15, info_x);
    api->puts("A/D  Move");

    api->set_cursor(BOARD_Y + 16, info_x);
    api->puts("W    Rotate");

    api->set_cursor(BOARD_Y + 17, info_x);
    api->puts("S    Drop");

    api->set_cursor(BOARD_Y + 18, info_x);
    api->puts("Q    Quit");
}

// Draw a cell
static void draw_cell(int x, int y, uint32_t color) {
    api->set_cursor(BOARD_Y + y, BOARD_X + x * 2);
    if (color != COLOR_BLACK) {
        api->set_color(color, COLOR_BLACK);
        api->puts("[]");
    } else {
        api->set_color(COLOR_BLACK, COLOR_BLACK);
        api->puts("  ");
    }
}

// Draw the board
static void draw_board(void) {
    for (int y = 0; y < BOARD_HEIGHT; y++) {
        for (int x = 0; x < BOARD_WIDTH; x++) {
            draw_cell(x, y, board_colors[y][x]);
        }
    }
}

// Draw the current piece
static void draw_piece(int clear) {
    uint32_t color = clear ? COLOR_BLACK : piece_colors[current_piece];

    for (int py = 0; py < 4; py++) {
        for (int px = 0; px < 4; px++) {
            if (pieces[current_piece][current_rotation][py][px]) {
                int bx = current_x + px;
                int by = current_y + py;
                if (bx >= 0 && bx < BOARD_WIDTH && by >= 0 && by < BOARD_HEIGHT) {
                    draw_cell(bx, by, color);
                }
            }
        }
    }
}

// Check if piece can be placed
static int can_place(int piece, int rotation, int x, int y) {
    for (int py = 0; py < 4; py++) {
        for (int px = 0; px < 4; px++) {
            if (pieces[piece][rotation][py][px]) {
                int bx = x + px;
                int by = y + py;

                if (bx < 0 || bx >= BOARD_WIDTH || by >= BOARD_HEIGHT) {
                    return 0;
                }

                if (by >= 0 && board[by][bx]) {
                    return 0;
                }
            }
        }
    }
    return 1;
}

// Lock piece in place
static void lock_piece(void) {
    for (int py = 0; py < 4; py++) {
        for (int px = 0; px < 4; px++) {
            if (pieces[current_piece][current_rotation][py][px]) {
                int bx = current_x + px;
                int by = current_y + py;
                if (bx >= 0 && bx < BOARD_WIDTH && by >= 0 && by < BOARD_HEIGHT) {
                    board[by][bx] = 1;
                    board_colors[by][bx] = piece_colors[current_piece];
                }
            }
        }
    }
}

// Clear completed lines
static int clear_lines_fn(void) {
    int cleared = 0;

    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {
        int complete = 1;
        for (int x = 0; x < BOARD_WIDTH; x++) {
            if (!board[y][x]) {
                complete = 0;
                break;
            }
        }

        if (complete) {
            cleared++;

            for (int yy = y; yy > 0; yy--) {
                for (int x = 0; x < BOARD_WIDTH; x++) {
                    board[yy][x] = board[yy - 1][x];
                    board_colors[yy][x] = board_colors[yy - 1][x];
                }
            }

            for (int x = 0; x < BOARD_WIDTH; x++) {
                board[0][x] = 0;
                board_colors[0][x] = COLOR_BLACK;
            }

            y++;
        }
    }

    return cleared;
}

// Spawn a new piece
static void spawn_piece(void) {
    current_piece = next_piece;
    next_piece = rand() % NUM_PIECES;
    current_rotation = 0;
    current_x = BOARD_WIDTH / 2 - 2;
    current_y = -1;

    if (!can_place(current_piece, current_rotation, current_x, current_y)) {
        game_over = 1;
    }
}

// Initialize game
static void init_game(void) {
    api->clear();

    for (int y = 0; y < BOARD_HEIGHT; y++) {
        for (int x = 0; x < BOARD_WIDTH; x++) {
            board[y][x] = 0;
            board_colors[y][x] = COLOR_BLACK;
        }
    }

    score = 0;
    lines = 0;
    level = 1;
    game_over = 0;

    next_piece = rand() % NUM_PIECES;
    spawn_piece();

    draw_border();
    draw_board();
    draw_info();
    draw_piece(0);
}

// Process input
static int process_input(void) {
    while (api->has_key()) {
        int c = api->getc();

        switch (c) {
            case 'q':
            case 'Q':
                return -1;

            case 'a':
            case 'A':
                if (can_place(current_piece, current_rotation, current_x - 1, current_y)) {
                    draw_piece(1);
                    current_x--;
                    draw_piece(0);
                }
                break;

            case 'd':
            case 'D':
                if (can_place(current_piece, current_rotation, current_x + 1, current_y)) {
                    draw_piece(1);
                    current_x++;
                    draw_piece(0);
                }
                break;

            case 'w':
            case 'W':
                {
                    int new_rot = (current_rotation + 1) % 4;
                    if (can_place(current_piece, new_rot, current_x, current_y)) {
                        draw_piece(1);
                        current_rotation = new_rot;
                        draw_piece(0);
                    }
                }
                break;

            case 's':
            case 'S':
                if (can_place(current_piece, current_rotation, current_x, current_y + 1)) {
                    draw_piece(1);
                    current_y++;
                    draw_piece(0);
                    score += 1;
                }
                break;

            case ' ':
                draw_piece(1);
                while (can_place(current_piece, current_rotation, current_x, current_y + 1)) {
                    current_y++;
                    score += 2;
                }
                draw_piece(0);
                break;
        }
    }
    return 0;
}

// Update game state
static void update_game(void) {
    if (can_place(current_piece, current_rotation, current_x, current_y + 1)) {
        draw_piece(1);
        current_y++;
        draw_piece(0);
    } else {
        lock_piece();

        int cleared = clear_lines_fn();
        if (cleared > 0) {
            lines += cleared;

            int points[] = {0, 100, 300, 500, 800};
            score += points[cleared] * level;

            level = (lines / 10) + 1;
            if (level > 10) level = 10;

            draw_board();
        }

        if (score > high_score) {
            high_score = score;
        }

        draw_info();

        spawn_piece();
        if (!game_over) {
            draw_piece(0);
        }
    }
}

// Show game over
static void show_game_over(void) {
    int center_y = BOARD_Y + BOARD_HEIGHT / 2;
    int center_x = BOARD_X + BOARD_WIDTH - 4;

    api->set_cursor(center_y - 1, center_x - 2);
    api->set_color(COLOR_RED, COLOR_BLACK);
    api->puts(" GAME OVER! ");

    api->set_cursor(center_y + 1, center_x - 2);
    api->set_color(COLOR_WHITE, COLOR_BLACK);
    api->puts(" Score: ");
    api->print_int(score);
    api->puts(" ");

    api->set_cursor(center_y + 3, center_x - 4);
    api->set_color(COLOR_AMBER, COLOR_BLACK);
    api->puts("[R]estart [Q]uit");
    api->set_color(COLOR_WHITE, COLOR_BLACK);
}

// Wait for restart or quit
static int wait_for_restart(void) {
    while (1) {
        if (api->has_key()) {
            int c = api->getc();
            if (c == 'r' || c == 'R') {
                return 1;
            }
            if (c == 'q' || c == 'Q') {
                return 0;
            }
        }
        api->sleep_ms(10);
    }
}

// Main entry point
int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    init_game();

    int drop_counter = 0;
    int drop_speed = 18;  // Ticks between drops (at 60fps, 18 ticks = ~300ms)

    while (1) {
        if (process_input() < 0) {
            break;
        }

        drop_counter++;
        if (drop_counter >= drop_speed) {
            drop_counter = 0;
            update_game();

            // Speed curve: starts at 18, decreases by 2 per level
            // Level 1: 18 ticks (~300ms), Level 10: 4 ticks (~67ms)
            drop_speed = 20 - level * 2;
            if (drop_speed < 4) drop_speed = 4;
        }

        if (game_over) {
            show_game_over();
            if (wait_for_restart()) {
                init_game();
                drop_counter = 0;
                continue;
            } else {
                break;
            }
        }

        // Game tick - sleep controls game speed
        api->sleep_ms(TETRIS_TICK_MS);
    }

    api->clear();
    api->set_color(COLOR_WHITE, COLOR_BLACK);

    return score;
}
</file>

<file path="kernel/process.c">
/*
 * VibeOS Process Management
 *
 * Cooperative multitasking - Win3.1/Classic Mac style.
 * Programs run in kernel space and call kernel functions directly.
 * No memory protection, no preemption.
 */

#include "process.h"
#include "elf.h"
#include "vfs.h"
#include "memory.h"
#include "string.h"
#include "printf.h"
#include "kapi.h"
#include <stddef.h>

// Process table
static process_t proc_table[MAX_PROCESSES];
static int current_pid = -1;  // -1 means kernel/shell is running
static int next_pid = 1;

// Kernel context - saved when switching from kernel to a process
// This allows us to return to kernel (e.g., desktop running via process_exec)
static cpu_context_t kernel_context;

// Program load address - grows upward as we load programs
// Set dynamically based on heap_end
static uint64_t program_base = 0;
static uint64_t next_load_addr = 0;

// Align to 64KB boundary for cleaner loading
#define ALIGN_64K(x) (((x) + 0xFFFF) & ~0xFFFFULL)

// Program entry point signature
typedef int (*program_entry_t)(kapi_t *api, int argc, char **argv);

// Forward declaration
static void process_entry_wrapper(void);

void process_init(void) {
    // Clear process table
    for (int i = 0; i < MAX_PROCESSES; i++) {
        proc_table[i].state = PROC_STATE_FREE;
        proc_table[i].pid = 0;
    }
    current_pid = -1;
    next_pid = 1;

    // Programs load right after the heap
    program_base = ALIGN_64K(heap_end);
    next_load_addr = program_base;

    printf("[PROC] Process subsystem initialized (max %d processes)\n", MAX_PROCESSES);
    printf("[PROC] Program load area: 0x%lx+\n", program_base);
}

// Find a free slot in the process table
static int find_free_slot(void) {
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (proc_table[i].state == PROC_STATE_FREE) {
            return i;
        }
    }
    return -1;
}

process_t *process_current(void) {
    if (current_pid < 0) return NULL;
    return &proc_table[current_pid];
}

process_t *process_get(int pid) {
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (proc_table[i].pid == pid && proc_table[i].state != PROC_STATE_FREE) {
            return &proc_table[i];
        }
    }
    return NULL;
}

int process_count_ready(void) {
    int count = 0;
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (proc_table[i].state == PROC_STATE_READY ||
            proc_table[i].state == PROC_STATE_RUNNING) {
            count++;
        }
    }
    return count;
}

int process_get_info(int index, char *name, int name_size, int *state) {
    if (index < 0 || index >= MAX_PROCESSES) return 0;
    process_t *p = &proc_table[index];
    if (p->state == PROC_STATE_FREE) return 0;

    // Copy name
    if (name && name_size > 0) {
        int len = strlen(p->name);
        if (len >= name_size) len = name_size - 1;
        for (int i = 0; i < len; i++) name[i] = p->name[i];
        name[len] = '\0';
    }

    // Return state
    if (state) *state = (int)p->state;

    return 1;
}

// Create a new process (load the binary but don't start it)
int process_create(const char *path, int argc, char **argv) {
    (void)argc;
    (void)argv;

    // Find free slot
    int slot = find_free_slot();
    if (slot < 0) {
        printf("[PROC] No free process slots\n");
        return -1;
    }

    // Look up file
    vfs_node_t *file = vfs_lookup(path);
    if (!file) {
        printf("[PROC] File not found: %s\n", path);
        return -1;
    }

    if (vfs_is_dir(file)) {
        printf("[PROC] Cannot exec directory: %s\n", path);
        return -1;
    }

    size_t size = file->size;
    if (size == 0) {
        printf("[PROC] File is empty: %s\n", path);
        return -1;
    }

    // Read the ELF file
    char *data = malloc(size);
    if (!data) {
        printf("[PROC] Out of memory reading %s\n", path);
        return -1;
    }

    int bytes = vfs_read(file, data, size, 0);
    if (bytes != (int)size) {
        printf("[PROC] Failed to read %s\n", path);
        free(data);
        return -1;
    }

    // Calculate how much memory the program needs
    uint64_t prog_size = elf_calc_size(data, size);
    if (prog_size == 0) {
        printf("[PROC] Invalid ELF: %s\n", path);
        free(data);
        return -1;
    }

    // Align load address
    uint64_t load_addr = ALIGN_64K(next_load_addr);

    // Load the ELF at this address
    elf_load_info_t info;
    if (elf_load_at(data, size, load_addr, &info) != 0) {
        printf("[PROC] Failed to load ELF: %s\n", path);
        free(data);
        return -1;
    }

    free(data);

    // Update next load address for future programs
    next_load_addr = ALIGN_64K(load_addr + info.load_size + 0x10000);

    // Set up process structure
    process_t *proc = &proc_table[slot];
    proc->pid = next_pid++;
    strncpy(proc->name, path, PROCESS_NAME_MAX - 1);
    proc->name[PROCESS_NAME_MAX - 1] = '\0';
    proc->state = PROC_STATE_READY;
    proc->load_base = info.load_base;
    proc->load_size = info.load_size;
    proc->entry = info.entry;
    proc->parent_pid = current_pid;
    proc->exit_status = 0;

    // Allocate stack
    proc->stack_size = PROCESS_STACK_SIZE;
    proc->stack_base = malloc(proc->stack_size);
    if (!proc->stack_base) {
        printf("[PROC] Failed to allocate stack\n");
        proc->state = PROC_STATE_FREE;
        return -1;
    }

    // Initialize context
    // Stack grows down, SP starts at top (aligned to 16 bytes)
    uint64_t stack_top = ((uint64_t)proc->stack_base + proc->stack_size) & ~0xFULL;

    // Set up initial context so when we switch to this process,
    // it "returns" to process_entry_wrapper which calls main
    memset(&proc->context, 0, sizeof(cpu_context_t));
    proc->context.sp = stack_top;
    proc->context.x30 = (uint64_t)process_entry_wrapper;  // Return to wrapper
    proc->context.x19 = proc->entry;    // Pass entry point in callee-saved reg
    proc->context.x20 = (uint64_t)&kapi; // Pass kapi pointer
    proc->context.x21 = (uint64_t)argc;  // argc
    proc->context.x22 = (uint64_t)argv;  // argv

    printf("[PROC] Created process '%s' pid=%d at 0x%lx (slot %d)\n",
           proc->name, proc->pid, proc->load_base, slot);

    return proc->pid;
}

// Entry wrapper - called when a new process is switched to for the first time
// x19 = entry, x20 = kapi, x21 = argc, x22 = argv (set in context)
static void process_entry_wrapper(void) {
    // Get parameters from callee-saved registers (set during create)
    register uint64_t entry asm("x19");
    register uint64_t kapi_ptr asm("x20");
    register uint64_t argc asm("x21");
    register uint64_t argv asm("x22");

    program_entry_t prog_main = (program_entry_t)entry;
    int result = prog_main((kapi_t *)kapi_ptr, (int)argc, (char **)argv);

    // Process returned - exit
    process_exit(result);
}

// Start a process (make it runnable)
int process_start(int pid) {
    process_t *proc = process_get(pid);
    if (!proc) return -1;

    if (proc->state != PROC_STATE_READY) {
        printf("[PROC] Process %d not ready (state=%d)\n", pid, proc->state);
        return -1;
    }

    printf("[PROC] Starting process %d '%s'\n", pid, proc->name);
    return 0;  // Already ready, scheduler will pick it up
}

// Exit current process
void process_exit(int status) {
    if (current_pid < 0) {
        printf("[PROC] Exit called with no current process!\n");
        return;
    }

    int slot = current_pid;
    process_t *proc = &proc_table[slot];
    printf("[PROC] Process '%s' (pid %d) exited with status %d\n",
           proc->name, proc->pid, status);

    proc->exit_status = status;
    proc->state = PROC_STATE_ZOMBIE;

    // Free stack - but we're still on it! Don't free yet.
    // The stack will be freed when the slot is reused.

    // Mark slot as free (simple cleanup for now)
    proc->state = PROC_STATE_FREE;

    // We're done with this process - switch back to kernel context
    // This MUST not return - we context switch away
    current_pid = -1;

    // Switch directly back to kernel context
    // This will resume in process_exec_args() or process_schedule()
    // wherever the kernel was waiting
    context_switch(&proc->context, &kernel_context);

    // Should never reach here
    printf("[PROC] ERROR: process_exit returned!\n");
    while(1);
}

// Yield - voluntarily give up CPU
void process_yield(void) {
    if (current_pid >= 0) {
        // Mark current process as ready
        process_t *proc = &proc_table[current_pid];
        proc->state = PROC_STATE_READY;
    }
    // Always try to schedule - even from kernel context
    // This lets programs started via process_exec() yield to spawned children
    process_schedule();
}

// Simple round-robin scheduler
void process_schedule(void) {
    int old_pid = current_pid;
    process_t *old_proc = (old_pid >= 0) ? &proc_table[old_pid] : NULL;

    // Find next runnable process (round-robin)
    int start = (old_pid >= 0) ? old_pid + 1 : 0;
    int next = -1;

    for (int i = 0; i < MAX_PROCESSES; i++) {
        int idx = (start + i) % MAX_PROCESSES;
        if (proc_table[idx].state == PROC_STATE_READY) {
            next = idx;
            break;
        }
    }

    if (next < 0) {
        // No runnable processes
        if (old_pid >= 0 && old_proc->state == PROC_STATE_RUNNING) {
            // Current process still running, keep it
            return;
        }
        // Return to kernel (if we were in a process, switch back to kernel)
        if (old_pid >= 0) {
            current_pid = -1;
            context_switch(&old_proc->context, &kernel_context);
        }
        // Already in kernel with nothing to run - sleep until next interrupt
        // This prevents busy-waiting when all processes are waiting for I/O
        asm volatile("wfi");
        return;
    }

    if (next == old_pid && old_proc && old_proc->state == PROC_STATE_RUNNING) {
        // Same process and it's running - nothing to switch
        // But if it just yielded (state == READY), it's waiting for something
        // so we should sleep before giving it back the CPU
        return;
    }

    if (next == old_pid && old_proc && old_proc->state == PROC_STATE_READY) {
        // Process yielded but it's the only one - sleep until interrupt
        // then let it run again. This prevents busy-wait loops.
        asm volatile("wfi");
        old_proc->state = PROC_STATE_RUNNING;
        return;
    }

    // Switch to new process
    process_t *new_proc = &proc_table[next];

    if (old_proc && old_proc->state == PROC_STATE_RUNNING) {
        old_proc->state = PROC_STATE_READY;
    }

    new_proc->state = PROC_STATE_RUNNING;
    current_pid = next;

    // Context switch!
    // If old_pid == -1, we're switching FROM kernel context
    cpu_context_t *old_ctx = (old_pid >= 0) ? &old_proc->context : &kernel_context;
    context_switch(old_ctx, &new_proc->context);
}

// Execute and wait - creates a real process and waits for it to finish
int process_exec_args(const char *path, int argc, char **argv) {
    // Create the process
    int pid = process_create(path, argc, argv);
    if (pid < 0) {
        return pid;  // Error already printed
    }

    // Start it
    process_start(pid);

    // Find the slot for this process
    int slot = -1;
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (proc_table[i].pid == pid) {
            slot = i;
            break;
        }
    }

    if (slot < 0) {
        printf("[PROC] exec: process disappeared?\n");
        return -1;
    }

    // Wait for it to finish by yielding until it's done
    // The process is READY, we need to run the scheduler to let it execute
    while (proc_table[slot].state != PROC_STATE_FREE &&
           proc_table[slot].state != PROC_STATE_ZOMBIE) {
        process_schedule();
    }

    int result = proc_table[slot].exit_status;
    printf("[PROC] Process '%s' (pid %d) finished with status %d\n", path, pid, result);
    return result;
}

int process_exec(const char *path) {
    char *argv[1] = { (char *)path };
    return process_exec_args(path, 1, argv);
}

// Called from IRQ handler for preemptive scheduling
// This runs after all registers are saved on the IRQ stack
void process_schedule_from_irq(void) {
    // Only reschedule if we have multiple processes
    int ready_count = process_count_ready();
    if (ready_count <= 1) {
        return;  // No point switching
    }

    // Call the normal scheduler
    process_schedule();
}
</file>

<file path="kernel/vfs.c">
/*
 * VibeOS Virtual File System
 *
 * Now backed by FAT32 on persistent storage with read/write support.
 * Falls back to in-memory if no disk is available.
 */

#include "vfs.h"
#include "fat32.h"
#include "string.h"
#include "memory.h"
#include "printf.h"

// Current working directory path
static char cwd_path[VFS_MAX_PATH] = "/";

// Is FAT32 available?
static int use_fat32 = 0;

// For in-memory fallback (minimal, just /tmp)
static vfs_node_t inodes[VFS_MAX_INODES];
static int inode_count = 0;
static vfs_node_t *mem_root = NULL;

// Allocate a new in-memory inode
static vfs_node_t *alloc_inode(void) {
    if (inode_count >= VFS_MAX_INODES) {
        return NULL;
    }
    vfs_node_t *node = &inodes[inode_count++];
    memset(node, 0, sizeof(vfs_node_t));
    return node;
}

// Create an in-memory directory node
static vfs_node_t *create_mem_dir(const char *name, vfs_node_t *parent) {
    vfs_node_t *dir = alloc_inode();
    if (!dir) return NULL;

    int i;
    for (i = 0; name[i] && i < VFS_MAX_NAME - 1; i++) {
        dir->name[i] = name[i];
    }
    dir->name[i] = '\0';

    dir->type = VFS_DIRECTORY;
    dir->parent = parent;
    dir->child_count = 0;

    if (parent) {
        if (parent->child_count >= VFS_MAX_CHILDREN) {
            return NULL;
        }
        parent->children[parent->child_count++] = dir;
    }

    return dir;
}

// Create an in-memory file node
static vfs_node_t *create_mem_file(const char *name, vfs_node_t *parent) {
    if (!parent || parent->type != VFS_DIRECTORY) {
        return NULL;
    }

    vfs_node_t *file = alloc_inode();
    if (!file) return NULL;

    int i;
    for (i = 0; name[i] && i < VFS_MAX_NAME - 1; i++) {
        file->name[i] = name[i];
    }
    file->name[i] = '\0';

    file->type = VFS_FILE;
    file->parent = parent;
    file->data = NULL;
    file->size = 0;
    file->capacity = 0;

    if (parent->child_count >= VFS_MAX_CHILDREN) {
        return NULL;
    }
    parent->children[parent->child_count++] = file;

    return file;
}

// Find child by name in an in-memory directory
static vfs_node_t *find_mem_child(vfs_node_t *dir, const char *name) {
    if (!dir || dir->type != VFS_DIRECTORY) {
        return NULL;
    }

    for (int i = 0; i < dir->child_count; i++) {
        if (strcmp(dir->children[i]->name, name) == 0) {
            return dir->children[i];
        }
    }
    return NULL;
}

// Lookup in-memory filesystem
static vfs_node_t *mem_lookup(const char *path) {
    if (!path || !path[0]) {
        return mem_root;
    }

    vfs_node_t *current;
    char pathbuf[VFS_MAX_PATH];
    char *token;
    char *rest;

    if (path[0] == '/') {
        current = mem_root;
        path++;
    } else {
        // Relative path - not supported for in-memory, just use root
        current = mem_root;
    }

    if (!path[0]) {
        return current;
    }

    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    rest = pathbuf;
    while ((token = strtok_r(rest, "/", &rest)) != NULL) {
        if (token[0] == '\0') continue;

        if (strcmp(token, ".") == 0) continue;

        if (strcmp(token, "..") == 0) {
            if (current->parent) {
                current = current->parent;
            }
            continue;
        }

        vfs_node_t *child = find_mem_child(current, token);
        if (!child) {
            return NULL;
        }
        current = child;
    }

    return current;
}

// Initialize the filesystem
void vfs_init(void) {
    // Try to use FAT32
    if (fat32_init() == 0) {
        use_fat32 = 1;

        // Set initial cwd to /home/user if it exists, else /
        if (fat32_is_dir("/home/user") == 1) {
            strcpy(cwd_path, "/home/user");
        } else if (fat32_is_dir("/home") == 1) {
            strcpy(cwd_path, "/home");
        } else {
            strcpy(cwd_path, "/");
        }
    } else {
        use_fat32 = 0;

        // Create minimal in-memory filesystem
        inode_count = 0;
        mem_root = alloc_inode();
        mem_root->name[0] = '/';
        mem_root->name[1] = '\0';
        mem_root->type = VFS_DIRECTORY;
        mem_root->parent = mem_root;
        mem_root->child_count = 0;

        // Create /tmp for temporary files
        create_mem_dir("tmp", mem_root);

        strcpy(cwd_path, "/");
    }

    printf("[VFS] %s, cwd=%s\n", use_fat32 ? "FAT32" : "in-memory", cwd_path);
}

// Resolve a path to a node
// For FAT32, we return a temporary node with info
// For in-memory, we return the actual node
vfs_node_t *vfs_lookup(const char *path) {
    static vfs_node_t temp_node;
    char fullpath[VFS_MAX_PATH];

    // Build full path
    if (!path || !path[0]) {
        strcpy(fullpath, cwd_path);
    } else if (path[0] == '/') {
        strncpy(fullpath, path, VFS_MAX_PATH - 1);
        fullpath[VFS_MAX_PATH - 1] = '\0';
    } else {
        // Relative path
        if (strcmp(cwd_path, "/") == 0) {
            snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
        } else {
            snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
        }
    }

    // Normalize . and ..
    char normalized[VFS_MAX_PATH];
    char *parts[32];
    int depth = 0;

    char *rest = fullpath;
    char *token;
    if (*rest == '/') rest++;

    while ((token = strtok_r(rest, "/", &rest)) != NULL) {
        if (token[0] == '\0' || strcmp(token, ".") == 0) {
            continue;
        }
        if (strcmp(token, "..") == 0) {
            if (depth > 0) depth--;
            continue;
        }
        parts[depth++] = token;
    }

    // Rebuild normalized path
    normalized[0] = '\0';
    for (int i = 0; i < depth; i++) {
        strcat(normalized, "/");
        strcat(normalized, parts[i]);
    }
    if (normalized[0] == '\0') {
        strcpy(normalized, "/");
    }

    if (use_fat32) {
        int is_dir = fat32_is_dir(normalized);
        if (is_dir < 0) {
            return NULL;  // Not found
        }

        // Create temporary node with info
        memset(&temp_node, 0, sizeof(temp_node));

        // Extract name from path
        char *last_slash = NULL;
        for (char *p = normalized; *p; p++) {
            if (*p == '/') last_slash = p;
        }
        if (last_slash && last_slash[1]) {
            strncpy(temp_node.name, last_slash + 1, VFS_MAX_NAME - 1);
        } else {
            strcpy(temp_node.name, "/");
        }

        temp_node.type = is_dir ? VFS_DIRECTORY : VFS_FILE;
        if (!is_dir) {
            temp_node.size = fat32_file_size(normalized);
        }

        // Store the full path in a static buffer for later use
        static char stored_path[VFS_MAX_PATH];
        strcpy(stored_path, normalized);
        temp_node.data = stored_path;  // Hack: store path in data pointer

        return &temp_node;
    } else {
        return mem_lookup(normalized);
    }
}

vfs_node_t *vfs_get_root(void) {
    return vfs_lookup("/");
}

vfs_node_t *vfs_get_cwd(void) {
    return vfs_lookup(cwd_path);
}

int vfs_set_cwd(const char *path) {
    char fullpath[VFS_MAX_PATH];

    if (!path || !path[0]) {
        return -1;
    }

    // Build full path
    if (path[0] == '/') {
        strncpy(fullpath, path, VFS_MAX_PATH - 1);
        fullpath[VFS_MAX_PATH - 1] = '\0';
    } else {
        if (strcmp(cwd_path, "/") == 0) {
            snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
        } else {
            snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
        }
    }

    // Normalize the path
    char normalized[VFS_MAX_PATH];
    char *parts[32];
    int depth = 0;

    char pathcopy[VFS_MAX_PATH];
    strcpy(pathcopy, fullpath);

    char *rest = pathcopy;
    char *token;
    if (*rest == '/') rest++;

    while ((token = strtok_r(rest, "/", &rest)) != NULL) {
        if (token[0] == '\0' || strcmp(token, ".") == 0) {
            continue;
        }
        if (strcmp(token, "..") == 0) {
            if (depth > 0) depth--;
            continue;
        }
        parts[depth++] = token;
    }

    normalized[0] = '\0';
    for (int i = 0; i < depth; i++) {
        strcat(normalized, "/");
        strcat(normalized, parts[i]);
    }
    if (normalized[0] == '\0') {
        strcpy(normalized, "/");
    }

    // Check if it exists and is a directory
    if (use_fat32) {
        if (fat32_is_dir(normalized) != 1) {
            return -1;
        }
    } else {
        vfs_node_t *node = mem_lookup(normalized);
        if (!node || node->type != VFS_DIRECTORY) {
            return -1;
        }
    }

    strcpy(cwd_path, normalized);
    return 0;
}

int vfs_get_cwd_path(char *buf, size_t size) {
    if (!buf || size == 0) return -1;
    strncpy(buf, cwd_path, size - 1);
    buf[size - 1] = '\0';
    return 0;
}

// Directory listing callback context
typedef struct {
    int index;
    int target_index;
    char *name;
    size_t name_size;
    uint8_t *type;
    int found;
} readdir_ctx_t;

static void readdir_callback(const char *name, int is_dir, uint32_t size, void *user_data) {
    (void)size;
    readdir_ctx_t *ctx = (readdir_ctx_t *)user_data;

    if (ctx->index == ctx->target_index) {
        strncpy(ctx->name, name, ctx->name_size - 1);
        ctx->name[ctx->name_size - 1] = '\0';
        if (ctx->type) {
            *ctx->type = is_dir ? VFS_DIRECTORY : VFS_FILE;
        }
        ctx->found = 1;
    }
    ctx->index++;
}

int vfs_readdir(vfs_node_t *dir, int index, char *name, size_t name_size, uint8_t *type) {
    if (!dir || dir->type != VFS_DIRECTORY || !name) {
        return -1;
    }

    if (use_fat32) {
        // Get the path from the node
        const char *dirpath = (const char *)dir->data;
        if (!dirpath) dirpath = "/";

        readdir_ctx_t ctx = {
            .index = 0,
            .target_index = index,
            .name = name,
            .name_size = name_size,
            .type = type,
            .found = 0
        };

        fat32_list_dir(dirpath, readdir_callback, &ctx);

        return ctx.found ? 0 : -1;
    } else {
        if (index < 0 || index >= dir->child_count) {
            return -1;
        }

        vfs_node_t *child = dir->children[index];
        strncpy(name, child->name, name_size - 1);
        name[name_size - 1] = '\0';
        if (type) *type = child->type;

        return 0;
    }
}

vfs_node_t *vfs_mkdir(const char *path) {
    if (use_fat32) {
        // Build full path
        char fullpath[VFS_MAX_PATH];
        if (path[0] == '/') {
            strncpy(fullpath, path, VFS_MAX_PATH - 1);
            fullpath[VFS_MAX_PATH - 1] = '\0';
        } else {
            if (strcmp(cwd_path, "/") == 0) {
                snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
            } else {
                snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
            }
        }

        if (fat32_mkdir(fullpath) < 0) {
            return NULL;
        }
        return vfs_lookup(path);
    }

    // In-memory mkdir
    if (!path || !path[0]) return NULL;

    char pathbuf[VFS_MAX_PATH];
    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    char *last_slash = NULL;
    for (char *p = pathbuf; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    vfs_node_t *parent;
    char *dirname;

    if (last_slash == NULL) {
        parent = mem_lookup(cwd_path);
        dirname = pathbuf;
    } else if (last_slash == pathbuf) {
        parent = mem_root;
        dirname = last_slash + 1;
    } else {
        *last_slash = '\0';
        parent = mem_lookup(pathbuf);
        dirname = last_slash + 1;
    }

    if (!parent || parent->type != VFS_DIRECTORY) {
        return NULL;
    }

    if (find_mem_child(parent, dirname)) {
        return NULL;  // Already exists
    }

    return create_mem_dir(dirname, parent);
}

vfs_node_t *vfs_create(const char *path) {
    if (use_fat32) {
        // Build full path
        char fullpath[VFS_MAX_PATH];
        if (path[0] == '/') {
            strncpy(fullpath, path, VFS_MAX_PATH - 1);
            fullpath[VFS_MAX_PATH - 1] = '\0';
        } else {
            if (strcmp(cwd_path, "/") == 0) {
                snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
            } else {
                snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
            }
        }

        if (fat32_create_file(fullpath) < 0) {
            return NULL;
        }
        return vfs_lookup(path);
    }

    if (!path || !path[0]) return NULL;

    char pathbuf[VFS_MAX_PATH];
    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    char *last_slash = NULL;
    for (char *p = pathbuf; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    vfs_node_t *parent;
    char *filename;

    if (last_slash == NULL) {
        parent = mem_lookup(cwd_path);
        filename = pathbuf;
    } else if (last_slash == pathbuf) {
        parent = mem_root;
        filename = last_slash + 1;
    } else {
        *last_slash = '\0';
        parent = mem_lookup(pathbuf);
        filename = last_slash + 1;
    }

    if (!parent || parent->type != VFS_DIRECTORY) {
        return NULL;
    }

    vfs_node_t *existing = find_mem_child(parent, filename);
    if (existing) {
        return existing;
    }

    return create_mem_file(filename, parent);
}

int vfs_read(vfs_node_t *file, char *buf, size_t size, size_t offset) {
    if (!file || file->type != VFS_FILE || !buf) {
        return -1;
    }

    if (use_fat32) {
        // Get path from node
        const char *filepath = (const char *)file->data;
        if (!filepath) return -1;

        // For now, read full file and return portion
        // TODO: optimize with offset support in fat32_read_file
        int file_size = fat32_file_size(filepath);
        if (file_size < 0) return -1;
        if ((int)offset >= file_size) return 0;

        char *temp = malloc(file_size);
        if (!temp) return -1;

        int read = fat32_read_file(filepath, temp, file_size);
        if (read < 0) {
            free(temp);
            return -1;
        }

        size_t to_copy = read - offset;
        if (to_copy > size) to_copy = size;
        memcpy(buf, temp + offset, to_copy);

        free(temp);
        return (int)to_copy;
    } else {
        if (offset >= file->size) {
            return 0;
        }

        size_t to_read = file->size - offset;
        if (to_read > size) to_read = size;

        memcpy(buf, file->data + offset, to_read);
        return (int)to_read;
    }
}

int vfs_write(vfs_node_t *file, const char *buf, size_t size) {
    if (!file || file->type != VFS_FILE) {
        return -1;
    }

    if (use_fat32) {
        // Get path from node
        const char *filepath = (const char *)file->data;
        if (!filepath) return -1;

        return fat32_write_file(filepath, buf, size);
    }

    // In-memory write
    if (size > file->capacity) {
        size_t new_cap = size + 64;
        char *new_data = malloc(new_cap);
        if (!new_data) return -1;

        if (file->data) {
            free(file->data);
        }
        file->data = new_data;
        file->capacity = new_cap;
    }

    memcpy(file->data, buf, size);
    file->size = size;
    return (int)size;
}

int vfs_append(vfs_node_t *file, const char *buf, size_t size) {
    if (!file || file->type != VFS_FILE) {
        return -1;
    }

    if (use_fat32) {
        // Get path from node
        const char *filepath = (const char *)file->data;
        if (!filepath) return -1;

        // For append, we need to read existing content, add new data, and write back
        int file_size = fat32_file_size(filepath);
        if (file_size < 0) file_size = 0;

        char *new_buf = malloc(file_size + size);
        if (!new_buf) return -1;

        // Read existing content
        if (file_size > 0) {
            if (fat32_read_file(filepath, new_buf, file_size) < 0) {
                free(new_buf);
                return -1;
            }
        }

        // Append new data
        memcpy(new_buf + file_size, buf, size);

        // Write back
        int result = fat32_write_file(filepath, new_buf, file_size + size);
        free(new_buf);
        return result >= 0 ? (int)size : -1;
    }

    size_t new_size = file->size + size;

    if (new_size > file->capacity) {
        size_t new_cap = new_size + 64;
        char *new_data = malloc(new_cap);
        if (!new_data) return -1;

        if (file->data) {
            memcpy(new_data, file->data, file->size);
            free(file->data);
        }
        file->data = new_data;
        file->capacity = new_cap;
    }

    memcpy(file->data + file->size, buf, size);
    file->size = new_size;
    return (int)size;
}

// Helper to build full path from possibly relative path
static void build_fullpath(const char *path, char *fullpath) {
    if (path[0] == '/') {
        strncpy(fullpath, path, VFS_MAX_PATH - 1);
        fullpath[VFS_MAX_PATH - 1] = '\0';
    } else {
        if (strcmp(cwd_path, "/") == 0) {
            snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
        } else {
            snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
        }
    }
}

int vfs_delete(const char *path) {
    if (use_fat32) {
        char fullpath[VFS_MAX_PATH];
        build_fullpath(path, fullpath);
        return fat32_delete(fullpath);
    }

    // In-memory delete
    if (!path || !path[0]) return -1;

    char pathbuf[VFS_MAX_PATH];
    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    char *last_slash = NULL;
    for (char *p = pathbuf; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    vfs_node_t *parent;
    char *filename;

    if (last_slash == NULL) {
        parent = mem_lookup(cwd_path);
        filename = pathbuf;
    } else if (last_slash == pathbuf) {
        parent = mem_root;
        filename = last_slash + 1;
    } else {
        *last_slash = '\0';
        parent = mem_lookup(pathbuf);
        filename = last_slash + 1;
    }

    if (!parent || parent->type != VFS_DIRECTORY) {
        return -1;
    }

    // Find the child
    int found_idx = -1;
    for (int i = 0; i < parent->child_count; i++) {
        if (strcmp(parent->children[i]->name, filename) == 0) {
            found_idx = i;
            break;
        }
    }

    if (found_idx < 0) return -1;

    vfs_node_t *node = parent->children[found_idx];

    // Don't delete directories with this function
    if (node->type == VFS_DIRECTORY) {
        return -1;
    }

    // Free file data if any
    if (node->data && node->type == VFS_FILE) {
        free(node->data);
    }

    // Remove from parent's children array
    for (int i = found_idx; i < parent->child_count - 1; i++) {
        parent->children[i] = parent->children[i + 1];
    }
    parent->child_count--;

    return 0;
}

int vfs_delete_dir(const char *path) {
    if (use_fat32) {
        char fullpath[VFS_MAX_PATH];
        build_fullpath(path, fullpath);
        return fat32_delete_dir(fullpath);
    }

    // In-memory delete directory
    if (!path || !path[0]) return -1;

    char pathbuf[VFS_MAX_PATH];
    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    char *last_slash = NULL;
    for (char *p = pathbuf; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    vfs_node_t *parent;
    char *dirname;

    if (last_slash == NULL) {
        parent = mem_lookup(cwd_path);
        dirname = pathbuf;
    } else if (last_slash == pathbuf) {
        parent = mem_root;
        dirname = last_slash + 1;
    } else {
        *last_slash = '\0';
        parent = mem_lookup(pathbuf);
        dirname = last_slash + 1;
    }

    if (!parent || parent->type != VFS_DIRECTORY) {
        return -1;
    }

    // Find the child
    int found_idx = -1;
    for (int i = 0; i < parent->child_count; i++) {
        if (strcmp(parent->children[i]->name, dirname) == 0) {
            found_idx = i;
            break;
        }
    }

    if (found_idx < 0) return -1;

    vfs_node_t *node = parent->children[found_idx];

    // Must be a directory
    if (node->type != VFS_DIRECTORY) {
        return -1;
    }

    // Must be empty
    if (node->child_count > 0) {
        return -1;
    }

    // Remove from parent's children array
    for (int i = found_idx; i < parent->child_count - 1; i++) {
        parent->children[i] = parent->children[i + 1];
    }
    parent->child_count--;

    return 0;
}

int vfs_delete_recursive(const char *path) {
    if (use_fat32) {
        char fullpath[VFS_MAX_PATH];
        build_fullpath(path, fullpath);
        return fat32_delete_recursive(fullpath);
    }

    // In-memory recursive delete - for now just try delete_dir (doesn't recurse)
    // This is fine since in-memory fs is rarely used
    vfs_node_t *node = vfs_lookup(path);
    if (!node) return -1;

    if (node->type == VFS_DIRECTORY) {
        return vfs_delete_dir(path);
    } else {
        return vfs_delete(path);
    }
}

int vfs_rename(const char *path, const char *newname) {
    if (use_fat32) {
        // Build full path
        char fullpath[VFS_MAX_PATH];
        if (path[0] == '/') {
            strncpy(fullpath, path, VFS_MAX_PATH - 1);
            fullpath[VFS_MAX_PATH - 1] = '\0';
        } else {
            if (strcmp(cwd_path, "/") == 0) {
                snprintf(fullpath, VFS_MAX_PATH, "/%s", path);
            } else {
                snprintf(fullpath, VFS_MAX_PATH, "%s/%s", cwd_path, path);
            }
        }

        return fat32_rename(fullpath, newname);
    }

    // In-memory rename
    if (!path || !path[0] || !newname || !newname[0]) return -1;

    char pathbuf[VFS_MAX_PATH];
    strncpy(pathbuf, path, VFS_MAX_PATH - 1);
    pathbuf[VFS_MAX_PATH - 1] = '\0';

    char *last_slash = NULL;
    for (char *p = pathbuf; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    vfs_node_t *parent;
    char *filename;

    if (last_slash == NULL) {
        parent = mem_lookup(cwd_path);
        filename = pathbuf;
    } else if (last_slash == pathbuf) {
        parent = mem_root;
        filename = last_slash + 1;
    } else {
        *last_slash = '\0';
        parent = mem_lookup(pathbuf);
        filename = last_slash + 1;
    }

    if (!parent || parent->type != VFS_DIRECTORY) {
        return -1;
    }

    // Find the child
    for (int i = 0; i < parent->child_count; i++) {
        if (strcmp(parent->children[i]->name, filename) == 0) {
            // Rename it
            int j;
            for (j = 0; newname[j] && j < VFS_MAX_NAME - 1; j++) {
                parent->children[i]->name[j] = newname[j];
            }
            parent->children[i]->name[j] = '\0';
            return 0;
        }
    }

    return -1;
}

int vfs_is_dir(vfs_node_t *node) {
    return node && node->type == VFS_DIRECTORY;
}

int vfs_is_file(vfs_node_t *node) {
    return node && node->type == VFS_FILE;
}
</file>

<file path="kernel/fat32.c">
/*
 * VibeOS FAT32 Filesystem Driver
 *
 * Read-only FAT32 implementation.
 * Supports long filenames (LFN) and standard 8.3 names.
 */

#include "fat32.h"
#include "virtio_blk.h"
#include "printf.h"
#include "string.h"
#include "memory.h"

// Boot sector (BIOS Parameter Block)
typedef struct __attribute__((packed)) {
    uint8_t  jmp[3];
    char     oem[8];
    uint16_t bytes_per_sector;
    uint8_t  sectors_per_cluster;
    uint16_t reserved_sectors;
    uint8_t  num_fats;
    uint16_t root_entry_count;    // 0 for FAT32
    uint16_t total_sectors_16;    // 0 for FAT32
    uint8_t  media_type;
    uint16_t fat_size_16;         // 0 for FAT32
    uint16_t sectors_per_track;
    uint16_t num_heads;
    uint32_t hidden_sectors;
    uint32_t total_sectors_32;
    // FAT32 extended
    uint32_t fat_size_32;
    uint16_t ext_flags;
    uint16_t fs_version;
    uint32_t root_cluster;
    uint16_t fs_info;
    uint16_t backup_boot;
    uint8_t  reserved[12];
    uint8_t  drive_num;
    uint8_t  reserved1;
    uint8_t  boot_sig;
    uint32_t volume_id;
    char     volume_label[11];
    char     fs_type[8];
} fat32_boot_t;

// Filesystem state
static fat32_fs_t fs;
static int fs_initialized = 0;

// Sector buffer
static uint8_t sector_buf[512] __attribute__((aligned(16)));

// Cluster buffer (for reading directory entries)
static uint8_t *cluster_buf = NULL;
static uint32_t cluster_buf_size = 0;

// Read a sector from disk
static int read_sector(uint32_t sector, void *buf) {
    return virtio_blk_read(sector, 1, buf);
}

// Write a sector to disk
static int write_sector(uint32_t sector, const void *buf) {
    return virtio_blk_write(sector, 1, buf);
}

// Write multiple sectors
static int write_sectors(uint32_t sector, uint32_t count, const void *buf) {
    return virtio_blk_write(sector, count, buf);
}

// Read multiple sectors
static int read_sectors(uint32_t sector, uint32_t count, void *buf) {
    return virtio_blk_read(sector, count, buf);
}

// Get the first sector of a cluster
static uint32_t cluster_to_sector(uint32_t cluster) {
    return fs.data_start + (cluster - 2) * fs.sectors_per_cluster;
}

// Read the FAT entry for a cluster (returns next cluster or EOC marker)
static uint32_t fat_next_cluster(uint32_t cluster) {
    // Calculate which sector of the FAT contains this entry
    uint32_t fat_offset = cluster * 4;
    uint32_t fat_sector = fs.reserved_sectors + (fat_offset / fs.bytes_per_sector);
    uint32_t entry_offset = fat_offset % fs.bytes_per_sector;

    if (read_sector(fat_sector, sector_buf) < 0) {
        return FAT32_EOC;
    }

    uint32_t next = *(uint32_t *)(sector_buf + entry_offset);
    return next & 0x0FFFFFFF;  // FAT32 uses only 28 bits
}

// Write a FAT entry (updates both FAT copies)
static int fat_set_cluster(uint32_t cluster, uint32_t value) {
    uint32_t fat_offset = cluster * 4;
    uint32_t fat_sector = fs.reserved_sectors + (fat_offset / fs.bytes_per_sector);
    uint32_t entry_offset = fat_offset % fs.bytes_per_sector;

    // Read current sector
    if (read_sector(fat_sector, sector_buf) < 0) {
        return -1;
    }

    // Modify entry (preserve high 4 bits)
    uint32_t *entry = (uint32_t *)(sector_buf + entry_offset);
    *entry = (*entry & 0xF0000000) | (value & 0x0FFFFFFF);

    // Write to FAT1
    if (write_sector(fat_sector, sector_buf) < 0) {
        return -1;
    }

    // Write to FAT2 (if exists)
    if (fs.num_fats > 1) {
        uint32_t fat2_sector = fat_sector + fs.fat_size;
        if (write_sector(fat2_sector, sector_buf) < 0) {
            return -1;
        }
    }

    return 0;
}

// Find a free cluster and mark it as end-of-chain
static uint32_t fat_alloc_cluster(void) {
    // Start searching from cluster 2 (first data cluster)
    for (uint32_t cluster = 2; cluster < fs.total_clusters + 2; cluster++) {
        uint32_t entry = fat_next_cluster(cluster);
        if (entry == FAT32_FREE) {
            // Mark as end of chain
            if (fat_set_cluster(cluster, FAT32_EOC) < 0) {
                return 0;
            }
            return cluster;
        }
    }
    return 0;  // No free clusters
}

// Free a cluster chain starting at given cluster
static int fat_free_chain(uint32_t cluster) {
    while (cluster >= 2 && cluster < FAT32_EOC) {
        uint32_t next = fat_next_cluster(cluster);
        if (fat_set_cluster(cluster, FAT32_FREE) < 0) {
            return -1;
        }
        cluster = next;
    }
    return 0;
}

// Write a cluster to disk
static int write_cluster(uint32_t cluster, const void *buf) {
    uint32_t sector = cluster_to_sector(cluster);
    return write_sectors(sector, fs.sectors_per_cluster, buf);
}

// Zero out a cluster
static int zero_cluster(uint32_t cluster) {
    memset(cluster_buf, 0, cluster_buf_size);
    return write_cluster(cluster, cluster_buf);
}

// Read a cluster into buffer
static int read_cluster(uint32_t cluster, void *buf) {
    uint32_t sector = cluster_to_sector(cluster);
    return read_sectors(sector, fs.sectors_per_cluster, buf);
}

// Convert 8.3 name to normal string
static void fat_name_to_str(const char *fat_name, char *out) {
    int i, j = 0;

    // Copy name part (first 8 chars, trim trailing spaces)
    for (i = 0; i < 8 && fat_name[i] != ' '; i++) {
        out[j++] = fat_name[i];
    }

    // Add dot and extension if present
    if (fat_name[8] != ' ') {
        out[j++] = '.';
        for (i = 8; i < 11 && fat_name[i] != ' '; i++) {
            out[j++] = fat_name[i];
        }
    }

    out[j] = '\0';

    // Convert to lowercase for nicer display
    for (i = 0; out[i]; i++) {
        if (out[i] >= 'A' && out[i] <= 'Z') {
            out[i] += 32;
        }
    }
}

// Compare filename (case-insensitive)
static int name_match(const char *name1, const char *name2) {
    while (*name1 && *name2) {
        char c1 = *name1++;
        char c2 = *name2++;
        // Convert to uppercase for comparison
        if (c1 >= 'a' && c1 <= 'z') c1 -= 32;
        if (c2 >= 'a' && c2 <= 'z') c2 -= 32;
        if (c1 != c2) return 0;
    }
    return *name1 == *name2;
}

int fat32_init(void) {
    printf("[FAT32] Initializing...\n");

    // Read boot sector
    printf("[FAT32] Reading boot sector...\n");
    int ret = read_sector(0, sector_buf);
    printf("[FAT32] read_sector returned %d\n", ret);
    if (ret < 0) {
        printf("[FAT32] Failed to read boot sector\n");
        return -1;
    }

    printf("[FAT32] Sector read OK, parsing boot sector...\n");

    fat32_boot_t *boot = (fat32_boot_t *)sector_buf;

    printf("[FAT32] boot ptr = %p, sector_buf = %p\n", boot, sector_buf);
    printf("[FAT32] First bytes: %02x %02x %02x\n",
           sector_buf[0], sector_buf[1], sector_buf[2]);

    printf("[FAT32] Reading byte 11...\n");
    uint8_t b11 = sector_buf[11];
    printf("[FAT32] byte 11 = %02x\n", b11);
    uint8_t b12 = sector_buf[12];
    printf("[FAT32] byte 12 = %02x\n", b12);

    // Read fields manually to avoid unaligned access issues on ARM
    uint16_t bytes_per_sector = b11 | (b12 << 8);
    printf("[FAT32] bytes_per_sector = %d\n", bytes_per_sector);

    uint8_t sectors_per_cluster = sector_buf[13];
    printf("[FAT32] sectors_per_cluster = %d\n", sectors_per_cluster);

    uint16_t reserved_sectors = sector_buf[14] | (sector_buf[15] << 8);
    printf("[FAT32] reserved_sectors = %d\n", reserved_sectors);

    printf("[FAT32] reading num_fats...\n");
    uint8_t num_fats = sector_buf[16];
    printf("[FAT32] num_fats = %d\n", num_fats);

    printf("[FAT32] reading root_entry_count...\n");
    printf("[FAT32] sector_buf[17]...\n");
    uint8_t b17 = sector_buf[17];
    printf("[FAT32] b17 = %02x\n", b17);
    printf("[FAT32] sector_buf[18]...\n");
    uint8_t b18 = sector_buf[18];
    printf("[FAT32] b18 = %02x\n", b18);
    uint16_t root_entry_count = b17 | (b18 << 8);
    printf("[FAT32] root_entry_count = %d\n", root_entry_count);

    printf("[FAT32] reading fat_size_16...\n");
    uint16_t fat_size_16 = sector_buf[22] | (sector_buf[23] << 8);
    printf("[FAT32] fat_size_16 = %d\n", fat_size_16);

    uint32_t fat_size_32 = sector_buf[36] | (sector_buf[37] << 8) |
                           (sector_buf[38] << 16) | (sector_buf[39] << 24);
    uint32_t root_cluster = sector_buf[44] | (sector_buf[45] << 8) |
                            (sector_buf[46] << 16) | (sector_buf[47] << 24);
    uint32_t total_sectors_32 = sector_buf[32] | (sector_buf[33] << 8) |
                                (sector_buf[34] << 16) | (sector_buf[35] << 24);
    printf("[FAT32] fat_size_32=%d root_cluster=%d total_sectors=%d\n",
           fat_size_32, root_cluster, total_sectors_32);

    // Verify this is FAT32
    if (bytes_per_sector != 512) {
        printf("[FAT32] Unsupported sector size: %d\n", bytes_per_sector);
        return -1;
    }

    if (fat_size_16 != 0 || root_entry_count != 0) {
        printf("[FAT32] Not a FAT32 filesystem\n");
        return -1;
    }

    // Fill in filesystem info
    fs.bytes_per_sector = bytes_per_sector;
    fs.sectors_per_cluster = sectors_per_cluster;
    fs.reserved_sectors = reserved_sectors;
    fs.num_fats = num_fats;
    fs.fat_size = fat_size_32;
    fs.root_cluster = root_cluster;

    // Calculate data region start
    fs.data_start = fs.reserved_sectors + (fs.num_fats * fs.fat_size);

    // Calculate total data clusters
    uint32_t data_sectors = total_sectors_32 - fs.data_start;
    fs.total_clusters = data_sectors / fs.sectors_per_cluster;

    printf("[FAT32] Sectors/cluster: %d\n", fs.sectors_per_cluster);
    printf("[FAT32] Reserved sectors: %d\n", fs.reserved_sectors);
    printf("[FAT32] FAT size: %d sectors\n", fs.fat_size);
    printf("[FAT32] Root cluster: %d\n", fs.root_cluster);
    printf("[FAT32] Data start: sector %d\n", fs.data_start);
    printf("[FAT32] Total clusters: %d\n", fs.total_clusters);

    // Allocate cluster buffer
    cluster_buf_size = fs.sectors_per_cluster * fs.bytes_per_sector;
    cluster_buf = malloc(cluster_buf_size);
    if (!cluster_buf) {
        printf("[FAT32] Failed to allocate cluster buffer\n");
        return -1;
    }

    fs_initialized = 1;
    printf("[FAT32] Filesystem ready!\n");
    return 0;
}

// Helper to read uint16 from byte array (little-endian)
static uint16_t read16(uint8_t *p) {
    return p[0] | (p[1] << 8);
}

// Helper to read uint32 from byte array (little-endian)
static uint32_t read32(uint8_t *p) {
    return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
}

// Find a directory entry by path component in a directory cluster chain
// Returns the directory entry or NULL if not found
static fat32_dirent_t *find_entry_in_dir(uint32_t dir_cluster, const char *name,
                                          uint32_t *out_cluster, uint32_t *out_offset) {
    static fat32_dirent_t found_entry;
    char entry_name[256];
    char lfn_name[256];
    int has_lfn = 0;

    uint32_t cluster = dir_cluster;

    while (cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return NULL;
        }

        int entries_per_cluster = cluster_buf_size / 32;  // Each entry is 32 bytes

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + (i * 32);

            // Entry layout:
            // 0-10: name (11 bytes)
            // 11: attr
            // 20: cluster_hi (2 bytes)
            // 26: cluster_lo (2 bytes)
            // 28: size (4 bytes)

            uint8_t first_byte = e[0];
            uint8_t attr = e[11];

            // End of directory
            if (first_byte == 0x00) {
                return NULL;
            }

            // Deleted entry
            if (first_byte == 0xE5) {
                has_lfn = 0;
                continue;
            }

            // Long filename entry (attr == 0x0F)
            if (attr == FAT_ATTR_LFN) {
                uint8_t order = e[0];
                int seq = order & 0x1F;
                int is_last = order & 0x40;

                if (is_last) {
                    has_lfn = 1;
                    memset(lfn_name, 0, sizeof(lfn_name));
                }

                // Extract characters from LFN entry (stored as UTF-16LE, we just take low byte)
                int base = (seq - 1) * 13;
                // name1: bytes 1-10 (5 UTF-16 chars)
                for (int j = 0; j < 5; j++) {
                    uint16_t c = e[1 + j*2] | (e[2 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + j < 255) lfn_name[base + j] = (char)c;
                }
                // name2: bytes 14-25 (6 UTF-16 chars)
                for (int j = 0; j < 6; j++) {
                    uint16_t c = e[14 + j*2] | (e[15 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 5 + j < 255) lfn_name[base + 5 + j] = (char)c;
                }
                // name3: bytes 28-31 (2 UTF-16 chars)
                for (int j = 0; j < 2; j++) {
                    uint16_t c = e[28 + j*2] | (e[29 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 11 + j < 255) lfn_name[base + 11 + j] = (char)c;
                }
                continue;
            }

            // Regular entry - skip volume label
            if (attr & FAT_ATTR_VOLUME_ID) {
                has_lfn = 0;
                continue;
            }

            // Get the name to compare
            if (has_lfn) {
                // Use long filename
                int k;
                for (k = 0; lfn_name[k]; k++) {
                    entry_name[k] = lfn_name[k];
                }
                entry_name[k] = '\0';
            } else {
                // Use 8.3 name - copy and convert
                fat_name_to_str((char *)e, entry_name);
            }

            // Compare names
            if (name_match(entry_name, name)) {
                // Build found_entry from bytes
                memcpy(found_entry.name, e, 11);
                found_entry.attr = attr;
                found_entry.cluster_hi = read16(e + 20);
                found_entry.cluster_lo = read16(e + 26);
                found_entry.size = read32(e + 28);
                if (out_cluster) *out_cluster = cluster;
                if (out_offset) *out_offset = i;
                return &found_entry;
            }

            has_lfn = 0;
        }

        // Follow cluster chain
        cluster = fat_next_cluster(cluster);
    }

    return NULL;
}

// Resolve a path to a directory entry
// Returns the entry or NULL if not found
static fat32_dirent_t *resolve_path(const char *path, uint32_t *out_cluster) {
    if (!fs_initialized || !path) return NULL;

    // Start at root
    uint32_t current_cluster = fs.root_cluster;

    // Skip leading slash
    if (*path == '/') path++;
    if (*path == '\0') {
        // Root directory requested - return a fake entry
        static fat32_dirent_t root_entry;
        memset(&root_entry, 0, sizeof(root_entry));
        root_entry.attr = FAT_ATTR_DIRECTORY;
        root_entry.cluster_hi = (fs.root_cluster >> 16) & 0xFFFF;
        root_entry.cluster_lo = fs.root_cluster & 0xFFFF;
        if (out_cluster) *out_cluster = fs.root_cluster;
        return &root_entry;
    }

    // Parse path components
    char pathbuf[256];
    int len = strlen(path);
    if (len >= 256) return NULL;
    memcpy(pathbuf, path, len + 1);

    char *rest = pathbuf;
    char *component;
    fat32_dirent_t *entry = NULL;

    while ((component = strtok_r(rest, "/", &rest)) != NULL) {
        if (component[0] == '\0') continue;

       // printf("[FAT32] resolve: looking for '%s' in cluster %u\n", component, current_cluster);
        entry = find_entry_in_dir(current_cluster, component, NULL, NULL);
        if (!entry) {
            printf("[FAT32] resolve: '%s' not found!\n", component);
            return NULL;  // Not found
        }
      //  printf("[FAT32] resolve: found '%s'\n", component);

        // Get cluster of this entry
        current_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;
       // printf("[FAT32] resolve: entry=%p attr=0x%x rest='%s'\n", entry, entry->attr, rest ? rest : "(null)");

        // If there's more path to go, this must be a directory
        if (rest && *rest && !(entry->attr & FAT_ATTR_DIRECTORY)) {
        //    printf("[FAT32] resolve: not a dir but path continues, abort\n");
            return NULL;  // Trying to traverse through a file
        }
    }

   // printf("[FAT32] resolve: loop done, entry=%p\n", entry);
    if (out_cluster) *out_cluster = current_cluster;
   // printf("[FAT32] resolve: returning entry=%p\n", entry);
    return entry;
}

int fat32_read_file(const char *path, void *buf, size_t size) {
    if (!fs_initialized) return -1;

    uint32_t cluster;
    fat32_dirent_t *entry = resolve_path(path, &cluster);

    if (!entry) {
        return -1;  // File not found
    }

    if (entry->attr & FAT_ATTR_DIRECTORY) {
        return -1;  // Can't read a directory as a file
    }

    uint32_t file_size = entry->size;
    if (size > file_size) size = file_size;

    // Read cluster chain
    uint8_t *dst = (uint8_t *)buf;
    size_t bytes_read = 0;

    while (cluster < FAT32_EOC && bytes_read < size) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        size_t to_copy = cluster_buf_size;
        if (bytes_read + to_copy > size) {
            to_copy = size - bytes_read;
        }

        memcpy(dst + bytes_read, cluster_buf, to_copy);
        bytes_read += to_copy;

        cluster = fat_next_cluster(cluster);
    }

    return (int)bytes_read;
}

int fat32_file_size(const char *path) {
    if (!fs_initialized) return -1;

    fat32_dirent_t *entry = resolve_path(path, NULL);
    if (!entry) return -1;
    if (entry->attr & FAT_ATTR_DIRECTORY) return -1;

    return (int)entry->size;
}

int fat32_is_dir(const char *path) {
    if (!fs_initialized) {
        printf("[FAT32] is_dir(%s): not initialized\n", path);
        return -1;
    }

    fat32_dirent_t *entry = resolve_path(path, NULL);
    if (!entry) {
        printf("[FAT32] is_dir(%s): not found\n", path);
        return -1;
    }

    int result = (entry->attr & FAT_ATTR_DIRECTORY) ? 1 : 0;
    printf("[FAT32] is_dir(%s): %d\n", path, result);
    return result;
}

int fat32_list_dir(const char *path, fat32_dir_callback callback, void *user_data) {
    if (!fs_initialized || !callback) return -1;

    uint32_t dir_cluster;
    fat32_dirent_t *entry = resolve_path(path, &dir_cluster);

    if (!entry) return -1;
    if (!(entry->attr & FAT_ATTR_DIRECTORY)) return -1;

    char entry_name[256];
    char lfn_name[256];
    int has_lfn = 0;

    uint32_t cluster = dir_cluster;

    while (cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        int entries_per_cluster = cluster_buf_size / 32;

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + (i * 32);
            uint8_t first_byte = e[0];
            uint8_t attr = e[11];

            // End of directory
            if (first_byte == 0x00) {
                return 0;
            }

            // Deleted entry
            if (first_byte == 0xE5) {
                has_lfn = 0;
                continue;
            }

            // Long filename entry
            if (attr == FAT_ATTR_LFN) {
                uint8_t order = e[0];
                int seq = order & 0x1F;
                int is_last = order & 0x40;

                if (is_last) {
                    has_lfn = 1;
                    memset(lfn_name, 0, sizeof(lfn_name));
                }

                int base = (seq - 1) * 13;
                for (int j = 0; j < 5; j++) {
                    uint16_t c = e[1 + j*2] | (e[2 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + j < 255) lfn_name[base + j] = (char)c;
                }
                for (int j = 0; j < 6; j++) {
                    uint16_t c = e[14 + j*2] | (e[15 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 5 + j < 255) lfn_name[base + 5 + j] = (char)c;
                }
                for (int j = 0; j < 2; j++) {
                    uint16_t c = e[28 + j*2] | (e[29 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 11 + j < 255) lfn_name[base + 11 + j] = (char)c;
                }
                continue;
            }

            // Skip volume label and . and ..
            if (attr & FAT_ATTR_VOLUME_ID) {
                has_lfn = 0;
                continue;
            }
            if (first_byte == '.') {
                has_lfn = 0;
                continue;
            }

            // Get the name
            if (has_lfn) {
                int k;
                for (k = 0; lfn_name[k]; k++) {
                    entry_name[k] = lfn_name[k];
                }
                entry_name[k] = '\0';
            } else {
                fat_name_to_str((char *)e, entry_name);
            }

            int is_dir = (attr & FAT_ATTR_DIRECTORY) ? 1 : 0;
            uint32_t size = read32(e + 28);
            callback(entry_name, is_dir, size, user_data);

            has_lfn = 0;
        }

        cluster = fat_next_cluster(cluster);
    }

    return 0;
}

fat32_fs_t *fat32_get_fs_info(void) {
    return fs_initialized ? &fs : NULL;
}

// Convert a normal filename to 8.3 format (uppercase, padded with spaces)
static void str_to_fat_name(const char *name, char *fat_name) {
    memset(fat_name, ' ', 11);

    int i = 0, j = 0;

    // Find the dot for extension
    const char *dot = NULL;
    for (const char *p = name; *p; p++) {
        if (*p == '.') dot = p;
    }

    // Copy name part (up to 8 chars, before dot or end)
    const char *end = dot ? dot : name + strlen(name);
    for (i = 0; i < 8 && name + i < end; i++) {
        char c = name[i];
        if (c >= 'a' && c <= 'z') c -= 32;  // Uppercase
        fat_name[i] = c;
    }

    // Copy extension (up to 3 chars, after dot)
    if (dot) {
        dot++;  // Skip the dot
        for (j = 0; j < 3 && dot[j]; j++) {
            char c = dot[j];
            if (c >= 'a' && c <= 'z') c -= 32;  // Uppercase
            fat_name[8 + j] = c;
        }
    }
}

// Calculate checksum for 8.3 name (used by LFN entries)
static uint8_t fat_checksum(const char *short_name) {
    uint8_t sum = 0;
    for (int i = 0; i < 11; i++) {
        sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + (uint8_t)short_name[i];
    }
    return sum;
}

// Check if a filename needs LFN (long filename) entries
// Returns 1 if LFN needed, 0 if 8.3 is sufficient
static int needs_lfn(const char *name) {
    int len = strlen(name);

    // Check length - 8.3 max is 12 chars (8 + dot + 3)
    if (len > 12) return 1;

    // Find the dot
    const char *dot = NULL;
    int dot_pos = -1;
    for (int i = 0; name[i]; i++) {
        if (name[i] == '.') {
            if (dot) return 1;  // Multiple dots
            dot = &name[i];
            dot_pos = i;
        }
    }

    // Check name part length (max 8)
    int name_len = dot ? dot_pos : len;
    if (name_len > 8) return 1;

    // Check extension length (max 3)
    if (dot && strlen(dot + 1) > 3) return 1;

    // Check for invalid 8.3 characters or lowercase
    for (int i = 0; name[i]; i++) {
        char c = name[i];
        // Lowercase needs LFN to preserve case
        if (c >= 'a' && c <= 'z') return 1;
        // Spaces need LFN (except trailing, but we don't allow those anyway)
        if (c == ' ') return 1;
        // These chars are invalid in 8.3 but some are ok in LFN
        if (c == '+' || c == ',' || c == ';' || c == '=' || c == '[' || c == ']') return 1;
    }

    return 0;
}

// Generate a basis name for 8.3 from a long filename
// Removes invalid chars, converts to uppercase, handles leading dots, etc.
static void generate_basis_name(const char *name, char *basis, char *ext) {
    memset(basis, ' ', 8);
    memset(ext, ' ', 3);

    // Skip leading dots and spaces
    while (*name == '.' || *name == ' ') name++;

    // Find the last dot for extension
    const char *last_dot = NULL;
    for (const char *p = name; *p; p++) {
        if (*p == '.') last_dot = p;
    }

    // Copy name part (up to 8 chars, before last dot or end)
    const char *end = last_dot ? last_dot : name + strlen(name);
    int j = 0;
    for (const char *p = name; p < end && j < 8; p++) {
        char c = *p;
        // Skip invalid chars and dots
        if (c == ' ' || c == '.' || c == '+' || c == ',' || c == ';' ||
            c == '=' || c == '[' || c == ']') continue;
        // Convert to uppercase
        if (c >= 'a' && c <= 'z') c -= 32;
        basis[j++] = c;
    }

    // Copy extension (up to 3 chars, after last dot)
    if (last_dot) {
        last_dot++;  // Skip the dot
        j = 0;
        for (const char *p = last_dot; *p && j < 3; p++) {
            char c = *p;
            if (c == ' ' || c == '.') continue;
            if (c >= 'a' && c <= 'z') c -= 32;
            ext[j++] = c;
        }
    }
}

// Check if a short name already exists in a directory
static int short_name_exists(uint32_t dir_cluster, const char *short_name) {
    uint32_t cluster = dir_cluster;

    while (cluster >= 2 && cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return 0;  // Error, assume doesn't exist
        }

        int entries_per_cluster = cluster_buf_size / 32;

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + (i * 32);

            if (e[0] == 0x00) return 0;  // End of dir
            if (e[0] == 0xE5) continue;   // Deleted
            if (e[11] == FAT_ATTR_LFN) continue;  // LFN entry

            // Compare the 11-byte name
            int match = 1;
            for (int j = 0; j < 11; j++) {
                if (e[j] != (uint8_t)short_name[j]) {
                    match = 0;
                    break;
                }
            }
            if (match) return 1;
        }

        cluster = fat_next_cluster(cluster);
    }

    return 0;
}

// Generate a unique 8.3 short name with numeric tail (~1, ~2, etc.)
static void generate_short_name(uint32_t dir_cluster, const char *long_name, char *short_name) {
    char basis[8], ext[3];
    generate_basis_name(long_name, basis, ext);

    // Build initial short name
    memcpy(short_name, basis, 8);
    memcpy(short_name + 8, ext, 3);

    // If no collision, we're done
    if (!short_name_exists(dir_cluster, short_name)) {
        return;
    }

    // Need numeric tail - try ~1 through ~99999
    for (int n = 1; n <= 99999; n++) {
        // Format the number
        char num[8];
        int num_len = 0;
        int temp = n;
        while (temp > 0) {
            num[num_len++] = '0' + (temp % 10);
            temp /= 10;
        }

        // Calculate how many basis chars we can keep
        // Need room for ~ and the number
        int tail_len = 1 + num_len;  // ~ plus digits
        int keep = 8 - tail_len;
        if (keep < 1) keep = 1;

        // Build short name with tail
        int j = 0;
        for (int i = 0; i < keep && basis[i] != ' '; i++) {
            short_name[j++] = basis[i];
        }
        short_name[j++] = '~';
        // Add number (reversed)
        for (int i = num_len - 1; i >= 0; i--) {
            short_name[j++] = num[i];
        }
        // Pad with spaces
        while (j < 8) {
            short_name[j++] = ' ';
        }
        // Extension stays the same
        memcpy(short_name + 8, ext, 3);

        if (!short_name_exists(dir_cluster, short_name)) {
            return;
        }
    }

    // Exhausted all options (very unlikely), just use what we have
}

// Find the parent directory cluster and the filename component
static int parse_parent_path(const char *path, uint32_t *parent_cluster, char *filename) {
    if (!path || path[0] != '/') return -1;

    // Find last slash
    const char *last_slash = path;
    for (const char *p = path; *p; p++) {
        if (*p == '/') last_slash = p;
    }

    // Extract filename
    const char *fname = last_slash + 1;
    if (!fname[0]) return -1;  // Path ends with /

    int len = strlen(fname);
    if (len >= 256) return -1;
    memcpy(filename, fname, len + 1);

    // Get parent directory
    if (last_slash == path) {
        // Parent is root
        *parent_cluster = fs.root_cluster;
    } else {
        // Build parent path
        char parent_path[256];
        int parent_len = last_slash - path;
        if (parent_len >= 256) return -1;
        memcpy(parent_path, path, parent_len);
        parent_path[parent_len] = '\0';

        fat32_dirent_t *parent = resolve_path(parent_path, parent_cluster);
        if (!parent) return -1;
        if (!(parent->attr & FAT_ATTR_DIRECTORY)) return -1;
    }

    return 0;
}

// Write 16-bit value to byte array (little-endian)
static void write16(uint8_t *p, uint16_t val) {
    p[0] = val & 0xFF;
    p[1] = (val >> 8) & 0xFF;
}

// Write 32-bit value to byte array (little-endian)
static void write32(uint8_t *p, uint32_t val) {
    p[0] = val & 0xFF;
    p[1] = (val >> 8) & 0xFF;
    p[2] = (val >> 16) & 0xFF;
    p[3] = (val >> 24) & 0xFF;
}

// Find N consecutive free directory entry slots in a directory cluster chain
// Returns cluster and offset of first free entry, or allocates new cluster if needed
// out_clusters and out_offsets are arrays of size count (entries may span clusters)
static int find_free_dir_entries(uint32_t dir_cluster, int count,
                                  uint32_t *out_clusters, uint32_t *out_offsets) {
    if (count <= 0) return -1;

    // Track all entries in directory for scanning
    // We'll collect potential consecutive runs
    uint32_t run_clusters[32];  // Max 32 entries for very long filenames
    uint32_t run_offsets[32];
    int run_len = 0;

    uint32_t cluster = dir_cluster;
    uint32_t last_cluster = dir_cluster;  // Track last valid cluster for chaining
    int entries_per_cluster = cluster_buf_size / 32;

    while (cluster >= 2 && cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + (i * 32);
            uint8_t first_byte = e[0];

            // Free entry (deleted or never used)
            if (first_byte == 0x00 || first_byte == 0xE5) {
                run_clusters[run_len] = cluster;
                run_offsets[run_len] = i;
                run_len++;

                if (run_len >= count) {
                    // Found enough! Copy to output
                    for (int j = 0; j < count; j++) {
                        out_clusters[j] = run_clusters[j];
                        out_offsets[j] = run_offsets[j];
                    }
                    return 0;
                }

                // If this was 0x00 (end of dir), rest of cluster is also free
                if (first_byte == 0x00) {
                    // Rest of this cluster is free
                    for (int k = i + 1; k < entries_per_cluster && run_len < count; k++) {
                        run_clusters[run_len] = cluster;
                        run_offsets[run_len] = k;
                        run_len++;
                    }
                    if (run_len >= count) {
                        for (int j = 0; j < count; j++) {
                            out_clusters[j] = run_clusters[j];
                            out_offsets[j] = run_offsets[j];
                        }
                        return 0;
                    }
                    // Need more entries - allocate new cluster(s)
                    last_cluster = cluster;
                    goto need_more;
                }
            } else {
                // Entry is used, reset run
                run_len = 0;
            }
        }

        last_cluster = cluster;
        cluster = fat_next_cluster(cluster);
    }

need_more:
    // We need to allocate new cluster(s) to complete the run
    while (run_len < count) {
        uint32_t new_cluster = fat_alloc_cluster();
        if (new_cluster == 0) return -1;

        // Link to chain
        if (fat_set_cluster(last_cluster, new_cluster) < 0) {
            fat_set_cluster(new_cluster, FAT32_FREE);
            return -1;
        }

        // Zero the new cluster
        if (zero_cluster(new_cluster) < 0) {
            return -1;
        }

        // Add entries from this cluster to the run
        for (int i = 0; i < entries_per_cluster && run_len < count; i++) {
            run_clusters[run_len] = new_cluster;
            run_offsets[run_len] = i;
            run_len++;
        }

        last_cluster = new_cluster;
    }

    // Copy to output
    for (int j = 0; j < count; j++) {
        out_clusters[j] = run_clusters[j];
        out_offsets[j] = run_offsets[j];
    }
    return 0;
}

// Legacy wrapper for single entry
static int find_free_dir_entry(uint32_t dir_cluster, uint32_t *out_cluster, uint32_t *out_offset) {
    return find_free_dir_entries(dir_cluster, 1, out_cluster, out_offset);
}

// Build an LFN entry at the given buffer location
// seq: sequence number (1 = first, 2 = second, etc.)
// is_last: set the "last" flag (0x40)
// name: full long filename
// checksum: checksum of the 8.3 short name
static void build_lfn_entry(uint8_t *e, int seq, int is_last, const char *name, uint8_t checksum) {
    int name_len = strlen(name);
    int start = (seq - 1) * 13;  // Starting character index for this entry

    memset(e, 0xFF, 32);  // Fill with 0xFF (unused chars are 0xFFFF in UTF-16)

    // Order byte: sequence number, with 0x40 flag if last entry
    e[0] = seq | (is_last ? 0x40 : 0);

    // Attribute = LFN (0x0F)
    e[11] = FAT_ATTR_LFN;

    // Type = 0
    e[12] = 0;

    // Checksum of short name
    e[13] = checksum;

    // First cluster = 0 (always for LFN)
    e[26] = 0;
    e[27] = 0;

    // Fill in the 13 characters for this entry
    // name1: bytes 1-10 (5 UTF-16LE chars)
    for (int i = 0; i < 5; i++) {
        int idx = start + i;
        if (idx < name_len) {
            e[1 + i*2] = (uint8_t)name[idx];  // Low byte
            e[2 + i*2] = 0;                    // High byte (ASCII, so always 0)
        } else if (idx == name_len) {
            // Null terminator
            e[1 + i*2] = 0;
            e[2 + i*2] = 0;
        }
        // else leave as 0xFFFF (already set)
    }

    // name2: bytes 14-25 (6 UTF-16LE chars)
    for (int i = 0; i < 6; i++) {
        int idx = start + 5 + i;
        if (idx < name_len) {
            e[14 + i*2] = (uint8_t)name[idx];
            e[15 + i*2] = 0;
        } else if (idx == name_len) {
            e[14 + i*2] = 0;
            e[15 + i*2] = 0;
        }
    }

    // name3: bytes 28-31 (2 UTF-16LE chars)
    for (int i = 0; i < 2; i++) {
        int idx = start + 11 + i;
        if (idx < name_len) {
            e[28 + i*2] = (uint8_t)name[idx];
            e[29 + i*2] = 0;
        } else if (idx == name_len) {
            e[28 + i*2] = 0;
            e[29 + i*2] = 0;
        }
    }
}

// Create a new directory entry in a directory (with LFN support)
// Returns 1 on success, 0 on error
static uint32_t create_dir_entry(uint32_t parent_cluster, const char *name, uint8_t attr, uint32_t first_cluster) {
    int name_len = strlen(name);
    int use_lfn = needs_lfn(name);

    // Calculate how many entries we need
    int lfn_entries = 0;
    if (use_lfn) {
        lfn_entries = (name_len + 12) / 13;  // Ceiling division
    }
    int total_entries = lfn_entries + 1;  // LFN entries + 1 short entry

    // Sanity check
    if (total_entries > 32) {
        return 0;  // Filename too long
    }

    // Generate short name FIRST (before finding entries, since this also reads clusters)
    char short_name[11];
    if (use_lfn) {
        generate_short_name(parent_cluster, name, short_name);
    } else {
        str_to_fat_name(name, short_name);
    }

    // Find consecutive free entries AFTER generating short name
    uint32_t entry_clusters[32];
    uint32_t entry_offsets[32];

    if (find_free_dir_entries(parent_cluster, total_entries, entry_clusters, entry_offsets) < 0) {
        return 0;
    }

    // Calculate checksum of short name (needed for LFN entries)
    uint8_t checksum = fat_checksum(short_name);

    // Write LFN entries (in reverse order: highest sequence number first)
    for (int i = 0; i < lfn_entries; i++) {
        int seq = lfn_entries - i;  // Sequence numbers go from N down to 1
        int is_last = (i == 0);     // First entry written is "last" in sequence

        uint32_t clust = entry_clusters[i];
        uint32_t offs = entry_offsets[i];

        // Read cluster
        if (read_cluster(clust, cluster_buf) < 0) {
            return 0;
        }

        // Build LFN entry
        uint8_t *e = cluster_buf + (offs * 32);
        build_lfn_entry(e, seq, is_last, name, checksum);

        // Write cluster back
        if (write_cluster(clust, cluster_buf) < 0) {
            return 0;
        }
    }

    // Write the short (8.3) entry
    uint32_t short_cluster = entry_clusters[lfn_entries];
    uint32_t short_offset = entry_offsets[lfn_entries];

    if (read_cluster(short_cluster, cluster_buf) < 0) {
        return 0;
    }

    uint8_t *e = cluster_buf + (short_offset * 32);
    memset(e, 0, 32);

    // Copy short name
    memcpy(e, short_name, 11);

    // Set attributes
    e[11] = attr;

    // Set cluster (if provided)
    write16(e + 20, (first_cluster >> 16) & 0xFFFF);  // cluster_hi
    write16(e + 26, first_cluster & 0xFFFF);          // cluster_lo

    // Size is 0 for new files/directories
    write32(e + 28, 0);

    // Write back the cluster
    if (write_cluster(short_cluster, cluster_buf) < 0) {
        return 0;
    }

    return 1;  // Success
}

// Update an existing directory entry's size and cluster
static int update_dir_entry(uint32_t dir_cluster, const char *name, uint32_t first_cluster, uint32_t size) {
    uint32_t entry_cluster, entry_offset;
    fat32_dirent_t *entry = find_entry_in_dir(dir_cluster, name, &entry_cluster, &entry_offset);

    if (!entry) return -1;

    // Read the cluster containing the entry
    if (read_cluster(entry_cluster, cluster_buf) < 0) {
        return -1;
    }

    // Update the entry
    uint8_t *e = cluster_buf + (entry_offset * 32);
    write16(e + 20, (first_cluster >> 16) & 0xFFFF);  // cluster_hi
    write16(e + 26, first_cluster & 0xFFFF);          // cluster_lo
    write32(e + 28, size);

    // Write back
    return write_cluster(entry_cluster, cluster_buf);
}

int fat32_create_file(const char *path) {
    if (!fs_initialized) return -1;

    char filename[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, filename) < 0) {
        return -1;
    }

    // Check if already exists
    fat32_dirent_t *existing = find_entry_in_dir(parent_cluster, filename, NULL, NULL);
    if (existing) {
        return 0;  // Already exists, that's fine
    }

    // Create directory entry with no cluster (empty file)
    if (!create_dir_entry(parent_cluster, filename, FAT_ATTR_ARCHIVE, 0)) {
        return -1;
    }

    return 0;
}

int fat32_mkdir(const char *path) {
    if (!fs_initialized) return -1;

    char dirname[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, dirname) < 0) {
        return -1;
    }

    // Check if already exists
    fat32_dirent_t *existing = find_entry_in_dir(parent_cluster, dirname, NULL, NULL);
    if (existing) {
        return -1;  // Already exists
    }

    // Allocate cluster for directory contents
    uint32_t dir_cluster = fat_alloc_cluster();
    if (dir_cluster == 0) {
        return -1;
    }

    // Zero the cluster
    if (zero_cluster(dir_cluster) < 0) {
        fat_set_cluster(dir_cluster, FAT32_FREE);
        return -1;
    }

    // Create . and .. entries in the new directory
    if (read_cluster(dir_cluster, cluster_buf) < 0) {
        fat_set_cluster(dir_cluster, FAT32_FREE);
        return -1;
    }

    // "." entry
    uint8_t *e = cluster_buf;
    memset(e, ' ', 11);
    e[0] = '.';
    e[11] = FAT_ATTR_DIRECTORY;
    write16(e + 20, (dir_cluster >> 16) & 0xFFFF);
    write16(e + 26, dir_cluster & 0xFFFF);

    // ".." entry
    e = cluster_buf + 32;
    memset(e, ' ', 11);
    e[0] = '.';
    e[1] = '.';
    e[11] = FAT_ATTR_DIRECTORY;
    write16(e + 20, (parent_cluster >> 16) & 0xFFFF);
    write16(e + 26, parent_cluster & 0xFFFF);

    if (write_cluster(dir_cluster, cluster_buf) < 0) {
        fat_set_cluster(dir_cluster, FAT32_FREE);
        return -1;
    }

    // Create entry in parent directory
    if (!create_dir_entry(parent_cluster, dirname, FAT_ATTR_DIRECTORY, dir_cluster)) {
        fat_set_cluster(dir_cluster, FAT32_FREE);
        return -1;
    }

    return 0;
}

int fat32_write_file(const char *path, const void *buf, size_t size) {
    if (!fs_initialized) return -1;

    char filename[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, filename) < 0) {
        return -1;
    }

    // Find or create the file
    fat32_dirent_t *entry = find_entry_in_dir(parent_cluster, filename, NULL, NULL);
    uint32_t old_cluster = 0;

    if (entry) {
        // File exists - get its current cluster chain to free later
        old_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;
        if (entry->attr & FAT_ATTR_DIRECTORY) {
            return -1;  // Can't write to a directory
        }
    } else {
        // Create new file entry
        if (!create_dir_entry(parent_cluster, filename, FAT_ATTR_ARCHIVE, 0)) {
            return -1;
        }
    }

    // Calculate clusters needed
    uint32_t cluster_size = cluster_buf_size;
    uint32_t clusters_needed = (size + cluster_size - 1) / cluster_size;
    if (clusters_needed == 0 && size > 0) clusters_needed = 1;

    // Allocate cluster chain for new data
    uint32_t first_cluster = 0;
    uint32_t prev_cluster = 0;
    const uint8_t *src = (const uint8_t *)buf;
    size_t remaining = size;

    for (uint32_t i = 0; i < clusters_needed; i++) {
        uint32_t cluster = fat_alloc_cluster();
        if (cluster == 0) {
            // Out of space - free what we allocated
            if (first_cluster) fat_free_chain(first_cluster);
            return -1;
        }

        if (first_cluster == 0) {
            first_cluster = cluster;
        }

        if (prev_cluster) {
            // Link previous cluster to this one
            fat_set_cluster(prev_cluster, cluster);
        }

        // Write data to this cluster
        size_t to_write = remaining > cluster_size ? cluster_size : remaining;
        memset(cluster_buf, 0, cluster_size);
        memcpy(cluster_buf, src, to_write);

        if (write_cluster(cluster, cluster_buf) < 0) {
            fat_free_chain(first_cluster);
            return -1;
        }

        src += to_write;
        remaining -= to_write;
        prev_cluster = cluster;
    }

    // Update directory entry with new cluster and size
    if (update_dir_entry(parent_cluster, filename, first_cluster, size) < 0) {
        if (first_cluster) fat_free_chain(first_cluster);
        return -1;
    }

    // Free old cluster chain
    if (old_cluster >= 2 && old_cluster < FAT32_EOC) {
        fat_free_chain(old_cluster);
    }

    return (int)size;
}

// Delete a directory entry including its LFN entries
// This finds all LFN entries associated with the 8.3 entry and marks them all as deleted
static int delete_dir_entry_with_lfn(uint32_t dir_cluster, const char *name) {
    uint32_t cluster = dir_cluster;

    // We need to track LFN entries that might precede the 8.3 entry
    // Store positions of LFN entries in the current "run"
    uint32_t lfn_clusters[32];
    uint32_t lfn_offsets[32];
    int lfn_count = 0;

    char entry_name[256];
    char lfn_name[256];
    int has_lfn = 0;

    while (cluster >= 2 && cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        int entries_per_cluster = cluster_buf_size / 32;

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + (i * 32);
            uint8_t first_byte = e[0];
            uint8_t attr = e[11];

            // End of directory
            if (first_byte == 0x00) {
                return -1;  // Not found
            }

            // Deleted entry - reset LFN tracking
            if (first_byte == 0xE5) {
                has_lfn = 0;
                lfn_count = 0;
                continue;
            }

            // Long filename entry
            if (attr == FAT_ATTR_LFN) {
                uint8_t order = first_byte;
                int seq = order & 0x1F;
                int is_last = order & 0x40;

                if (is_last) {
                    has_lfn = 1;
                    lfn_count = 0;
                    memset(lfn_name, 0, sizeof(lfn_name));
                }

                // Track this LFN entry's position
                if (lfn_count < 32) {
                    lfn_clusters[lfn_count] = cluster;
                    lfn_offsets[lfn_count] = i;
                    lfn_count++;
                }

                // Extract characters from LFN entry
                int base = (seq - 1) * 13;
                for (int j = 0; j < 5; j++) {
                    uint16_t c = e[1 + j*2] | (e[2 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + j < 255) lfn_name[base + j] = (char)c;
                }
                for (int j = 0; j < 6; j++) {
                    uint16_t c = e[14 + j*2] | (e[15 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 5 + j < 255) lfn_name[base + 5 + j] = (char)c;
                }
                for (int j = 0; j < 2; j++) {
                    uint16_t c = e[28 + j*2] | (e[29 + j*2] << 8);
                    if (c == 0 || c == 0xFFFF) break;
                    if (base + 11 + j < 255) lfn_name[base + 11 + j] = (char)c;
                }
                continue;
            }

            // Regular entry - skip volume label
            if (attr & FAT_ATTR_VOLUME_ID) {
                has_lfn = 0;
                lfn_count = 0;
                continue;
            }

            // Get the name to compare
            if (has_lfn) {
                int k;
                for (k = 0; lfn_name[k]; k++) {
                    entry_name[k] = lfn_name[k];
                }
                entry_name[k] = '\0';
            } else {
                fat_name_to_str((char *)e, entry_name);
            }

            // Check if this is the entry we want to delete
            if (name_match(entry_name, name)) {
                // Found it! Now delete all associated entries

                // First, delete LFN entries
                for (int j = 0; j < lfn_count; j++) {
                    if (read_cluster(lfn_clusters[j], cluster_buf) < 0) {
                        return -1;
                    }
                    cluster_buf[lfn_offsets[j] * 32] = 0xE5;
                    if (write_cluster(lfn_clusters[j], cluster_buf) < 0) {
                        return -1;
                    }
                }

                // Then delete the 8.3 entry
                if (read_cluster(cluster, cluster_buf) < 0) {
                    return -1;
                }
                cluster_buf[i * 32] = 0xE5;
                if (write_cluster(cluster, cluster_buf) < 0) {
                    return -1;
                }

                return 0;  // Success
            }

            // Reset LFN tracking for next entry
            has_lfn = 0;
            lfn_count = 0;
        }

        cluster = fat_next_cluster(cluster);
    }

    return -1;  // Not found
}

int fat32_delete(const char *path) {
    if (!fs_initialized) return -1;

    char filename[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, filename) < 0) {
        return -1;
    }

    // Find the entry
    uint32_t entry_cluster, entry_offset;
    fat32_dirent_t *entry = find_entry_in_dir(parent_cluster, filename, &entry_cluster, &entry_offset);
    if (!entry) return -1;

    // Don't allow deleting directories with this function
    if (entry->attr & FAT_ATTR_DIRECTORY) {
        return -1;
    }

    // Free the cluster chain
    uint32_t first_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;
    if (first_cluster >= 2 && first_cluster < FAT32_EOC) {
        fat_free_chain(first_cluster);
    }

    // Delete the directory entry (including any LFN entries)
    return delete_dir_entry_with_lfn(parent_cluster, filename);
}

int fat32_rename(const char *oldpath, const char *newname) {
    if (!fs_initialized) return -1;

    char filename[256];
    uint32_t parent_cluster;

    if (parse_parent_path(oldpath, &parent_cluster, filename) < 0) {
        return -1;
    }

    // Find the existing entry to get its attributes, cluster, and size
    uint32_t entry_cluster, entry_offset;
    fat32_dirent_t *entry = find_entry_in_dir(parent_cluster, filename, &entry_cluster, &entry_offset);
    if (!entry) return -1;

    // Save the entry's data
    uint8_t attr = entry->attr;
    uint32_t first_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;
    uint32_t size = entry->size;

    // Delete the old entry (including LFN)
    if (delete_dir_entry_with_lfn(parent_cluster, filename) < 0) {
        return -1;
    }

    // Create a new entry with the new name (with LFN if needed)
    if (!create_dir_entry(parent_cluster, newname, attr, first_cluster)) {
        return -1;
    }

    // Update the size in the new entry (create_dir_entry sets it to 0)
    if (size > 0) {
        if (update_dir_entry(parent_cluster, newname, first_cluster, size) < 0) {
            return -1;
        }
    }

    return 0;
}

// Check if directory is empty (only has . and ..)
static int is_dir_empty(uint32_t dir_cluster) {
    uint32_t cluster = dir_cluster;

    while (cluster >= 2 && cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        int entries_per_cluster = (fs.sectors_per_cluster * fs.bytes_per_sector) / 32;

        for (int i = 0; i < entries_per_cluster; i++) {
            fat32_dirent_t *entry = (fat32_dirent_t *)(cluster_buf + i * 32);

            // End of directory
            if (entry->name[0] == 0x00) {
                return 1;  // Empty
            }

            // Deleted entry - skip
            if ((uint8_t)entry->name[0] == 0xE5) {
                continue;
            }

            // LFN entry - skip
            if ((entry->attr & FAT_ATTR_LFN) == FAT_ATTR_LFN) {
                continue;
            }

            // Check if it's . or ..
            if (entry->name[0] == '.' && (entry->name[1] == ' ' || entry->name[1] == '.')) {
                continue;
            }

            // Found a real entry - not empty
            return 0;
        }

        cluster = fat_next_cluster(cluster);
    }

    return 1;  // Empty
}

int fat32_delete_dir(const char *path) {
    if (!fs_initialized) return -1;

    char dirname[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, dirname) < 0) {
        return -1;
    }

    // Find the entry
    uint32_t entry_cluster, entry_offset;
    fat32_dirent_t *entry = find_entry_in_dir(parent_cluster, dirname, &entry_cluster, &entry_offset);
    if (!entry) return -1;

    // Must be a directory
    if (!(entry->attr & FAT_ATTR_DIRECTORY)) {
        return -1;
    }

    // Get the directory's cluster
    uint32_t dir_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;

    // Check if directory is empty
    if (!is_dir_empty(dir_cluster)) {
        return -1;  // Directory not empty
    }

    // Free the cluster chain
    if (dir_cluster >= 2 && dir_cluster < FAT32_EOC) {
        fat_free_chain(dir_cluster);
    }

    // Delete the directory entry (including any LFN entries)
    return delete_dir_entry_with_lfn(parent_cluster, dirname);
}

// Forward declaration for recursion
int fat32_delete_recursive(const char *path);

// Helper to delete all contents of a directory
static int delete_dir_contents(const char *dir_path) {
    // Open directory to iterate
    uint32_t dir_cluster;

    // Resolve the directory path
    if (strcmp(dir_path, "/") == 0) {
        dir_cluster = fs.root_cluster;
    } else {
        uint32_t dummy;
        fat32_dirent_t *entry = resolve_path(dir_path, &dummy);
        if (!entry || !(entry->attr & FAT_ATTR_DIRECTORY)) {
            return -1;
        }
        dir_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;
    }

    uint32_t cluster = dir_cluster;
    char entry_name[256];
    char child_path[512];

    while (cluster >= 2 && cluster < FAT32_EOC) {
        if (read_cluster(cluster, cluster_buf) < 0) {
            return -1;
        }

        int entries_per_cluster = (fs.sectors_per_cluster * fs.bytes_per_sector) / 32;

        for (int i = 0; i < entries_per_cluster; i++) {
            uint8_t *e = cluster_buf + i * 32;

            // End of directory
            if (e[0] == 0x00) {
                return 0;  // Done, directory is now empty
            }

            // Deleted entry - skip
            if (e[0] == 0xE5) {
                continue;
            }

            // LFN entry - skip (will be deleted with 8.3 entry)
            if ((e[11] & FAT_ATTR_LFN) == FAT_ATTR_LFN) {
                continue;
            }

            // Get entry name
            fat_name_to_str((char *)e, entry_name);

            // Skip . and ..
            if (strcmp(entry_name, ".") == 0 || strcmp(entry_name, "..") == 0) {
                continue;
            }

            // Build full path
            if (strcmp(dir_path, "/") == 0) {
                strcpy(child_path, "/");
                strcat(child_path, entry_name);
            } else {
                strcpy(child_path, dir_path);
                strcat(child_path, "/");
                strcat(child_path, entry_name);
            }

            // Delete this entry (recursively if directory)
            if (fat32_delete_recursive(child_path) < 0) {
                return -1;
            }

            // Re-read cluster as it may have been modified
            if (read_cluster(cluster, cluster_buf) < 0) {
                return -1;
            }
        }

        cluster = fat_next_cluster(cluster);
    }

    return 0;
}

int fat32_delete_recursive(const char *path) {
    if (!fs_initialized) return -1;

    char name[256];
    uint32_t parent_cluster;

    if (parse_parent_path(path, &parent_cluster, name) < 0) {
        return -1;
    }

    // Find the entry
    uint32_t entry_cluster, entry_offset;
    fat32_dirent_t *entry = find_entry_in_dir(parent_cluster, name, &entry_cluster, &entry_offset);
    if (!entry) return -1;

    uint8_t is_dir = entry->attr & FAT_ATTR_DIRECTORY;
    uint32_t first_cluster = ((uint32_t)entry->cluster_hi << 16) | entry->cluster_lo;

    if (is_dir) {
        // First delete all contents recursively
        if (delete_dir_contents(path) < 0) {
            return -1;
        }
    }

    // Free the cluster chain
    if (first_cluster >= 2 && first_cluster < FAT32_EOC) {
        fat_free_chain(first_cluster);
    }

    // Delete the directory entry (including any LFN entries)
    return delete_dir_entry_with_lfn(parent_cluster, name);
}

// Get total disk space in KB
int fat32_get_total_kb(void) {
    if (!fs_initialized) return 0;
    // total_clusters * sectors_per_cluster * bytes_per_sector / 1024
    uint64_t total_bytes = (uint64_t)fs.total_clusters * fs.sectors_per_cluster * fs.bytes_per_sector;
    return (int)(total_bytes / 1024);
}

// Get free disk space in KB (counts free clusters in FAT)
int fat32_get_free_kb(void) {
    if (!fs_initialized) return 0;

    uint32_t free_clusters = 0;
    for (uint32_t cluster = 2; cluster < fs.total_clusters + 2; cluster++) {
        uint32_t entry = fat_next_cluster(cluster);
        if (entry == FAT32_FREE) {
            free_clusters++;
        }
    }

    uint64_t free_bytes = (uint64_t)free_clusters * fs.sectors_per_cluster * fs.bytes_per_sector;
    return (int)(free_bytes / 1024);
}
</file>

<file path="kernel/shell.c">
/*
 * VibeOS Shell Bootstrap
 *
 * Launches /bin/vibesh on boot. Falls back to a minimal recovery shell
 * if vibesh is not found.
 */

#include "shell.h"
#include "console.h"
#include "keyboard.h"
#include "string.h"
#include "printf.h"
#include "fb.h"
#include "vfs.h"
#include "process.h"
#include <stddef.h>

void shell_init(void) {
    // Nothing to initialize
}

void shell_run(void) {
    console_puts("\n");
    console_set_color(COLOR_AMBER, COLOR_BLACK);
    console_puts("VibeOS v0.1\n");
    console_set_color(COLOR_WHITE, COLOR_BLACK);

    // Try to launch vibesh
    vfs_node_t *vibesh = vfs_lookup("/bin/vibesh");
    if (vibesh) {
        console_puts("Starting vibesh...\n\n");
        int result = process_exec("/bin/vibesh");

        // If we get here, vibesh exited
        console_puts("\nvibesh exited with status ");
        printf("%d\n", result);
    } else {
        console_set_color(COLOR_RED, COLOR_BLACK);
        console_puts("ERROR: /bin/vibesh not found!\n");
        console_set_color(COLOR_WHITE, COLOR_BLACK);
        console_puts("Make sure to run 'make install-user' to install userspace programs.\n");
    }

    // Fallback: minimal recovery loop
    console_puts("\n[Recovery Mode - type 'gui' to launch desktop, 'reboot' to restart]\n");

    char cmd[64];
    int pos = 0;

    while (1) {
        console_set_color(COLOR_RED, COLOR_BLACK);
        console_puts("recovery> ");
        console_set_color(COLOR_WHITE, COLOR_BLACK);

        pos = 0;
        while (1) {
            int c = keyboard_getc();
            if (c < 0) {
                // No input - sleep until next interrupt
                asm volatile("wfi");
                continue;
            }

            if (c == '\r' || c == '\n') {
                console_putc('\n');
                cmd[pos] = '\0';
                break;
            } else if ((c == '\b' || c == 127) && pos > 0) {
                pos--;
                console_putc('\b');
                console_putc(' ');
                console_putc('\b');
            } else if (c >= 32 && c < 127 && pos < 63) {
                cmd[pos++] = (char)c;
                console_putc((char)c);
            }
        }

        if (strcmp(cmd, "gui") == 0) {
            process_exec("/bin/desktop");
        } else if (strcmp(cmd, "vibesh") == 0) {
            process_exec("/bin/vibesh");
        } else if (strcmp(cmd, "reboot") == 0) {
            console_puts("Rebooting not implemented. Please close QEMU.\n");
        } else if (pos > 0) {
            console_puts("Unknown command. Try 'gui', 'vibesh', or 'reboot'.\n");
        }
    }
}
</file>

<file path="kernel/kernel.c">
/*
 * VibeOS Kernel
 *
 * The main kernel entry point and core functionality.
 */

#include <stdint.h>
#include "memory.h"
#include "string.h"
#include "printf.h"
#include "fb.h"
#include "console.h"
#include "keyboard.h"
#include "shell.h"
#include "vfs.h"
#include "process.h"
#include "initramfs.h"
#include "kapi.h"
#include "virtio_blk.h"
#include "mouse.h"
#include "irq.h"
#include "rtc.h"
#include "virtio_sound.h"
#include "virtio_net.h"
#include "net.h"

// QEMU virt machine PL011 UART base address
#define UART0_BASE 0x09000000

// PL011 UART registers
#define UART_DR     (*(volatile uint32_t *)(UART0_BASE + 0x00))  // Data Register
#define UART_FR     (*(volatile uint32_t *)(UART0_BASE + 0x18))  // Flag Register
#define UART_FR_TXFF (1 << 5)  // Transmit FIFO Full
#define UART_FR_RXFE (1 << 4)  // Receive FIFO Empty

void uart_putc(char c) {
    // Wait until transmit FIFO is not full
    while (UART_FR & UART_FR_TXFF) {
        asm volatile("nop");
    }
    UART_DR = c;
}

void uart_puts(const char *s) {
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

int uart_getc(void) {
    // Return -1 if no data available
    if (UART_FR & UART_FR_RXFE) {
        return -1;
    }
    return UART_DR & 0xFF;
}

int uart_getc_blocking(void) {
    // Wait for data
    while (UART_FR & UART_FR_RXFE) {
        asm volatile("nop");
    }
    return UART_DR & 0xFF;
}

void kernel_main(void) {
    // Raw UART test first
    uart_putc('V');
    uart_putc('I');
    uart_putc('B');
    uart_putc('E');
    uart_putc('\r');
    uart_putc('\n');

    // Test printf with simplest possible case
    uart_putc('1');
    printf("test");
    uart_putc('2');
    printf("\n");
    printf("     \n");
    printf("    \n");
    printf("    \n");
    printf("\n");
    printf("VibeOS v0.1 - aarch64\n");
    printf("=====================\n\n");
    printf("[BOOT] Kernel loaded successfully!\n");
    printf("[BOOT] UART initialized.\n");

    // Initialize memory management
    memory_init();
    printf("[BOOT] Memory initialized.\n");
    printf("       Heap: %p - %p\n", (void *)heap_start, (void *)heap_end);
    printf("       Free: %lu MB\n", memory_free() / 1024 / 1024);

    // Test malloc
    printf("[TEST] Testing malloc...\n");
    char *test1 = malloc(100);
    char *test2 = malloc(200);
    printf("       Allocated 100 bytes at: %p\n", test1);
    printf("       Allocated 200 bytes at: %p\n", test2);

    // Write something to prove it works
    strcpy(test1, "Hi from printf!");
    printf("       Wrote to memory: %s\n", test1);

    // Free and check
    free(test1);
    free(test2);
    printf("       Freed allocations. Free: %lu MB\n", memory_free() / 1024 / 1024);

    printf("[BOOT] Running on QEMU virt machine.\n");

    // Initialize framebuffer
    if (fb_init() == 0) {
        // Initialize console
        console_init();
        printf("[FB] Console initialized: %dx%d chars\n", console_cols(), console_rows());

        // Print to console (on screen!)
        console_set_color(COLOR_GREEN, COLOR_BLACK);
        console_puts("  _   _ _ _          ___  ____  \n");
        console_puts(" | | | (_) |__   ___/ _ \\/ ___| \n");
        console_puts(" | | | | | '_ \\ / _ \\ | | \\___ \\ \n");
        console_puts(" | \\_/ | | |_) |  __/ |_| |___) |\n");
        console_puts("  \\___/|_|_.__/ \\___|\\___/|____/ \n");
        console_set_color(COLOR_WHITE, COLOR_BLACK);
        console_puts("                            by ");
        console_set_color(COLOR_AMBER, COLOR_BLACK);
        console_puts("Claude\n");
        console_puts("\n");
        console_set_color(COLOR_WHITE, COLOR_BLACK);
        console_puts("==========================================\n\n");

        console_set_color(COLOR_GREEN, COLOR_BLACK);
        console_puts("The vibes are immaculate.\n\n");

        console_set_color(COLOR_WHITE, COLOR_BLACK);
        console_puts("System ready.\n");
        console_puts("\n");
    }

    // Initialize interrupt controller (GIC)
    irq_init();

    // Initialize timer (10ms tick = 100 ticks/second)
    timer_init(10);

    // Initialize RTC (real time clock)
    rtc_init();

    // Initialize keyboard
    keyboard_init();

    // Register keyboard IRQ handler
    uint32_t kbd_irq = keyboard_get_irq();
    if (kbd_irq > 0) {
        irq_register_handler(kbd_irq, keyboard_irq_handler);
        irq_enable_irq(kbd_irq);
        printf("[KERNEL] Keyboard IRQ %d registered\n", kbd_irq);
    }

    // Initialize mouse (for GUI)
    mouse_init();

    // Register mouse IRQ handler
    uint32_t mouse_irq = mouse_get_irq();
    if (mouse_irq > 0) {
        irq_register_handler(mouse_irq, mouse_irq_handler);
        irq_enable_irq(mouse_irq);
        printf("[KERNEL] Mouse IRQ %d registered\n", mouse_irq);
    }

    // Initialize block device (for persistent storage)
    virtio_blk_init();

    // Initialize sound device (for audio playback)
    virtio_sound_init();

    // Initialize network device
    virtio_net_init();

    // Register network IRQ handler
    uint32_t net_irq = virtio_net_get_irq();
    if (net_irq > 0) {
        irq_register_handler(net_irq, virtio_net_irq_handler);
        irq_enable_irq(net_irq);
        printf("[KERNEL] Network IRQ %d registered\n", net_irq);
    }

    // Initialize network stack (IP, ARP, ICMP)
    net_init();

    // Initialize filesystem (will use FAT32 if disk available)
    vfs_init();

    // Initialize kernel API (for userspace programs)
    kapi_init();
    printf("[KERNEL] Kernel API initialized\n");

    // Initialize process subsystem
    process_init();

    // Load embedded binaries into VFS
    initramfs_init();

    // Enable interrupts now that everything is initialized
    printf("[KERNEL] Enabling interrupts...\n");
    irq_enable();
    printf("[KERNEL] Interrupts enabled!\n");

    printf("\n");
    printf("[KERNEL] Starting shell...\n");

    // Run the shell
    shell_run();

    // Should never reach here
    while (1) {
        asm volatile("wfi");
    }
}
</file>

<file path="user/bin/desktop.c">
/*
 * VibeOS Desktop - Window Manager
 *
 * Classic Mac System 7 aesthetic - TRUE 1-bit black & white.
 * Manages windows for GUI apps, dock, menu bar.
 *
 * Fullscreen apps (snake, tetris) are launched with exec() and take over.
 * Windowed apps use the window API registered in kapi.
 */

#include "vibe.h"
#include "../lib/gfx.h"
#include "../lib/icons.h"

// Screen dimensions (set dynamically from kapi)
static int SCREEN_WIDTH;
static int SCREEN_HEIGHT;

// UI dimensions
#define MENU_BAR_HEIGHT 20
#define DOCK_HEIGHT     52
#define TITLE_BAR_HEIGHT 20

// 1-bit Colors - TRUE Mac System 7 black & white
#define COLOR_BLACK      0x00000000
#define COLOR_WHITE      0x00FFFFFF

// Semantic color aliases (all B&W)
#define COLOR_DESKTOP    COLOR_BLACK   // We'll dither this
#define COLOR_MENU_BG    COLOR_WHITE
#define COLOR_MENU_TEXT  COLOR_BLACK
#define COLOR_TITLE_BG   COLOR_WHITE
#define COLOR_TITLE_TEXT COLOR_BLACK
#define COLOR_WIN_BG     COLOR_WHITE
#define COLOR_WIN_BORDER COLOR_BLACK
#define COLOR_DOCK_BG    COLOR_WHITE
#define COLOR_HIGHLIGHT  COLOR_BLACK

// Window limits
#define MAX_WINDOWS 16
#define MAX_TITLE_LEN 32

// Event structure
typedef struct {
    int type;
    int data1;
    int data2;
    int data3;
} win_event_t;

// Window structure
typedef struct {
    int active;           // Is this slot in use?
    int x, y, w, h;       // Position and size (including title bar)
    char title[MAX_TITLE_LEN];
    uint32_t *buffer;     // Content buffer (w * (h - TITLE_BAR_HEIGHT))
    int dirty;            // Needs redraw?
    int pid;              // Owner process ID (0 = desktop owns it)

    // Event queue (ring buffer)
    win_event_t events[32];
    int event_head;
    int event_tail;
} window_t;

// Dock icon
typedef struct {
    int x, y, w, h;
    const char *label;
    const char *exec_path;
    int is_fullscreen;    // If true, use exec() instead of spawn()
} dock_icon_t;

// Global state
static kapi_t *api;
static uint32_t *backbuffer;
static gfx_ctx_t gfx;  // Graphics context for backbuffer
static window_t windows[MAX_WINDOWS];
static int window_order[MAX_WINDOWS];  // Z-order: window_order[0] is topmost
static int window_count = 0;
static int focused_window = -1;

// Mouse state
static int mouse_x, mouse_y;
static int mouse_prev_x, mouse_prev_y;
static uint8_t mouse_buttons;
static uint8_t mouse_prev_buttons;

// Dragging state
static int dragging_window = -1;
static int drag_offset_x, drag_offset_y;

// Resizing state
static int resizing_window = -1;
static int resize_start_w, resize_start_h;
static int resize_start_mx, resize_start_my;

// Desktop running flag
static int running = 1;

// Menu system
#define MENU_NONE   -1
#define MENU_APPLE   0
#define MENU_FILE    1
#define MENU_EDIT    2

static int open_menu = MENU_NONE;  // Currently open menu (-1 = none)

// Menu item structure
typedef struct {
    const char *label;   // NULL = separator
    int action;          // Action ID
} menu_item_t;

// Action IDs
#define ACTION_NONE           0
#define ACTION_ABOUT          1
#define ACTION_QUIT           2
#define ACTION_NEW_WINDOW     3
#define ACTION_CLOSE_WINDOW   4
#define ACTION_CUT            5
#define ACTION_COPY           6
#define ACTION_PASTE          7

// Apple menu items
static const menu_item_t apple_menu[] = {
    { "About This Computer", ACTION_ABOUT },
    { NULL, 0 },  // separator
    { "Quit Desktop", ACTION_QUIT },
    { NULL, -1 }  // end marker
};

// File menu items
static const menu_item_t file_menu[] = {
    { "New Terminal", ACTION_NEW_WINDOW },
    { "Close Window", ACTION_CLOSE_WINDOW },
    { NULL, -1 }
};

// Edit menu items
static const menu_item_t edit_menu[] = {
    { "Cut", ACTION_CUT },
    { "Copy", ACTION_COPY },
    { "Paste", ACTION_PASTE },
    { NULL, -1 }
};

// Forward declarations
static void draw_desktop(void);
static void draw_window(int wid);
static void draw_dock(void);
static void draw_menu_bar(void);
static void flip_buffer(void);
static void draw_about_dialog(void);

// About dialog state (declared here so draw_desktop can see it)
static int show_about_dialog = 0;

// ============ Backbuffer Drawing (wrappers around gfx lib) ============

#define bb_put_pixel(x, y, c)           gfx_put_pixel(&gfx, x, y, c)
#define bb_fill_rect(x, y, w, h, c)     gfx_fill_rect(&gfx, x, y, w, h, c)
#define bb_draw_char(x, y, ch, fg, bg)  gfx_draw_char(&gfx, x, y, ch, fg, bg)
#define bb_draw_string(x, y, s, fg, bg) gfx_draw_string(&gfx, x, y, s, fg, bg)
#define bb_draw_hline(x, y, w, c)       gfx_draw_hline(&gfx, x, y, w, c)
#define bb_draw_vline(x, y, h, c)       gfx_draw_vline(&gfx, x, y, h, c)
#define bb_draw_rect(x, y, w, h, c)     gfx_draw_rect(&gfx, x, y, w, h, c)
#define bb_fill_pattern(x, y, w, h)     gfx_fill_pattern(&gfx, x, y, w, h, COLOR_BLACK, COLOR_WHITE)

// ============ VibeOS Logo (from icons.h) ============

static void draw_vibeos_logo(int x, int y) {
    for (int py = 0; py < 16; py++) {
        for (int px = 0; px < 16; px++) {
            if (vibeos_logo[py * 16 + px]) {
                bb_put_pixel(x + px, y + py, COLOR_BLACK);
            }
        }
    }
}

// ============ Dock Icons (from icons.h) ============

static void draw_icon_bitmap(int x, int y, const unsigned char *bitmap, int inverted) {
    uint32_t fg = inverted ? COLOR_WHITE : COLOR_BLACK;
    uint32_t bg = inverted ? COLOR_BLACK : COLOR_WHITE;

    for (int py = 0; py < 32; py++) {
        for (int px = 0; px < 32; px++) {
            uint32_t color = bitmap[py * 32 + px] ? fg : bg;
            bb_put_pixel(x + px, y + py, color);
        }
    }
}

// ============ Window Management ============

static int find_free_window(void) {
    for (int i = 0; i < MAX_WINDOWS; i++) {
        if (!windows[i].active) return i;
    }
    return -1;
}

static void bring_to_front(int wid) {
    if (wid < 0 || !windows[wid].active) return;

    // Find current position in z-order
    int pos = -1;
    for (int i = 0; i < window_count; i++) {
        if (window_order[i] == wid) {
            pos = i;
            break;
        }
    }

    if (pos < 0) return;

    // Shift everything down and put this at front
    for (int i = pos; i > 0; i--) {
        window_order[i] = window_order[i - 1];
    }
    window_order[0] = wid;
    focused_window = wid;
}

static int window_at_point(int x, int y) {
    // Check in z-order (front to back)
    for (int i = 0; i < window_count; i++) {
        int wid = window_order[i];
        window_t *w = &windows[wid];
        if (w->active) {
            if (x >= w->x && x < w->x + w->w &&
                y >= w->y && y < w->y + w->h) {
                return wid;
            }
        }
    }
    return -1;
}

static void push_event(int wid, int event_type, int data1, int data2, int data3) {
    if (wid < 0 || !windows[wid].active) return;
    window_t *w = &windows[wid];

    int next = (w->event_tail + 1) % 32;
    if (next == w->event_head) return;  // Queue full

    w->events[w->event_tail].type = event_type;
    w->events[w->event_tail].data1 = data1;
    w->events[w->event_tail].data2 = data2;
    w->events[w->event_tail].data3 = data3;
    w->event_tail = next;
}

// ============ Window API (registered in kapi) ============

static int wm_window_create(int x, int y, int w, int h, const char *title) {
    int wid = find_free_window();
    if (wid < 0) return -1;

    window_t *win = &windows[wid];
    win->active = 1;
    win->x = x;
    win->y = y;
    win->w = w;
    win->h = h;
    win->dirty = 1;
    win->pid = 0;  // TODO: get current process
    win->event_head = 0;
    win->event_tail = 0;

    // Copy title
    int i;
    for (i = 0; i < MAX_TITLE_LEN - 1 && title[i]; i++) {
        win->title[i] = title[i];
    }
    win->title[i] = '\0';

    // Allocate content buffer (excluding title bar)
    int content_h = h - TITLE_BAR_HEIGHT;
    if (content_h < 1) content_h = 1;
    win->buffer = api->malloc(w * content_h * sizeof(uint32_t));
    if (!win->buffer) {
        win->active = 0;
        return -1;
    }

    // Clear to white
    for (int j = 0; j < w * content_h; j++) {
        win->buffer[j] = COLOR_WIN_BG;
    }

    // Add to z-order (at front)
    for (int j = window_count; j > 0; j--) {
        window_order[j] = window_order[j - 1];
    }
    window_order[0] = wid;
    window_count++;
    focused_window = wid;

    return wid;
}

static void wm_window_destroy(int wid) {
    if (wid < 0 || wid >= MAX_WINDOWS || !windows[wid].active) return;

    window_t *win = &windows[wid];
    if (win->buffer) {
        api->free(win->buffer);
        win->buffer = 0;
    }
    win->active = 0;

    // Remove from z-order
    int pos = -1;
    for (int i = 0; i < window_count; i++) {
        if (window_order[i] == wid) {
            pos = i;
            break;
        }
    }
    if (pos >= 0) {
        for (int i = pos; i < window_count - 1; i++) {
            window_order[i] = window_order[i + 1];
        }
        window_count--;
    }

    // Update focus
    if (focused_window == wid) {
        focused_window = (window_count > 0) ? window_order[0] : -1;
    }
}

static uint32_t *wm_window_get_buffer(int wid, int *w, int *h) {
    if (wid < 0 || wid >= MAX_WINDOWS || !windows[wid].active) return 0;
    window_t *win = &windows[wid];
    if (w) *w = win->w;
    if (h) *h = win->h - TITLE_BAR_HEIGHT;
    return win->buffer;
}

static int wm_window_poll_event(int wid, int *event_type, int *data1, int *data2, int *data3) {
    if (wid < 0 || wid >= MAX_WINDOWS || !windows[wid].active) return 0;
    window_t *win = &windows[wid];

    if (win->event_head == win->event_tail) return 0;  // No events

    win_event_t *ev = &win->events[win->event_head];
    *event_type = ev->type;
    *data1 = ev->data1;
    *data2 = ev->data2;
    *data3 = ev->data3;
    win->event_head = (win->event_head + 1) % 32;
    return 1;
}

static void wm_window_invalidate(int wid) {
    if (wid < 0 || wid >= MAX_WINDOWS || !windows[wid].active) return;
    windows[wid].dirty = 1;
}

static void wm_window_set_title(int wid, const char *title) {
    if (wid < 0 || wid >= MAX_WINDOWS || !windows[wid].active) return;
    window_t *win = &windows[wid];
    int i;
    for (i = 0; i < MAX_TITLE_LEN - 1 && title[i]; i++) {
        win->title[i] = title[i];
    }
    win->title[i] = '\0';
    win->dirty = 1;
}

// ============ Dock ============

#define DOCK_ICON_SIZE 32
#define DOCK_PADDING 12
#define DOCK_LABEL_HEIGHT 12

// Dock icons with bitmap indices
static dock_icon_t dock_icons[] = {
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Snake",   "/bin/snake",   1 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Tetris",  "/bin/tetris",  1 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Calc",    "/bin/calc",    0 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Files",   "/bin/files",   0 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Music",   "/bin/music",   0 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Browser", "/bin/browser", 0 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "Term",    "/bin/term",    0 },
    { 0, 0, DOCK_ICON_SIZE, DOCK_ICON_SIZE, "SysMon",  "/bin/sysmon",  0 },
};
#define NUM_DOCK_ICONS (sizeof(dock_icons) / sizeof(dock_icons[0]))

static void init_dock_positions(void) {
    int total_width = NUM_DOCK_ICONS * (DOCK_ICON_SIZE + DOCK_PADDING) - DOCK_PADDING;
    int start_x = (SCREEN_WIDTH - total_width) / 2;
    int y = SCREEN_HEIGHT - DOCK_HEIGHT + 6;  // Top padding

    for (int i = 0; i < (int)NUM_DOCK_ICONS; i++) {
        dock_icons[i].x = start_x + i * (DOCK_ICON_SIZE + DOCK_PADDING);
        dock_icons[i].y = y;
    }
}

static void draw_dock_icon(dock_icon_t *icon, int icon_idx, int highlight) {
    // Draw the bitmap icon
    draw_icon_bitmap(icon->x, icon->y, icon_bitmaps[icon_idx], highlight);

    // Draw label below icon
    int label_len = strlen(icon->label);
    int label_x = icon->x + (DOCK_ICON_SIZE - label_len * 8) / 2;
    int label_y = icon->y + DOCK_ICON_SIZE + 2;

    // Label background (inverted if highlighted)
    if (highlight) {
        bb_fill_rect(label_x - 2, label_y - 1, label_len * 8 + 4, 10, COLOR_BLACK);
        bb_draw_string(label_x, label_y, icon->label, COLOR_WHITE, COLOR_BLACK);
    } else {
        bb_draw_string(label_x, label_y, icon->label, COLOR_BLACK, COLOR_WHITE);
    }
}

static void draw_dock(void) {
    // Dock background - white with top border
    bb_fill_rect(0, SCREEN_HEIGHT - DOCK_HEIGHT, SCREEN_WIDTH, DOCK_HEIGHT, COLOR_WHITE);
    // Double line at top for 3D effect
    bb_draw_hline(0, SCREEN_HEIGHT - DOCK_HEIGHT, SCREEN_WIDTH, COLOR_BLACK);
    bb_draw_hline(0, SCREEN_HEIGHT - DOCK_HEIGHT + 2, SCREEN_WIDTH, COLOR_BLACK);

    // Icons
    for (int i = 0; i < (int)NUM_DOCK_ICONS; i++) {
        int highlight = (mouse_y >= dock_icons[i].y &&
                        mouse_y < dock_icons[i].y + DOCK_ICON_SIZE + DOCK_LABEL_HEIGHT &&
                        mouse_x >= dock_icons[i].x &&
                        mouse_x < dock_icons[i].x + DOCK_ICON_SIZE);
        draw_dock_icon(&dock_icons[i], i, highlight);
    }
}

static int dock_icon_at_point(int x, int y) {
    for (int i = 0; i < (int)NUM_DOCK_ICONS; i++) {
        if (x >= dock_icons[i].x && x < dock_icons[i].x + DOCK_ICON_SIZE &&
            y >= dock_icons[i].y && y < dock_icons[i].y + DOCK_ICON_SIZE) {
            return i;
        }
    }
    return -1;
}

// ============ Menu Bar ============

// Format time string: "HH:MM" (5 chars + null)
static void format_time(char *buf) {
    int year, month, day, hour, minute, second, weekday;
    api->get_datetime(&year, &month, &day, &hour, &minute, &second, &weekday);

    buf[0] = '0' + (hour / 10);
    buf[1] = '0' + (hour % 10);
    buf[2] = ':';
    buf[3] = '0' + (minute / 10);
    buf[4] = '0' + (minute % 10);
    buf[5] = '\0';
}

// Format date string: "Mon Dec 8" (max ~10 chars)
static void format_date(char *buf) {
    static const char day_names[7][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    static const char month_names[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    int year, month, day, hour, minute, second, weekday;
    (void)year; (void)hour; (void)minute; (void)second;
    api->get_datetime(&year, &month, &day, &hour, &minute, &second, &weekday);

    // Copy day name
    buf[0] = day_names[weekday][0];
    buf[1] = day_names[weekday][1];
    buf[2] = day_names[weekday][2];
    buf[3] = ' ';

    // Copy month name
    buf[4] = month_names[month - 1][0];
    buf[5] = month_names[month - 1][1];
    buf[6] = month_names[month - 1][2];
    buf[7] = ' ';

    // Day number
    if (day >= 10) {
        buf[8] = '0' + (day / 10);
        buf[9] = '0' + (day % 10);
        buf[10] = '\0';
    } else {
        buf[8] = '0' + day;
        buf[9] = '\0';
    }
}

// Menu bar item positions (x, width)
#define APPLE_MENU_X     4
#define APPLE_MENU_W     20
#define FILE_MENU_X      28
#define FILE_MENU_W      32
#define EDIT_MENU_X      68
#define EDIT_MENU_W      32

static void draw_dropdown_menu(int menu_x, const menu_item_t *items) {
    // Calculate menu dimensions
    int max_width = 0;
    int item_count = 0;
    for (int i = 0; items[i].action != -1; i++) {
        if (items[i].label) {
            int len = strlen(items[i].label);
            if (len > max_width) max_width = len;
        }
        item_count++;
    }

    int menu_w = max_width * 8 + 24;  // Padding on sides
    int menu_h = item_count * 16 + 4; // 16px per item + border

    int menu_y = MENU_BAR_HEIGHT;

    // Draw menu background with shadow
    bb_fill_rect(menu_x + 2, menu_y + 2, menu_w, menu_h, COLOR_BLACK);  // Shadow
    bb_fill_rect(menu_x, menu_y, menu_w, menu_h, COLOR_WHITE);
    bb_draw_rect(menu_x, menu_y, menu_w, menu_h, COLOR_BLACK);

    // Draw items
    int y = menu_y + 2;
    for (int i = 0; items[i].action != -1; i++) {
        if (items[i].label == NULL) {
            // Separator
            bb_draw_hline(menu_x + 4, y + 7, menu_w - 8, COLOR_BLACK);
        } else {
            // Check if mouse is over this item
            int item_y = y;
            int hovering = (mouse_y >= item_y && mouse_y < item_y + 16 &&
                           mouse_x >= menu_x && mouse_x < menu_x + menu_w);

            if (hovering) {
                bb_fill_rect(menu_x + 2, item_y, menu_w - 4, 16, COLOR_BLACK);
                bb_draw_string(menu_x + 12, item_y + 1, items[i].label, COLOR_WHITE, COLOR_BLACK);
            } else {
                bb_draw_string(menu_x + 12, item_y + 1, items[i].label, COLOR_BLACK, COLOR_WHITE);
            }
        }
        y += 16;
    }
}

static void draw_menu_bar(void) {
    // Background
    bb_fill_rect(0, 0, SCREEN_WIDTH, MENU_BAR_HEIGHT, COLOR_MENU_BG);
    // Bottom border - double line for 3D effect
    bb_draw_hline(0, MENU_BAR_HEIGHT - 2, SCREEN_WIDTH, COLOR_BLACK);
    bb_draw_hline(0, MENU_BAR_HEIGHT - 1, SCREEN_WIDTH, COLOR_BLACK);

    // VibeOS logo in menu bar (highlighted if menu open)
    if (open_menu == MENU_APPLE) {
        bb_fill_rect(APPLE_MENU_X - 2, 0, APPLE_MENU_W + 4, MENU_BAR_HEIGHT - 2, COLOR_BLACK);
        // Draw inverted logo
        for (int py = 0; py < 16; py++) {
            for (int px = 0; px < 16; px++) {
                if (vibeos_logo[py * 16 + px]) {
                    bb_put_pixel(APPLE_MENU_X + px, 2 + py, COLOR_WHITE);
                }
            }
        }
    } else {
        draw_vibeos_logo(APPLE_MENU_X, 2);
    }

    // File menu
    if (open_menu == MENU_FILE) {
        bb_fill_rect(FILE_MENU_X - 4, 0, FILE_MENU_W + 8, MENU_BAR_HEIGHT - 2, COLOR_BLACK);
        bb_draw_string(FILE_MENU_X, 2, "File", COLOR_WHITE, COLOR_BLACK);
    } else {
        bb_draw_string(FILE_MENU_X, 2, "File", COLOR_MENU_TEXT, COLOR_MENU_BG);
    }

    // Edit menu
    if (open_menu == MENU_EDIT) {
        bb_fill_rect(EDIT_MENU_X - 4, 0, EDIT_MENU_W + 8, MENU_BAR_HEIGHT - 2, COLOR_BLACK);
        bb_draw_string(EDIT_MENU_X, 2, "Edit", COLOR_WHITE, COLOR_BLACK);
    } else {
        bb_draw_string(EDIT_MENU_X, 2, "Edit", COLOR_MENU_TEXT, COLOR_MENU_BG);
    }

    // Date and time on right side
    char date_buf[16];
    char time_buf[8];
    format_date(date_buf);
    format_time(time_buf);

    // Draw date then time: "Mon Dec 8  12:00"
    int date_len = strlen(date_buf);
    int time_x = SCREEN_WIDTH - 48;  // Time on far right
    int date_x = time_x - (date_len * 8) - 16;  // Date with gap

    bb_draw_string(date_x, 2, date_buf, COLOR_MENU_TEXT, COLOR_MENU_BG);
    bb_draw_string(time_x, 2, time_buf, COLOR_MENU_TEXT, COLOR_MENU_BG);
}

static void draw_open_menu(void) {
    if (open_menu == MENU_APPLE) {
        draw_dropdown_menu(APPLE_MENU_X - 2, apple_menu);
    } else if (open_menu == MENU_FILE) {
        draw_dropdown_menu(FILE_MENU_X - 4, file_menu);
    } else if (open_menu == MENU_EDIT) {
        draw_dropdown_menu(EDIT_MENU_X - 4, edit_menu);
    }
}

// ============ Window Drawing ============

// Draw System 7 style horizontal stripes for title bar
static void draw_title_stripes(int x, int y, int w, int h) {
    for (int row = 0; row < h; row++) {
        // Every other row is black (creates stripe effect)
        if (row % 2 == 1) {
            for (int col = 0; col < w; col++) {
                bb_put_pixel(x + col, y + row, COLOR_BLACK);
            }
        } else {
            for (int col = 0; col < w; col++) {
                bb_put_pixel(x + col, y + row, COLOR_WHITE);
            }
        }
    }
}

static void draw_window(int wid) {
    if (wid < 0 || !windows[wid].active) return;
    window_t *w = &windows[wid];

    int is_focused = (wid == focused_window);

    // Outer shadow (drop shadow effect)
    bb_fill_rect(w->x + 2, w->y + w->h, w->w, 2, COLOR_BLACK);
    bb_fill_rect(w->x + w->w, w->y + 2, 2, w->h, COLOR_BLACK);

    // Window background
    bb_fill_rect(w->x, w->y, w->w, w->h, COLOR_WHITE);

    // Window border (double line)
    bb_draw_rect(w->x, w->y, w->w, w->h, COLOR_BLACK);
    bb_draw_rect(w->x + 1, w->y + 1, w->w - 2, w->h - 2, COLOR_BLACK);

    // Title bar area
    if (is_focused) {
        // Striped title bar (System 7 signature look)
        // Leave space for close box and title
        int stripe_start = w->x + 20;  // After close box
        int stripe_end = w->x + w->w - 20;  // Before right edge
        int title_len = strlen(w->title);
        int title_width = title_len * 8 + 8;  // Title + padding
        int title_start = w->x + (w->w - title_width) / 2;

        // Left stripes
        draw_title_stripes(stripe_start, w->y + 4, title_start - stripe_start - 4, TITLE_BAR_HEIGHT - 8);

        // Right stripes
        draw_title_stripes(title_start + title_width + 4, w->y + 4,
                          stripe_end - (title_start + title_width + 4), TITLE_BAR_HEIGHT - 8);
    }

    // Title bar bottom line
    bb_draw_hline(w->x + 1, w->y + TITLE_BAR_HEIGHT, w->w - 2, COLOR_BLACK);

    // Close box (left side) - System 7 style with inner box
    int close_x = w->x + 6;
    int close_y = w->y + 4;
    bb_fill_rect(close_x, close_y, 13, 13, COLOR_WHITE);
    bb_draw_rect(close_x, close_y, 13, 13, COLOR_BLACK);
    if (is_focused) {
        // Inner box when focused
        bb_draw_rect(close_x + 3, close_y + 3, 7, 7, COLOR_BLACK);
    }

    // Title text (centered, bold effect with double-draw)
    int title_len = strlen(w->title);
    int title_x = w->x + (w->w - title_len * 8) / 2;
    int title_y = w->y + 3;
    bb_draw_string(title_x, title_y, w->title, COLOR_BLACK, COLOR_WHITE);

    // Content area - copy from window buffer
    int content_y = w->y + TITLE_BAR_HEIGHT + 2;
    int content_h = w->h - TITLE_BAR_HEIGHT - 4;
    int content_w = w->w - 4;

    for (int py = 0; py < content_h; py++) {
        for (int px = 0; px < content_w; px++) {
            int screen_x = w->x + 2 + px;
            int screen_y = content_y + py;
            if (screen_x < SCREEN_WIDTH && screen_y < SCREEN_HEIGHT) {
                backbuffer[screen_y * SCREEN_WIDTH + screen_x] =
                    w->buffer[py * (w->w) + px];
            }
        }
    }

    // Resize handle (bottom-right corner) - System 7 style diagonal lines
    int rh_x = w->x + w->w - 15;
    int rh_y = w->y + w->h - 15;
    // Draw 3 diagonal lines
    for (int i = 0; i < 3; i++) {
        int offset = i * 4;
        // Each line is 2 pixels thick for visibility
        for (int d = 0; d < 10 - offset; d++) {
            bb_put_pixel(rh_x + offset + d + 4, rh_y + d + 4, COLOR_BLACK);
        }
    }
}

// ============ Cursor ============

static void draw_cursor(int x, int y) {
    // Classic Mac-style arrow cursor as flat array (PIE-safe)
    // 1 = black, 2 = white, 0 = transparent
    static const uint8_t cursor_bits[16 * 16] = {
        1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,
        1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,
        1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,
        1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,
        1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,
        1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,
        1,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,
        1,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,
        1,2,2,1,2,2,1,0,0,0,0,0,0,0,0,0,
        1,2,1,1,2,2,1,0,0,0,0,0,0,0,0,0,
        1,1,0,0,1,2,2,1,0,0,0,0,0,0,0,0,
        1,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,
        0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
    };

    for (int py = 0; py < 16; py++) {
        for (int px = 0; px < 16; px++) {
            uint8_t c = cursor_bits[py * 16 + px];
            if (c != 0) {
                int sx = x + px;
                int sy = y + py;
                if (sx >= 0 && sx < SCREEN_WIDTH && sy >= 0 && sy < SCREEN_HEIGHT) {
                    uint32_t color = (c == 1) ? COLOR_BLACK : COLOR_WHITE;
                    backbuffer[sy * SCREEN_WIDTH + sx] = color;
                }
            }
        }
    }
}

// ============ Main Drawing ============

static void draw_desktop(void) {
    // Desktop background - classic Mac diagonal checkerboard pattern
    bb_fill_pattern(0, MENU_BAR_HEIGHT, SCREEN_WIDTH,
                    SCREEN_HEIGHT - MENU_BAR_HEIGHT - DOCK_HEIGHT);

    // Menu bar
    draw_menu_bar();

    // Windows (back to front)
    for (int i = window_count - 1; i >= 0; i--) {
        draw_window(window_order[i]);
    }

    // Dock
    draw_dock();

    // Open menu dropdown (draw last, on top of everything)
    if (open_menu != MENU_NONE) {
        draw_open_menu();
    }

    // About dialog (on top of everything)
    if (show_about_dialog) {
        draw_about_dialog();
    }
}

static void flip_buffer(void) {
    memcpy(api->fb_base, backbuffer, SCREEN_WIDTH * SCREEN_HEIGHT * sizeof(uint32_t));
}

// ============ Input Handling ============

#define ABOUT_W 280
#define ABOUT_H 180
#define ABOUT_X ((SCREEN_WIDTH - ABOUT_W) / 2)
#define ABOUT_Y ((SCREEN_HEIGHT - ABOUT_H) / 2 - 20)

static void draw_about_dialog(void) {
    int x = ABOUT_X;
    int y = ABOUT_Y;

    // Shadow
    bb_fill_rect(x + 3, y + 3, ABOUT_W, ABOUT_H, COLOR_BLACK);

    // Background
    bb_fill_rect(x, y, ABOUT_W, ABOUT_H, COLOR_WHITE);

    // Border (double line)
    bb_draw_rect(x, y, ABOUT_W, ABOUT_H, COLOR_BLACK);
    bb_draw_rect(x + 1, y + 1, ABOUT_W - 2, ABOUT_H - 2, COLOR_BLACK);

    // Draw a big VibeOS logo in the dialog (2x size)
    int logo_x = x + (ABOUT_W - 32) / 2;  // 16*2 = 32
    int logo_y = y + 12;
    for (int py = 0; py < 16; py++) {
        for (int px = 0; px < 16; px++) {
            if (vibeos_logo[py * 16 + px]) {
                // Draw it 2x size
                bb_put_pixel(logo_x + px*2, logo_y + py*2, COLOR_BLACK);
                bb_put_pixel(logo_x + px*2 + 1, logo_y + py*2, COLOR_BLACK);
                bb_put_pixel(logo_x + px*2, logo_y + py*2 + 1, COLOR_BLACK);
                bb_put_pixel(logo_x + px*2 + 1, logo_y + py*2 + 1, COLOR_BLACK);
            }
        }
    }

    // Title
    const char *title = "VibeOS";
    int title_x = x + (ABOUT_W - strlen(title) * 8) / 2;
    bb_draw_string(title_x, y + 50, title, COLOR_BLACK, COLOR_WHITE);

    // Version
    const char *version = "Version 1.0";
    int ver_x = x + (ABOUT_W - strlen(version) * 8) / 2;
    bb_draw_string(ver_x, y + 68, version, COLOR_BLACK, COLOR_WHITE);

    // Separator line
    bb_draw_hline(x + 20, y + 88, ABOUT_W - 40, COLOR_BLACK);

    // System info
    // Memory
    unsigned long mem_used = api->get_mem_used() / 1024;  // KB
    unsigned long mem_free = api->get_mem_free() / 1024;  // KB
    unsigned long mem_total = mem_used + mem_free;

    char mem_str[40];
    // Manual sprintf: "Memory: XXX KB used / XXX KB total"
    char *p = mem_str;
    const char *m1 = "Memory: ";
    while (*m1) *p++ = *m1++;

    // Used KB
    char num[12];
    int ni = 0;
    unsigned long n = mem_used;
    if (n == 0) num[ni++] = '0';
    else { while (n > 0) { num[ni++] = '0' + (n % 10); n /= 10; } }
    while (ni > 0) *p++ = num[--ni];

    const char *m2 = " / ";
    while (*m2) *p++ = *m2++;

    // Total KB
    n = mem_total;
    ni = 0;
    if (n == 0) num[ni++] = '0';
    else { while (n > 0) { num[ni++] = '0' + (n % 10); n /= 10; } }
    while (ni > 0) *p++ = num[--ni];

    const char *m3 = " KB";
    while (*m3) *p++ = *m3++;
    *p = '\0';

    int mem_x = x + (ABOUT_W - strlen(mem_str) * 8) / 2;
    bb_draw_string(mem_x, y + 100, mem_str, COLOR_BLACK, COLOR_WHITE);

    // Uptime
    unsigned long ticks = api->get_uptime_ticks();
    unsigned long secs = ticks / 100;
    unsigned long mins = secs / 60;
    unsigned long hours = mins / 60;
    mins = mins % 60;
    secs = secs % 60;

    char up_str[32];
    p = up_str;
    const char *u1 = "Uptime: ";
    while (*u1) *p++ = *u1++;

    // Hours
    n = hours;
    ni = 0;
    if (n == 0) num[ni++] = '0';
    else { while (n > 0) { num[ni++] = '0' + (n % 10); n /= 10; } }
    while (ni > 0) *p++ = num[--ni];
    *p++ = ':';

    // Minutes (2 digits)
    *p++ = '0' + (mins / 10);
    *p++ = '0' + (mins % 10);
    *p++ = ':';

    // Seconds (2 digits)
    *p++ = '0' + (secs / 10);
    *p++ = '0' + (secs % 10);
    *p = '\0';

    int up_x = x + (ABOUT_W - strlen(up_str) * 8) / 2;
    bb_draw_string(up_x, y + 118, up_str, COLOR_BLACK, COLOR_WHITE);

    // OK button
    int btn_w = 60;
    int btn_h = 20;
    int btn_x = x + (ABOUT_W - btn_w) / 2;
    int btn_y = y + ABOUT_H - 35;

    // Check if hovering over button
    int hovering = (mouse_x >= btn_x && mouse_x < btn_x + btn_w &&
                   mouse_y >= btn_y && mouse_y < btn_y + btn_h);

    if (hovering) {
        bb_fill_rect(btn_x, btn_y, btn_w, btn_h, COLOR_BLACK);
        bb_draw_string(btn_x + 20, btn_y + 3, "OK", COLOR_WHITE, COLOR_BLACK);
    } else {
        bb_fill_rect(btn_x, btn_y, btn_w, btn_h, COLOR_WHITE);
        bb_draw_rect(btn_x, btn_y, btn_w, btn_h, COLOR_BLACK);
        bb_draw_rect(btn_x + 2, btn_y + 2, btn_w - 4, btn_h - 4, COLOR_BLACK);
        bb_draw_string(btn_x + 20, btn_y + 3, "OK", COLOR_BLACK, COLOR_WHITE);
    }
}

// Execute a menu action
static void do_menu_action(int action) {
    switch (action) {
        case ACTION_ABOUT:
            show_about_dialog = 1;
            break;
        case ACTION_QUIT:
            running = 0;
            break;
        case ACTION_NEW_WINDOW:
            api->spawn("/bin/term");
            break;
        case ACTION_CLOSE_WINDOW:
            if (focused_window >= 0) {
                push_event(focused_window, WIN_EVENT_CLOSE, 0, 0, 0);
            }
            break;
        case ACTION_CUT:
        case ACTION_COPY:
        case ACTION_PASTE:
            // TODO: Clipboard operations
            break;
    }
}

// Check if click is on a menu item and return its action
static int get_menu_item_action(int menu_x, const menu_item_t *items, int click_x, int click_y) {
    // Calculate menu dimensions
    int max_width = 0;
    int item_count = 0;
    for (int i = 0; items[i].action != -1; i++) {
        if (items[i].label) {
            int len = strlen(items[i].label);
            if (len > max_width) max_width = len;
        }
        item_count++;
    }

    int menu_w = max_width * 8 + 24;
    int menu_y = MENU_BAR_HEIGHT;

    // Check if click is within menu bounds
    if (click_x < menu_x || click_x >= menu_x + menu_w) return ACTION_NONE;
    if (click_y < menu_y) return ACTION_NONE;

    // Find which item was clicked
    int y = menu_y + 2;
    for (int i = 0; items[i].action != -1; i++) {
        if (click_y >= y && click_y < y + 16) {
            if (items[i].label != NULL) {
                return items[i].action;
            }
            return ACTION_NONE;  // Clicked on separator
        }
        y += 16;
    }

    return ACTION_NONE;
}

static void handle_mouse_click(int x, int y, uint8_t buttons) {
    // Handle About dialog (modal - blocks everything else)
    if (show_about_dialog && (buttons & MOUSE_BTN_LEFT)) {
        // Check OK button
        int btn_w = 60;
        int btn_h = 20;
        int btn_x = ABOUT_X + (ABOUT_W - btn_w) / 2;
        int btn_y = ABOUT_Y + ABOUT_H - 35;

        if (x >= btn_x && x < btn_x + btn_w &&
            y >= btn_y && y < btn_y + btn_h) {
            show_about_dialog = 0;
        }
        // Click anywhere in dialog dismisses it too
        if (x >= ABOUT_X && x < ABOUT_X + ABOUT_W &&
            y >= ABOUT_Y && y < ABOUT_Y + ABOUT_H) {
            // Clicked inside dialog, but not button - do nothing (or dismiss)
        } else {
            // Clicked outside dialog - dismiss it
            show_about_dialog = 0;
        }
        return;  // Modal - don't process other clicks
    }

    // Handle menu bar clicks (left click only)
    if ((buttons & MOUSE_BTN_LEFT) && y < MENU_BAR_HEIGHT) {
        // Check which menu was clicked
        if (x >= APPLE_MENU_X && x < APPLE_MENU_X + APPLE_MENU_W) {
            open_menu = (open_menu == MENU_APPLE) ? MENU_NONE : MENU_APPLE;
        } else if (x >= FILE_MENU_X && x < FILE_MENU_X + FILE_MENU_W) {
            open_menu = (open_menu == MENU_FILE) ? MENU_NONE : MENU_FILE;
        } else if (x >= EDIT_MENU_X && x < EDIT_MENU_X + EDIT_MENU_W) {
            open_menu = (open_menu == MENU_EDIT) ? MENU_NONE : MENU_EDIT;
        } else {
            open_menu = MENU_NONE;
        }
        return;
    }

    // Handle clicks on open menu dropdown
    if ((buttons & MOUSE_BTN_LEFT) && open_menu != MENU_NONE) {
        int action = ACTION_NONE;

        if (open_menu == MENU_APPLE) {
            action = get_menu_item_action(APPLE_MENU_X - 2, apple_menu, x, y);
        } else if (open_menu == MENU_FILE) {
            action = get_menu_item_action(FILE_MENU_X - 4, file_menu, x, y);
        } else if (open_menu == MENU_EDIT) {
            action = get_menu_item_action(EDIT_MENU_X - 4, edit_menu, x, y);
        }

        if (action != ACTION_NONE) {
            do_menu_action(action);
        }

        // Close menu after any click outside menu bar
        open_menu = MENU_NONE;
        return;
    }

    // Check dock first (left click only)
    if (buttons & MOUSE_BTN_LEFT) {
        int dock_idx = dock_icon_at_point(x, y);
        if (dock_idx >= 0) {
            dock_icon_t *icon = &dock_icons[dock_idx];
            if (icon->is_fullscreen) {
                // Fullscreen app - exec and wait
                api->exec(icon->exec_path);
                // When we return, redraw everything
            } else {
                // Windowed app - spawn
                api->spawn(icon->exec_path);
            }
            return;
        }
    }

    // Check windows
    int wid = window_at_point(x, y);
    if (wid >= 0) {
        window_t *w = &windows[wid];
        bring_to_front(wid);

        // Check if click is on title bar (left click only for dragging/close)
        if ((buttons & MOUSE_BTN_LEFT) && y >= w->y && y < w->y + TITLE_BAR_HEIGHT) {
            // Check close box (updated position)
            int close_x = w->x + 6;
            int close_y = w->y + 4;
            if (x >= close_x && x < close_x + 13 &&
                y >= close_y && y < close_y + 13) {
                // Close window
                push_event(wid, WIN_EVENT_CLOSE, 0, 0, 0);
                return;
            }

            // Start dragging
            dragging_window = wid;
            drag_offset_x = x - w->x;
            drag_offset_y = y - w->y;
        } else if (y >= w->y + TITLE_BAR_HEIGHT) {
            // Check for resize handle (bottom-right corner, 15x15 area)
            int rh_x = w->x + w->w - 15;
            int rh_y = w->y + w->h - 15;
            if ((buttons & MOUSE_BTN_LEFT) &&
                x >= rh_x && x < w->x + w->w &&
                y >= rh_y && y < w->y + w->h) {
                // Start resizing
                resizing_window = wid;
                resize_start_w = w->w;
                resize_start_h = w->h;
                resize_start_mx = x;
                resize_start_my = y;
                return;
            }
            // Click in content area - send event to app with button info
            int local_x = x - w->x - 1;
            int local_y = y - w->y - TITLE_BAR_HEIGHT - 1;
            push_event(wid, WIN_EVENT_MOUSE_DOWN, local_x, local_y, buttons);
        }
    }
}

static void handle_mouse_release(int x, int y) {
    dragging_window = -1;

    // Handle resize completion
    if (resizing_window >= 0) {
        window_t *w = &windows[resizing_window];

        // Free old buffer and allocate new one
        api->free(w->buffer);
        int content_h = w->h - TITLE_BAR_HEIGHT;
        if (content_h < 1) content_h = 1;
        w->buffer = api->malloc(w->w * content_h * sizeof(uint32_t));

        // Clear new buffer to white
        for (int i = 0; i < w->w * content_h; i++) {
            w->buffer[i] = COLOR_WHITE;
        }

        // Send resize event to app (data1=new width, data2=new height)
        push_event(resizing_window, WIN_EVENT_RESIZE, w->w, w->h, 0);

        resizing_window = -1;
        return;
    }

    int wid = window_at_point(x, y);
    if (wid >= 0) {
        window_t *w = &windows[wid];
        if (y >= w->y + TITLE_BAR_HEIGHT) {
            int local_x = x - w->x - 1;
            int local_y = y - w->y - TITLE_BAR_HEIGHT - 1;
            push_event(wid, WIN_EVENT_MOUSE_UP, local_x, local_y, 0);
        }
    }
}

static void handle_mouse_move(int x, int y) {
    if (dragging_window >= 0) {
        window_t *w = &windows[dragging_window];
        w->x = x - drag_offset_x;
        w->y = y - drag_offset_y;

        // Clamp to screen
        if (w->x < 0) w->x = 0;
        if (w->y < MENU_BAR_HEIGHT) w->y = MENU_BAR_HEIGHT;
        if (w->x + w->w > SCREEN_WIDTH) w->x = SCREEN_WIDTH - w->w;
        if (w->y + w->h > SCREEN_HEIGHT - DOCK_HEIGHT)
            w->y = SCREEN_HEIGHT - DOCK_HEIGHT - w->h;
    }

    if (resizing_window >= 0) {
        window_t *w = &windows[resizing_window];

        // Calculate new size based on mouse delta
        int new_w = resize_start_w + (x - resize_start_mx);
        int new_h = resize_start_h + (y - resize_start_my);

        // Enforce minimum size
        if (new_w < 100) new_w = 100;
        if (new_h < 60) new_h = 60;

        // Enforce maximum (screen bounds)
        if (w->x + new_w > SCREEN_WIDTH) new_w = SCREEN_WIDTH - w->x;
        if (w->y + new_h > SCREEN_HEIGHT - DOCK_HEIGHT)
            new_h = SCREEN_HEIGHT - DOCK_HEIGHT - w->y;

        w->w = new_w;
        w->h = new_h;
    }
}

static void handle_keyboard(void) {
    while (api->has_key()) {
        int c = api->getc();

        // Send to focused window
        if (focused_window >= 0) {
            push_event(focused_window, WIN_EVENT_KEY, c, 0, 0);
        }

        // Global shortcuts
        if (c == 'q' || c == 'Q') {
            // For debugging - quit desktop
            // running = 0;
        }
    }
}

// ============ Main ============

static void register_window_api(void) {
    // Register our window functions in kapi
    // This is a bit of a hack - we're modifying kapi from userspace
    // But since we're all in the same address space, it works
    api->window_create = wm_window_create;
    api->window_destroy = wm_window_destroy;
    api->window_get_buffer = wm_window_get_buffer;
    api->window_poll_event = wm_window_poll_event;
    api->window_invalidate = wm_window_invalidate;
    api->window_set_title = wm_window_set_title;
}

int main(kapi_t *kapi, int argc, char **argv) {
    (void)argc;
    (void)argv;

    api = kapi;

    // Get screen dimensions from kapi
    SCREEN_WIDTH = api->fb_width;
    SCREEN_HEIGHT = api->fb_height;

    // Allocate backbuffer
    backbuffer = api->malloc(SCREEN_WIDTH * SCREEN_HEIGHT * sizeof(uint32_t));
    if (!backbuffer) {
        api->puts("Desktop: failed to allocate backbuffer\n");
        return 1;
    }

    // Initialize graphics context
    gfx_init(&gfx, backbuffer, SCREEN_WIDTH, SCREEN_HEIGHT, api->font_data);

    // Initialize
    init_dock_positions();
    register_window_api();

    mouse_x = 0;
    mouse_y = 0;
    mouse_prev_x = 0;
    mouse_prev_y = 0;

    // Main loop
    while (running) {
        // Poll mouse
        api->mouse_poll();
        api->mouse_get_pos(&mouse_x, &mouse_y);
        mouse_buttons = api->mouse_get_buttons();

        // Handle mouse events
        int left_pressed = (mouse_buttons & MOUSE_BTN_LEFT) && !(mouse_prev_buttons & MOUSE_BTN_LEFT);
        int left_released = !(mouse_buttons & MOUSE_BTN_LEFT) && (mouse_prev_buttons & MOUSE_BTN_LEFT);
        int right_pressed = (mouse_buttons & MOUSE_BTN_RIGHT) && !(mouse_prev_buttons & MOUSE_BTN_RIGHT);

        if (left_pressed || right_pressed) {
            uint8_t pressed_btns = 0;
            if (left_pressed) pressed_btns |= MOUSE_BTN_LEFT;
            if (right_pressed) pressed_btns |= MOUSE_BTN_RIGHT;
            handle_mouse_click(mouse_x, mouse_y, pressed_btns);
        }
        if (left_released) {
            handle_mouse_release(mouse_x, mouse_y);
        }
        if (mouse_x != mouse_prev_x || mouse_y != mouse_prev_y) {
            handle_mouse_move(mouse_x, mouse_y);
        }

        // Handle keyboard
        handle_keyboard();

        // Always redraw (simple approach - can optimize later)
        draw_desktop();
        draw_cursor(mouse_x, mouse_y);
        flip_buffer();

        mouse_prev_x = mouse_x;
        mouse_prev_y = mouse_y;
        mouse_prev_buttons = mouse_buttons;

        // Yield to other processes (kernel WFIs if nothing else to run)
        api->yield();
    }

    // Cleanup - clear screen to black and restore console
    for (int i = 0; i < SCREEN_WIDTH * SCREEN_HEIGHT; i++) {
        api->fb_base[i] = COLOR_BLACK;
    }

    // Clear console and show exit message
    api->clear();
    api->puts("Desktop exited.\n");

    api->free(backbuffer);

    return 0;
}
</file>

<file path="kernel/kapi.c">
/*
 * VibeOS Kernel API Implementation
 */

#include "kapi.h"
#include "console.h"
#include "keyboard.h"
#include "memory.h"
#include "vfs.h"
#include "process.h"
#include "fb.h"
#include "mouse.h"
#include "irq.h"
#include "rtc.h"
#include "virtio_sound.h"
#include "fat32.h"
#include "net.h"
#include "tls.h"

// Global kernel API instance
kapi_t kapi;

// RAM size helper
static size_t kapi_get_ram_total(void) {
    extern uint64_t ram_size;
    return (size_t)ram_size;
}

// Wrapper for exit (needs to match signature)
static void kapi_exit(int status) {
    process_exit(status);
}

// Print integer (simple implementation)
static void kapi_print_int(int n) {
    if (n < 0) {
        console_putc('-');
        n = -n;
    }
    if (n == 0) {
        console_putc('0');
        return;
    }
    char buf[12];
    int i = 0;
    while (n > 0) {
        buf[i++] = '0' + (n % 10);
        n /= 10;
    }
    while (i > 0) {
        console_putc(buf[--i]);
    }
}

// Print hex
static void kapi_print_hex(uint32_t n) {
    const char *hex = "0123456789ABCDEF";
    for (int i = 7; i >= 0; i--) {
        console_putc(hex[(n >> (i * 4)) & 0xF]);
    }
}

// Wrapper for exec
static int kapi_exec(const char *path) {
    return process_exec(path);
}

// Wrapper for exec with arguments
static int kapi_exec_args(const char *path, int argc, char **argv) {
    return process_exec_args(path, argc, argv);
}

// Wrapper for spawn - create and start a new process
static int kapi_spawn(const char *path) {
    char *argv[1] = { (char *)path };
    int pid = process_create(path, 1, argv);
    if (pid > 0) {
        process_start(pid);
    }
    return pid;
}

// Wrapper for console color
static void kapi_set_color(uint32_t fg, uint32_t bg) {
    console_set_color(fg, bg);
}

// Wrapper for VFS open
static void *kapi_open(const char *path) {
    return (void *)vfs_lookup(path);
}

// Wrapper for VFS read
static int kapi_read(void *file, char *buf, size_t size, size_t offset) {
    return vfs_read((vfs_node_t *)file, buf, size, offset);
}

// Wrapper for VFS write
static int kapi_write(void *file, const char *buf, size_t size) {
    return vfs_write((vfs_node_t *)file, buf, size);
}

// Wrapper for is_dir
static int kapi_is_dir(void *node) {
    return vfs_is_dir((vfs_node_t *)node);
}

// Wrapper for file_size
static int kapi_file_size(void *node) {
    if (!node) return -1;
    vfs_node_t *n = (vfs_node_t *)node;
    return (int)n->size;
}

// Wrapper for create
static void *kapi_create(const char *path) {
    return (void *)vfs_create(path);
}

// Wrapper for mkdir
static void *kapi_mkdir(const char *path) {
    return (void *)vfs_mkdir(path);
}

// Wrapper for delete
static int kapi_delete(const char *path) {
    return vfs_delete(path);
}

// Wrapper for delete_dir
static int kapi_delete_dir(const char *path) {
    return vfs_delete_dir(path);
}

// Wrapper for delete_recursive
static int kapi_delete_recursive(const char *path) {
    return vfs_delete_recursive(path);
}

// Wrapper for rename
static int kapi_rename(const char *path, const char *newname) {
    return vfs_rename(path, newname);
}

// Wrapper for readdir
static int kapi_readdir(void *dir, int index, char *name, size_t name_size, uint8_t *type) {
    return vfs_readdir((vfs_node_t *)dir, index, name, name_size, type);
}

// Wrapper for set_cwd
static int kapi_set_cwd(const char *path) {
    return vfs_set_cwd(path);
}

// Wrapper for get_cwd
static int kapi_get_cwd(char *buf, size_t size) {
    return vfs_get_cwd_path(buf, size);
}

// Wrapper for get_datetime (flattens the datetime_t struct)
static void kapi_get_datetime(int *year, int *month, int *day,
                              int *hour, int *minute, int *second, int *weekday) {
    datetime_t dt;
    rtc_get_datetime(&dt);
    if (year) *year = dt.year;
    if (month) *month = dt.month;
    if (day) *day = dt.day;
    if (hour) *hour = dt.hour;
    if (minute) *minute = dt.minute;
    if (second) *second = dt.second;
    if (weekday) *weekday = dt.weekday;
}

void kapi_init(void) {
    kapi.version = KAPI_VERSION;

    // Console
    extern void uart_puts(const char *s);
    kapi.putc = console_putc;
    kapi.puts = console_puts;
    kapi.uart_puts = uart_puts;
    kapi.getc = keyboard_getc;
    kapi.set_color = kapi_set_color;
    kapi.clear = console_clear;
    kapi.set_cursor = console_set_cursor;
    kapi.print_int = kapi_print_int;
    kapi.print_hex = kapi_print_hex;

    // Keyboard
    kapi.has_key = keyboard_has_key;

    // Memory
    kapi.malloc = malloc;
    kapi.free = free;

    // Filesystem
    kapi.open = kapi_open;
    kapi.read = kapi_read;
    kapi.write = kapi_write;
    kapi.is_dir = kapi_is_dir;
    kapi.file_size = kapi_file_size;
    kapi.create = kapi_create;
    kapi.mkdir = kapi_mkdir;
    kapi.delete = kapi_delete;
    kapi.delete_dir = kapi_delete_dir;
    kapi.delete_recursive = kapi_delete_recursive;
    kapi.rename = kapi_rename;
    kapi.readdir = kapi_readdir;
    kapi.set_cwd = kapi_set_cwd;
    kapi.get_cwd = kapi_get_cwd;

    // Process
    kapi.exit = kapi_exit;
    kapi.exec = kapi_exec;
    kapi.exec_args = kapi_exec_args;
    kapi.yield = process_yield;
    kapi.spawn = kapi_spawn;

    // Console info
    kapi.console_rows = console_rows;
    kapi.console_cols = console_cols;

    // Framebuffer
    kapi.fb_base = fb_base;
    kapi.fb_width = fb_width;
    kapi.fb_height = fb_height;
    kapi.fb_put_pixel = fb_put_pixel;
    kapi.fb_fill_rect = fb_fill_rect;
    kapi.fb_draw_char = fb_draw_char;
    kapi.fb_draw_string = fb_draw_string;

    // Font access
    extern const uint8_t font_data[256][16];
    kapi.font_data = (const uint8_t *)font_data;

    // Mouse
    kapi.mouse_get_pos = mouse_get_screen_pos;
    kapi.mouse_get_buttons = mouse_get_buttons;
    kapi.mouse_poll = mouse_poll;

    // Window management (provided by desktop, not kernel)
    kapi.window_create = 0;
    kapi.window_destroy = 0;
    kapi.window_get_buffer = 0;
    kapi.window_poll_event = 0;
    kapi.window_invalidate = 0;
    kapi.window_set_title = 0;

    // Stdio hooks (provided by terminal emulator, not kernel)
    kapi.stdio_putc = 0;
    kapi.stdio_puts = 0;
    kapi.stdio_getc = 0;
    kapi.stdio_has_key = 0;

    // System info
    kapi.get_uptime_ticks = timer_get_ticks;
    kapi.get_mem_used = memory_used;
    kapi.get_mem_free = memory_free;

    // RTC
    kapi.get_timestamp = rtc_get_timestamp;
    kapi.get_datetime = kapi_get_datetime;

    // Power management / timing
    kapi.wfi = wfi;
    kapi.sleep_ms = sleep_ms;

    // Sound
    kapi.sound_play_wav = virtio_sound_play_wav;
    kapi.sound_stop = virtio_sound_stop;
    kapi.sound_is_playing = virtio_sound_is_playing;
    kapi.sound_play_pcm = (int (*)(const void *, uint32_t, uint8_t, uint32_t))virtio_sound_play_pcm;
    kapi.sound_play_pcm_async = (int (*)(const void *, uint32_t, uint8_t, uint32_t))virtio_sound_play_pcm_async;
    kapi.sound_pause = virtio_sound_pause;
    kapi.sound_resume = virtio_sound_resume;
    kapi.sound_is_paused = virtio_sound_is_paused;

    // Process info
    kapi.get_process_count = process_count_ready;
    kapi.get_process_info = process_get_info;

    // Disk info
    kapi.get_disk_total = fat32_get_total_kb;
    kapi.get_disk_free = fat32_get_free_kb;

    // RAM info
    kapi.get_ram_total = kapi_get_ram_total;

    // Networking
    kapi.net_ping = net_ping;
    kapi.net_poll = net_poll;
    kapi.net_get_ip = net_get_ip;
    kapi.net_get_mac = net_get_mac;
    kapi.dns_resolve = dns_resolve;

    // TCP sockets
    kapi.tcp_connect = tcp_connect;
    kapi.tcp_send = tcp_send;
    kapi.tcp_recv = tcp_recv;
    kapi.tcp_close = tcp_close;
    kapi.tcp_is_connected = tcp_is_connected;

    // TLS (HTTPS) sockets
    kapi.tls_connect = tls_connect;
    kapi.tls_send = tls_send;
    kapi.tls_recv = tls_recv;
    kapi.tls_close = tls_close;
    kapi.tls_is_connected = tls_is_connected;
}
</file>

<file path="kernel/kapi.h">
/*
 * VibeOS Kernel API
 *
 * Function pointers passed to userspace programs.
 * Programs call kernel functions directly - no syscalls needed.
 * Win3.1 style!
 */

#ifndef KAPI_H
#define KAPI_H

#include <stdint.h>
#include <stddef.h>

// Kernel API version
#define KAPI_VERSION 1

// The kernel API structure - passed to every program
typedef struct {
    uint32_t version;

    // Console I/O
    void (*putc)(char c);
    void (*puts)(const char *s);
    void (*uart_puts)(const char *s);  // Direct UART output
    int  (*getc)(void);              // Non-blocking, returns -1 if no input
    void (*set_color)(uint32_t fg, uint32_t bg);
    void (*clear)(void);             // Clear screen
    void (*set_cursor)(int row, int col);  // Set cursor position
    void (*print_int)(int n);        // Print integer
    void (*print_hex)(uint32_t n);   // Print hex

    // Keyboard
    int  (*has_key)(void);           // Check if key available

    // Memory
    void *(*malloc)(size_t size);
    void  (*free)(void *ptr);

    // Filesystem
    void *(*open)(const char *path);  // Returns vfs_node_t*
    int   (*read)(void *file, char *buf, size_t size, size_t offset);
    int   (*write)(void *file, const char *buf, size_t size);
    int   (*is_dir)(void *node);
    int   (*file_size)(void *node);   // Get file size in bytes
    void *(*create)(const char *path);
    void *(*mkdir)(const char *path);
    int   (*delete)(const char *path);
    int   (*delete_dir)(const char *path);  // Delete empty directory
    int   (*delete_recursive)(const char *path);  // Delete file or dir recursively
    int   (*rename)(const char *path, const char *newname);
    int   (*readdir)(void *dir, int index, char *name, size_t name_size, uint8_t *type);
    int   (*set_cwd)(const char *path);
    int   (*get_cwd)(char *buf, size_t size);

    // Process
    void (*exit)(int status);
    int  (*exec)(const char *path);   // Run another program (waits for completion)
    int  (*exec_args)(const char *path, int argc, char **argv);  // Run with arguments
    void (*yield)(void);              // Give up CPU to other processes
    int  (*spawn)(const char *path);  // Start a new process (returns immediately)

    // Console info
    int  (*console_rows)(void);       // Get number of console rows
    int  (*console_cols)(void);       // Get number of console columns

    // Framebuffer (for GUI programs)
    uint32_t *fb_base;               // Direct framebuffer pointer
    uint32_t fb_width;               // Screen width in pixels
    uint32_t fb_height;              // Screen height in pixels
    void (*fb_put_pixel)(uint32_t x, uint32_t y, uint32_t color);
    void (*fb_fill_rect)(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
    void (*fb_draw_char)(uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg);
    void (*fb_draw_string)(uint32_t x, uint32_t y, const char *s, uint32_t fg, uint32_t bg);

    // Font access (for custom rendering)
    const uint8_t *font_data;        // 256 chars, 16 bytes each (8x16 bitmap)

    // Mouse (for GUI programs)
    void (*mouse_get_pos)(int *x, int *y);         // Get screen position
    uint8_t (*mouse_get_buttons)(void);            // Get button state
    void (*mouse_poll)(void);                      // Poll for updates

    // Window management (for desktop apps)
    // These are set by the desktop window server, not the kernel
    int  (*window_create)(int x, int y, int w, int h, const char *title);
    void (*window_destroy)(int wid);
    uint32_t *(*window_get_buffer)(int wid, int *w, int *h);
    int  (*window_poll_event)(int wid, int *event_type, int *data1, int *data2, int *data3);
    void (*window_invalidate)(int wid);
    void (*window_set_title)(int wid, const char *title);

    // Stdio hooks (for terminal emulator)
    // If set, shell uses these instead of console I/O
    void (*stdio_putc)(char c);          // Write a character
    void (*stdio_puts)(const char *s);   // Write a string
    int  (*stdio_getc)(void);            // Read a character (-1 if none)
    int  (*stdio_has_key)(void);         // Check if input available

    // System info
    uint64_t (*get_uptime_ticks)(void);  // Get timer tick count (100 ticks/sec)
    size_t (*get_mem_used)(void);        // Get used memory in bytes
    size_t (*get_mem_free)(void);        // Get free memory in bytes

    // RTC (Real Time Clock)
    uint32_t (*get_timestamp)(void);     // Unix timestamp (seconds since 1970)
    void (*get_datetime)(int *year, int *month, int *day,
                         int *hour, int *minute, int *second, int *weekday);

    // Power management / timing
    void (*wfi)(void);                   // Wait for interrupt (low power sleep)
    void (*sleep_ms)(uint32_t ms);       // Sleep for at least ms milliseconds

    // Sound
    int (*sound_play_wav)(const void *data, uint32_t size);  // Play WAV from memory (legacy)
    void (*sound_stop)(void);                                 // Stop playback
    int (*sound_is_playing)(void);                           // Check if playing
    int (*sound_play_pcm)(const void *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);  // Play raw S16LE PCM (blocking)
    int (*sound_play_pcm_async)(const void *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);  // Play raw S16LE PCM (non-blocking)
    void (*sound_pause)(void);                               // Pause playback (can resume)
    int (*sound_resume)(void);                               // Resume paused playback
    int (*sound_is_paused)(void);                            // Check if paused

    // Process info (for sysmon)
    int (*get_process_count)(void);                          // Number of active processes
    int (*get_process_info)(int index, char *name, int name_size, int *state);  // Get process info by index

    // Disk info
    int (*get_disk_total)(void);                             // Total disk space in KB
    int (*get_disk_free)(void);                              // Free disk space in KB

    // RAM info
    size_t (*get_ram_total)(void);                           // Total RAM in bytes

    // Networking
    int (*net_ping)(uint32_t ip, uint16_t seq, uint32_t timeout_ms);  // Ping an IP, returns 0 on success
    void (*net_poll)(void);                                           // Process incoming packets
    uint32_t (*net_get_ip)(void);                                     // Get our IP address
    void (*net_get_mac)(uint8_t *mac);                               // Get our MAC address (6 bytes)
    uint32_t (*dns_resolve)(const char *hostname);                   // Resolve hostname to IP, returns 0 on failure

    // TCP sockets
    int (*tcp_connect)(uint32_t ip, uint16_t port);                  // Connect to server, returns socket or -1
    int (*tcp_send)(int sock, const void *data, uint32_t len);       // Send data, returns bytes sent or -1
    int (*tcp_recv)(int sock, void *buf, uint32_t maxlen);           // Receive data, returns bytes or 0/-1
    void (*tcp_close)(int sock);                                      // Close connection
    int (*tcp_is_connected)(int sock);                               // Check if connected

    // TLS (HTTPS) sockets
    int (*tls_connect)(uint32_t ip, uint16_t port, const char *hostname);  // Connect with TLS, returns socket or -1
    int (*tls_send)(int sock, const void *data, uint32_t len);             // Send encrypted data
    int (*tls_recv)(int sock, void *buf, uint32_t maxlen);                 // Receive decrypted data
    void (*tls_close)(int sock);                                           // Close TLS connection
    int (*tls_is_connected)(int sock);                                     // Check if connected

} kapi_t;

// Window event types
#define WIN_EVENT_NONE       0
#define WIN_EVENT_MOUSE_DOWN 1
#define WIN_EVENT_MOUSE_UP   2
#define WIN_EVENT_MOUSE_MOVE 3
#define WIN_EVENT_KEY        4
#define WIN_EVENT_CLOSE      5
#define WIN_EVENT_FOCUS      6
#define WIN_EVENT_UNFOCUS    7
#define WIN_EVENT_RESIZE     8

// Global kernel API instance
extern kapi_t kapi;

// Initialize the kernel API
void kapi_init(void);

#endif
</file>

<file path="user/lib/vibe.h">
/*
 * VibeOS Userspace Library
 *
 * Programs receive a pointer to kernel API and call functions directly.
 * No syscalls needed - Win3.1 style!
 */

#ifndef _VIBE_H
#define _VIBE_H

typedef unsigned long size_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long uint64_t;
typedef signed short int16_t;

// Kernel API structure (must match kernel/kapi.h)
typedef struct kapi {
    uint32_t version;

    // Console I/O
    void (*putc)(char c);
    void (*puts)(const char *s);
    void (*uart_puts)(const char *s);  // Direct UART output
    int  (*getc)(void);
    void (*set_color)(uint32_t fg, uint32_t bg);
    void (*clear)(void);
    void (*set_cursor)(int row, int col);
    void (*print_int)(int n);
    void (*print_hex)(uint32_t n);

    // Keyboard
    int  (*has_key)(void);

    // Memory
    void *(*malloc)(size_t size);
    void  (*free)(void *ptr);

    // Filesystem
    void *(*open)(const char *path);
    int   (*read)(void *file, char *buf, size_t size, size_t offset);
    int   (*write)(void *file, const char *buf, size_t size);
    int   (*is_dir)(void *node);
    int   (*file_size)(void *node);   // Get file size in bytes
    void *(*create)(const char *path);
    void *(*mkdir)(const char *path);
    int   (*delete)(const char *path);
    int   (*delete_dir)(const char *path);  // Delete empty directory
    int   (*delete_recursive)(const char *path);  // Delete file or dir recursively
    int   (*rename)(const char *path, const char *newname);
    int   (*readdir)(void *dir, int index, char *name, size_t name_size, uint8_t *type);
    int   (*set_cwd)(const char *path);
    int   (*get_cwd)(char *buf, size_t size);

    // Process
    void (*exit)(int status);
    int  (*exec)(const char *path);   // Run another program (waits for completion)
    int  (*exec_args)(const char *path, int argc, char **argv);  // Run with arguments
    void (*yield)(void);              // Give up CPU to other processes
    int  (*spawn)(const char *path);  // Start a new process (returns immediately)

    // Console info
    int  (*console_rows)(void);       // Get number of console rows
    int  (*console_cols)(void);       // Get number of console columns

    // Framebuffer (for GUI programs)
    uint32_t *fb_base;
    uint32_t fb_width;
    uint32_t fb_height;
    void (*fb_put_pixel)(uint32_t x, uint32_t y, uint32_t color);
    void (*fb_fill_rect)(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
    void (*fb_draw_char)(uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg);
    void (*fb_draw_string)(uint32_t x, uint32_t y, const char *s, uint32_t fg, uint32_t bg);

    // Font access (for custom rendering)
    const uint8_t *font_data;        // 256 chars, 16 bytes each (8x16 bitmap)

    // Mouse (for GUI programs)
    void (*mouse_get_pos)(int *x, int *y);
    uint8_t (*mouse_get_buttons)(void);
    void (*mouse_poll)(void);

    // Window management (for desktop apps)
    // These are set by the desktop window server, not the kernel
    int  (*window_create)(int x, int y, int w, int h, const char *title);
    void (*window_destroy)(int wid);
    uint32_t *(*window_get_buffer)(int wid, int *w, int *h);
    int  (*window_poll_event)(int wid, int *event_type, int *data1, int *data2, int *data3);
    void (*window_invalidate)(int wid);
    void (*window_set_title)(int wid, const char *title);

    // Stdio hooks (for terminal emulator)
    // If set, shell uses these instead of console I/O
    void (*stdio_putc)(char c);          // Write a character
    void (*stdio_puts)(const char *s);   // Write a string
    int  (*stdio_getc)(void);            // Read a character (-1 if none)
    int  (*stdio_has_key)(void);         // Check if input available

    // System info
    unsigned long (*get_uptime_ticks)(void);  // Get timer tick count (100 ticks/sec)
    size_t (*get_mem_used)(void);             // Get used memory in bytes
    size_t (*get_mem_free)(void);             // Get free memory in bytes

    // RTC (Real Time Clock)
    uint32_t (*get_timestamp)(void);     // Unix timestamp (seconds since 1970)
    void (*get_datetime)(int *year, int *month, int *day,
                         int *hour, int *minute, int *second, int *weekday);

    // Power management / timing
    void (*wfi)(void);                   // Wait for interrupt (low power sleep)
    void (*sleep_ms)(uint32_t ms);       // Sleep for at least ms milliseconds

    // Sound
    int (*sound_play_wav)(const void *data, uint32_t size);  // Play WAV from memory (legacy)
    void (*sound_stop)(void);                                 // Stop playback
    int (*sound_is_playing)(void);                           // Check if playing
    int (*sound_play_pcm)(const void *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);  // Play raw S16LE PCM (blocking)
    int (*sound_play_pcm_async)(const void *data, uint32_t samples, uint8_t channels, uint32_t sample_rate);  // Play raw S16LE PCM (non-blocking)
    void (*sound_pause)(void);                               // Pause playback (can resume)
    int (*sound_resume)(void);                               // Resume paused playback
    int (*sound_is_paused)(void);                            // Check if paused

    // Process info (for sysmon)
    int (*get_process_count)(void);                          // Number of active processes
    int (*get_process_info)(int index, char *name, int name_size, int *state);  // Get process info by index

    // Disk info
    int (*get_disk_total)(void);                             // Total disk space in KB
    int (*get_disk_free)(void);                              // Free disk space in KB

    // RAM info
    size_t (*get_ram_total)(void);                           // Total RAM in bytes

    // Networking
    int (*net_ping)(uint32_t ip, uint16_t seq, uint32_t timeout_ms);  // Ping an IP, returns 0 on success
    void (*net_poll)(void);                                           // Process incoming packets
    uint32_t (*net_get_ip)(void);                                     // Get our IP address
    void (*net_get_mac)(uint8_t *mac);                               // Get our MAC address (6 bytes)
    uint32_t (*dns_resolve)(const char *hostname);                   // Resolve hostname to IP, returns 0 on failure

    // TCP sockets
    int (*tcp_connect)(uint32_t ip, uint16_t port);                  // Connect to server, returns socket or -1
    int (*tcp_send)(int sock, const void *data, uint32_t len);       // Send data, returns bytes sent or -1
    int (*tcp_recv)(int sock, void *buf, uint32_t maxlen);           // Receive data, returns bytes or 0/-1
    void (*tcp_close)(int sock);                                      // Close connection
    int (*tcp_is_connected)(int sock);                               // Check if connected

    // TLS (HTTPS) sockets
    int (*tls_connect)(uint32_t ip, uint16_t port, const char *hostname);  // Connect with TLS
    int (*tls_send)(int sock, const void *data, uint32_t len);             // Send encrypted
    int (*tls_recv)(int sock, void *buf, uint32_t maxlen);                 // Receive decrypted
    void (*tls_close)(int sock);                                           // Close TLS
    int (*tls_is_connected)(int sock);                                     // Check connected
} kapi_t;

// Window event types
#define WIN_EVENT_NONE       0
#define WIN_EVENT_MOUSE_DOWN 1
#define WIN_EVENT_MOUSE_UP   2
#define WIN_EVENT_MOUSE_MOVE 3
#define WIN_EVENT_KEY        4
#define WIN_EVENT_CLOSE      5
#define WIN_EVENT_FOCUS      6
#define WIN_EVENT_UNFOCUS    7
#define WIN_EVENT_RESIZE     8

// Mouse button masks
#define MOUSE_BTN_LEFT   0x01
#define MOUSE_BTN_RIGHT  0x02
#define MOUSE_BTN_MIDDLE 0x04

// Special key codes (must match kernel/keyboard.c)
#define KEY_UP     0x100
#define KEY_DOWN   0x101
#define KEY_LEFT   0x102
#define KEY_RIGHT  0x103
#define KEY_HOME   0x104
#define KEY_END    0x105
#define KEY_DELETE 0x106

// Colors (must match kernel fb.h - these are RGB values)
#define COLOR_BLACK   0x00000000
#define COLOR_WHITE   0x00FFFFFF
#define COLOR_RED     0x00FF0000
#define COLOR_GREEN   0x0000FF00
#define COLOR_BLUE    0x000000FF
#define COLOR_CYAN    0x0000FFFF
#define COLOR_MAGENTA 0x00FF00FF
#define COLOR_YELLOW  0x00FFFF00
#define COLOR_AMBER   0x00FFBF00

// NULL pointer
#ifndef NULL
#define NULL ((void *)0)
#endif

// Network helper: make IP address from bytes
#define MAKE_IP(a,b,c,d) (((uint32_t)(a)<<24)|((uint32_t)(b)<<16)|((uint32_t)(c)<<8)|(uint32_t)(d))

// ============ String Functions ============

static inline size_t strlen(const char *s) {
    size_t len = 0;
    while (s[len]) len++;
    return len;
}

static inline int strcmp(const char *a, const char *b) {
    while (*a && *b && *a == *b) {
        a++;
        b++;
    }
    return *a - *b;
}

static inline int strncmp(const char *a, const char *b, size_t n) {
    while (n > 0 && *a && *b && *a == *b) {
        a++;
        b++;
        n--;
    }
    if (n == 0) return 0;
    return *a - *b;
}

static inline char *strcpy(char *dst, const char *src) {
    char *d = dst;
    while ((*d++ = *src++));
    return dst;
}

static inline char *strncpy_safe(char *dst, const char *src, size_t n) {
    size_t i;
    for (i = 0; i < n - 1 && src[i]; i++) {
        dst[i] = src[i];
    }
    dst[i] = '\0';
    return dst;
}

static inline char *strcat(char *dst, const char *src) {
    char *d = dst;
    while (*d) d++;
    while ((*d++ = *src++));
    return dst;
}

static inline void *memset(void *s, int c, size_t n) {
    unsigned char *p = (unsigned char *)s;
    while (n--) *p++ = (unsigned char)c;
    return s;
}

static inline void *memcpy(void *dst, const void *src, size_t n) {
    unsigned char *d = (unsigned char *)dst;
    const unsigned char *s = (const unsigned char *)src;
    while (n--) *d++ = *s++;
    return dst;
}

// Check if character is whitespace
static inline int isspace(int c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

// Check if character is printable
static inline int isprint(int c) {
    return c >= 32 && c < 127;
}

#endif
</file>

<file path="Makefile">
# VibeOS Makefile
# Build system for VibeOS - an aarch64 operating system

# Cross-compiler toolchain
# On macOS, install with: brew install aarch64-elf-gcc
# Or use: brew tap ArmMbed/homebrew-formulae && brew install arm-none-eabi-gcc
CROSS_COMPILE ?= aarch64-elf-
CC = $(CROSS_COMPILE)gcc
AS = $(CROSS_COMPILE)as
LD = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
OBJDUMP = $(CROSS_COMPILE)objdump

# Directories
BOOT_DIR = boot
KERNEL_DIR = kernel
USER_DIR = user
BUILD_DIR = build
USER_BUILD_DIR = $(BUILD_DIR)/user

# Source files
BOOT_SRC = $(BOOT_DIR)/boot.S
KERNEL_C_SRCS = $(wildcard $(KERNEL_DIR)/*.c)
KERNEL_S_SRCS = $(wildcard $(KERNEL_DIR)/*.S)

# Userspace programs to build and install to disk
USER_PROGS = snake tetris desktop calc vibesh echo ls cat pwd mkdir touch rm term uptime sysmon textedit files date play music ping fetch browser

# Object files
BOOT_OBJ = $(BUILD_DIR)/boot.o
KERNEL_C_OBJS = $(patsubst $(KERNEL_DIR)/%.c,$(BUILD_DIR)/%.o,$(KERNEL_C_SRCS))
KERNEL_S_OBJS = $(patsubst $(KERNEL_DIR)/%.S,$(BUILD_DIR)/%.o,$(KERNEL_S_SRCS))
KERNEL_OBJS = $(KERNEL_C_OBJS) $(KERNEL_S_OBJS)

# Userspace ELF files (installed to disk, NOT embedded in kernel)
USER_ELFS = $(patsubst %,$(USER_BUILD_DIR)/%.elf,$(USER_PROGS))

# Output files
KERNEL_ELF = $(BUILD_DIR)/vibeos.elf
KERNEL_BIN = $(BUILD_DIR)/vibeos.bin
DISK_IMG = disk.img
DISK_SIZE = 1024

# Compiler flags - YOLO -O3
# Floating point enabled (no -mgeneral-regs-only)
# Use -mstrict-align to avoid unaligned SIMD accesses
# -I$(KERNEL_DIR)/libc is for TLSe to find our stdlib stubs
CFLAGS = -ffreestanding -nostdlib -nostartfiles -mcpu=cortex-a72 -mstrict-align -Wall -Wextra -O3 -I$(KERNEL_DIR) -I$(KERNEL_DIR)/libc

# Special flags for TLS (TLSe is huge and noisy)
TLS_CFLAGS = -ffreestanding -nostdlib -nostartfiles -mcpu=cortex-a72 -mstrict-align -O2 -I$(KERNEL_DIR) -I$(KERNEL_DIR)/libc -w
ASFLAGS = -mcpu=cortex-a72
LDFLAGS = -nostdlib -T linker.ld

# Userspace compiler flags (PIE for position-independent loading) - YOLO -O3
USER_CFLAGS = -ffreestanding -nostdlib -nostartfiles -mcpu=cortex-a72 -mstrict-align -fPIE -Wall -Wextra -O3 -I$(USER_DIR)/lib
USER_LDFLAGS = -nostdlib -pie -T user/linker.ld

# QEMU settings
QEMU = qemu-system-aarch64
# Graphical mode with virtio-keyboard, virtio-tablet (mouse), virtio-blk disk, virtio-sound, and virtio-net
# Use force-legacy=false to get modern virtio (version 2) which is easier to program
# Use secure=on and -bios to boot at EL3 with full GIC access
# Network: user-mode NAT networking (guest IP: 10.0.2.15, gateway: 10.0.2.2, DNS: 10.0.2.3)
QEMU_FLAGS = -M virt,secure=on -cpu cortex-a72 -m 512M -rtc base=utc,clock=host -global virtio-mmio.force-legacy=false -device ramfb -device virtio-blk-device,drive=hd0 -drive file=$(DISK_IMG),if=none,format=raw,id=hd0 -device virtio-keyboard-device -device virtio-tablet-device -device virtio-sound-device,audiodev=audio0 -audiodev coreaudio,id=audio0 -device virtio-net-device,netdev=net0 -netdev user,id=net0 -serial stdio -bios $(KERNEL_BIN)
# No-graphics mode (terminal only) - no keyboard in nographic mode
QEMU_FLAGS_NOGRAPHIC = -M virt,secure=on -cpu cortex-a72 -m 512M -rtc base=utc,clock=host -global virtio-mmio.force-legacy=false -device virtio-blk-device,drive=hd0 -drive file=$(DISK_IMG),if=none,format=raw,id=hd0 -device virtio-sound-device,audiodev=audio0 -audiodev coreaudio,id=audio0 -device virtio-net-device,netdev=net0 -netdev user,id=net0 -nographic -bios $(KERNEL_BIN)

.PHONY: all clean run run-nographic debug user disk install-user

all: $(KERNEL_BIN)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(USER_BUILD_DIR):
	mkdir -p $(USER_BUILD_DIR)

# Boot object
$(BOOT_OBJ): $(BOOT_SRC) | $(BUILD_DIR)
	$(CC) $(ASFLAGS) -c $< -o $@

# Kernel C objects
$(BUILD_DIR)/%.o: $(KERNEL_DIR)/%.c | $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Special rule for TLS (includes huge third-party library)
$(BUILD_DIR)/tls.o: $(KERNEL_DIR)/tls.c | $(BUILD_DIR)
	@echo "Building TLS (this takes a while)..."
	$(CC) $(TLS_CFLAGS) -c $< -o $@

# Kernel assembly objects
$(BUILD_DIR)/%.o: $(KERNEL_DIR)/%.S | $(BUILD_DIR)
	$(CC) $(ASFLAGS) -c $< -o $@

# Userspace crt0
$(USER_BUILD_DIR)/crt0.o: $(USER_DIR)/lib/crt0.S | $(USER_BUILD_DIR)
	$(CC) $(ASFLAGS) -c $< -o $@

# Userspace program compilation
$(USER_BUILD_DIR)/%.prog.o: $(USER_DIR)/bin/%.c | $(USER_BUILD_DIR)
	$(CC) $(USER_CFLAGS) -c $< -o $@

# Link userspace program
$(USER_BUILD_DIR)/%.elf: $(USER_BUILD_DIR)/crt0.o $(USER_BUILD_DIR)/%.prog.o
	$(LD) $(USER_LDFLAGS) $^ -o $@
	@echo "Built userspace program: $@"

# Build all userspace programs
user: $(USER_ELFS)

# Install userspace programs to disk image
install-user: user $(DISK_IMG)
	@echo "Installing userspace programs to disk..."
	@hdiutil attach $(DISK_IMG) -nobrowse -mountpoint /tmp/vibeos_mount > /dev/null
	@for prog in $(USER_PROGS); do \
		cp $(USER_BUILD_DIR)/$$prog.elf /tmp/vibeos_mount/bin/$$prog; \
		echo "  Installed /bin/$$prog"; \
	done
	@if [ -f beep.mp3 ]; then cp beep.mp3 /tmp/vibeos_mount/beep.mp3 && echo "  Installed /beep.mp3"; fi
	@if [ -f beep.wav ]; then cp beep.wav /tmp/vibeos_mount/beep.wav && echo "  Installed /beep.wav"; fi
	@if [ -d Music ]; then mkdir -p /tmp/vibeos_mount/home/user/Music && cp -r Music/* /tmp/vibeos_mount/home/user/Music/ && echo "  Installed /home/user/Music/"; fi
	@dot_clean /tmp/vibeos_mount 2>/dev/null || true
	@find /tmp/vibeos_mount -name '._*' -delete 2>/dev/null || true
	@find /tmp/vibeos_mount -name '.DS_Store' -delete 2>/dev/null || true
	@rm -rf /tmp/vibeos_mount/.fseventsd 2>/dev/null || true
	@rm -rf /tmp/vibeos_mount/.Spotlight-V100 2>/dev/null || true
	@rm -rf /tmp/vibeos_mount/.Trashes 2>/dev/null || true
	@hdiutil detach /tmp/vibeos_mount > /dev/null
	@echo "Done!"

# Link kernel (no embedded userspace - programs are on disk)
$(KERNEL_ELF): $(BOOT_OBJ) $(KERNEL_OBJS)
	$(LD) $(LDFLAGS) $^ -o $@

$(KERNEL_BIN): $(KERNEL_ELF)
	$(OBJCOPY) -O binary $< $@
	@echo ""
	@echo "========================================="
	@echo "  VibeOS built successfully!"
	@echo "  Binary: $(KERNEL_BIN)"
	@echo "  Run with: make run"
	@echo "========================================="

# Create disk image with FAT32 filesystem
# Only creates if it doesn't exist - to recreate, delete disk.img first
disk: $(DISK_IMG)

$(DISK_IMG):
	@echo "Creating FAT32 disk image..."
	@dd if=/dev/zero of=$(DISK_IMG) bs=1M count=$(DISK_SIZE)
	@echo "Formatting as FAT32..."
	@DISK_DEV=$$(hdiutil attach -nomount $(DISK_IMG) | head -1 | awk '{print $$1}') && \
		newfs_msdos -F 32 -v VIBEOS $$DISK_DEV && \
		hdiutil detach $$DISK_DEV
	@echo "Creating directory structure..."
	@hdiutil attach $(DISK_IMG) -nobrowse -mountpoint /tmp/vibeos_mount > /dev/null
	@mkdir -p /tmp/vibeos_mount/home/user
	@mkdir -p /tmp/vibeos_mount/bin
	@mkdir -p /tmp/vibeos_mount/etc
	@mkdir -p /tmp/vibeos_mount/tmp
	@echo "Welcome to VibeOS!" > /tmp/vibeos_mount/etc/motd
	@dot_clean /tmp/vibeos_mount 2>/dev/null || true
	@find /tmp/vibeos_mount -name '._*' -delete 2>/dev/null || true
	@find /tmp/vibeos_mount -name '.DS_Store' -delete 2>/dev/null || true
	@hdiutil detach /tmp/vibeos_mount > /dev/null
	@echo ""
	@echo "========================================="
	@echo "  Disk image created: $(DISK_IMG)"
	@echo ""
	@echo "  To mount and add files on macOS:"
	@echo "    hdiutil attach $(DISK_IMG)"
	@echo "    # ... add files ..."
	@echo "    hdiutil detach /Volumes/VIBEOS"
	@echo "========================================="

run: $(KERNEL_BIN) install-user
	$(QEMU) $(QEMU_FLAGS)

run-nographic: $(KERNEL_BIN) $(DISK_IMG)
	$(QEMU) $(QEMU_FLAGS_NOGRAPHIC)

debug: $(KERNEL_BIN)
	$(QEMU) $(QEMU_FLAGS) -S -s

disasm: $(KERNEL_ELF)
	$(OBJDUMP) -d $<

disasm-user: $(USER_ELFS)
	$(OBJDUMP) -d $(USER_BUILD_DIR)/hello.elf

clean:
	rm -rf $(BUILD_DIR)

# Clean everything including disk image
distclean: clean
	rm -f $(DISK_IMG)

# Alternative cross-compiler detection
# Try different common toolchain names
check-toolchain:
	@which $(CC) > /dev/null 2>&1 || \
	(echo "Cross-compiler not found. Try one of:" && \
	 echo "  brew install aarch64-elf-gcc" && \
	 echo "  # or" && \
	 echo "  brew tap ArmMbed/homebrew-formulae && brew install arm-none-eabi-gcc" && \
	 echo "  # Then set CROSS_COMPILE=aarch64-none-elf- or arm-none-eabi-" && \
	 exit 1)
</file>

<file path="claude.md">
# VibeOS - Claude Context

**IMPORTANT DISK RULES:**
- Never look at the disk
- The disk always works
- `make run` is the only way to compile and run the code - the user will run it
- Trust `make run` - the user will tell you if it is broken
- Do NOT use hdiutil for anything

## Project Overview
VibeOS is a hobby operating system built from scratch for aarch64 (ARM64), targeting QEMU's virt machine. This is a science experiment to see what an LLM can build.

## The Vibe
- **Aesthetic**: Retro Mac System 7 / Apple Lisa (1-bit black & white, Chicago-style fonts, classic Mac UI)
- **Philosophy**: Simple, educational, nostalgic
- **NOT trying to be**: Linux, production-ready, or modern

## Team
- **Human**: Vibes only. Yells "fuck yeah" when things work. Cannot provide technical guidance.
- **Claude**: Full technical lead. Makes all architecture decisions. Wozniak energy.

## Current State (Last Updated: Session 31)
- [x] Bootloader (boot/boot.S) - Sets up stack, clears BSS, jumps to kernel
- [x] Minimal kernel (kernel/kernel.c) - UART output working
- [x] Linker script (linker.ld) - Memory layout for QEMU virt
- [x] Makefile - Builds and runs in QEMU
- [x] Boots successfully! Prints to serial console.
- [x] Memory management (kernel/memory.c) - malloc/free working, dynamic heap sizing
- [x] DTB parsing (kernel/dtb.c) - Detects RAM size at runtime from Device Tree
- [x] String functions (kernel/string.c) - memcpy, strlen, strcmp, strtok_r, etc.
- [x] Printf (kernel/printf.c) - %d, %s, %x, %p working
- [x] Framebuffer (kernel/fb.c) - ramfb device, 800x600
- [x] Bitmap font (kernel/font.c) - 8x16 VGA-style font
- [x] Console (kernel/console.c) - Text console with colors on screen
- [x] Virtio keyboard (kernel/keyboard.c) - Full keyboard with shift support
- [x] Shell (kernel/shell.c) - In-kernel shell with commands
- [x] VFS (kernel/vfs.c) - Now backed by FAT32, falls back to in-memory
- [x] Coreutils - ls, cd, pwd, mkdir, touch, rm, cat, echo (with > redirect)
- [x] ELF loader (kernel/elf.c) - Loads PIE binaries with full relocation support
- [x] Process management (kernel/process.c) - Process table, context switching, scheduler
- [x] Cooperative multitasking - yield(), spawn() in kapi, round-robin scheduler
- [x] Kernel API (kernel/kapi.c) - Function pointers for programs to call kernel
- [x] Text editor (kernel/vi.c) - Modal vi clone with normal/insert/command modes
- [x] Virtio block device (kernel/virtio_blk.c) - Read/write disk sectors
- [x] FAT32 filesystem (kernel/fat32.c) - Read/write, full LFN (long filename) support
- [x] Persistent storage - 64MB FAT32 disk image, mountable on macOS
- [x] Interrupts - GIC-400 working! Keyboard via IRQ, boots at EL3 (Secure)
- [x] Timer - 10ms tick (100Hz), used for uptime tracking
- [x] System Monitor - GUI app showing uptime and memory usage
- [x] TextEdit - GUI text editor with Save As modal
- [x] RTC - PL031 real-time clock at 0x09010000, shows actual date/time
- [x] Date command - /bin/date shows current UTC date/time
- [x] Menu bar - Apple menu with About/Quit, File menu, Edit menu
- [x] About dialog - Shows VibeOS version, memory, uptime
- [x] Power management - WFI-based idle, mouse interrupt-driven, 100Hz UI refresh
- [x] Virtio Sound - Audio playback via virtio-sound device, WAV and MP3 support
- [x] Music Player - GUI music player with album/track browser, pause/resume, progress bar
- [x] Floating point - FPU enabled, context switch saves/restores FP regs, calc uses doubles
- [x] Networking - virtio-net driver, Ethernet, ARP, IP, ICMP working!
- [x] Ping command - `/bin/ping` can ping internet hosts (1.1.1.1, etc.)
- [x] UDP + DNS - hostname resolution via QEMU's DNS server (10.0.2.3)
- [x] TCP - full TCP state machine with 3-way handshake, send/recv, close
- [x] HTTP client - `/bin/fetch` can make HTTP requests to real websites!
- [x] Web Browser - `/bin/browser` GUI browser with HTML rendering, works on HTTP sites

## Architecture Decisions Made
1. **Target**: QEMU virt machine, aarch64, Cortex-A72
2. **Memory start**: 0x40000000 (QEMU virt default)
3. **UART**: PL011 at 0x09000000 (QEMU virt default)
4. **Stack**: 64KB, placed in .stack section after BSS
5. **Toolchain**: aarch64-elf-gcc (brew install)
6. **Compiler flags**: -mstrict-align (prevent unaligned SIMD), FPU enabled
7. **Process model**: Win3.1 style - no memory protection, programs run in kernel space

## Roadmap (Terminal-First)
Phase 1: Kernel Foundations - DONE
1. ~~Memory management~~ - heap allocator working
2. ~~libc basics~~ - string functions, sprintf
3. ~~Display~~ - framebuffer, console, font
4. ~~Keyboard~~ - virtio-input with shift keys
5. ~~Shell~~ - in-kernel with basic commands
6. ~~Filesystem~~ - in-memory VFS

Phase 2: Programs - MONOLITH APPROACH
7. ~~ELF loader~~ - working but abandoned
8. ~~Kernel API~~ - kapi struct with function pointers
9. **DECISION**: Monolith kernel - all commands built into shell
   - Tried external programs, hit linker issues with 6+ embedded binaries
   - Win3.1 vibes - everything in one binary is fine

Phase 3: Apps (DONE)
10. ~~Text editor~~ - vi clone with modal editing (normal/insert/command modes)
11. ~~Snake~~ - moved to /bin/snake userspace program
12. ~~Tetris~~ - moved to /bin/tetris userspace program

Phase 4: GUI (IN PROGRESS)
13. ~~Mouse driver~~ - virtio-tablet support
14. ~~Window manager~~ - /bin/desktop with draggable windows, close boxes
15. ~~Double buffering~~ - reduces flicker
16. ~~Terminal emulator~~ - /bin/term with stdio hooks
17. ~~Visual refresh~~ - True 1-bit B&W System 7 aesthetic
18. Notepad/text editor, file explorer - TODO
19. DOOM?

## Technical Notes

### QEMU virt Machine Memory Map
- 0x00000000 - 0x3FFFFFFF: Flash, peripherals
- 0x08000000: GIC (interrupt controller)
- 0x09000000: UART (PL011)
- 0x0A000000: RTC
- 0x0A003E00: Virtio keyboard (device 31)
- 0x40000000+: RAM (we load here)
- 0x41000000+: Program load area (dynamically allocated by kernel)

### Key Files
- boot/boot.S - Entry point, EL3EL1 transition, BSS clear, .data copy
- kernel/kernel.c - Main kernel code
- kernel/dtb.c/.h - Device Tree Blob parser (RAM detection)
- kernel/memory.c/.h - Heap allocator (malloc/free), dynamic sizing
- kernel/string.c/.h - String/memory functions
- kernel/printf.c/.h - Printf implementation
- kernel/fb.c/.h - Framebuffer driver (ramfb)
- kernel/console.c/.h - Text console (with UART fallback)
- kernel/font.c/.h - Bitmap font
- kernel/keyboard.c/.h - Virtio keyboard driver (interrupt-driven)
- kernel/irq.c/.h - GIC-400 interrupt controller driver
- kernel/vectors.S - Exception vector table
- kernel/virtio_blk.c/.h - Virtio block device driver
- kernel/fat32.c/.h - FAT32 filesystem driver (read/write)
- kernel/shell.c/.h - In-kernel shell with all commands
- kernel/vfs.c/.h - Virtual filesystem (backed by FAT32 or in-memory)
- kernel/vi.c/.h - Modal text editor (vi clone)
- kernel/elf.c/.h - ELF64 loader (supports PIE binaries)
- kernel/process.c/.h - Process table, scheduler, context switching
- kernel/context.S - Assembly context switch routine
- kernel/kapi.c/.h - Kernel API for programs
- kernel/initramfs.c/.h - Binary embedding (currently unused)
- kernel/virtio_sound.c/.h - Virtio sound driver (WAV playback)
- linker.ld - Memory layout (flash + RAM regions)
- Makefile - Build system
- disk.img - FAT32 disk image (created by `make disk`)

### User Directory (userspace programs)
- user/lib/vibe.h - Userspace library header
- user/lib/gfx.h - Shared graphics primitives (header-only)
- user/lib/icons.h - Dock icons and VibeOS logo bitmaps
- user/lib/crt0.S - C runtime startup
- user/bin/*.c - Program sources
- user/linker.ld - Program linker script (PIE, base at 0x0)

### Build & Run
```bash
make            # Build kernel AND all user programs (everything)
make clean      # Clean build artifacts
make disk       # Create FAT32 disk image (only needed once)
make run        # Run with GUI window (serial still in terminal)
make run-nographic  # Terminal only
make distclean  # Clean everything including disk image
```

**IMPORTANT**: `make` builds EVERYTHING - kernel and all user programs. There is no separate user-progs target. Just use `make clean && make` to rebuild.

### Mounting the Disk Image (macOS)
```bash
hdiutil attach disk.img        # Mount
# ... add/edit files in /Volumes/VIBEOS/ ...
hdiutil detach /Volumes/VIBEOS # Unmount before running QEMU
```

### Shell Commands
| Command | Description |
|---------|-------------|
| help | Show available commands |
| clear | Clear screen |
| echo [text] | Print text (supports > redirect) |
| version | Show VibeOS version |
| mem | Show memory info |
| pwd | Print working directory |
| ls [path] | List directory contents |
| cd <path> | Change directory |
| mkdir <dir> | Create directory |
| touch <file> | Create empty file |
| rm <file> | Remove file |
| cat <file> | Show file contents |
| vi <file> | Edit file (modal editor) |

### VFS Structure
```
/
 bin/        (empty - monolith kernel)
 etc/
    motd    (message of the day)
 home/
    user/   (default cwd)
 tmp/
```

## Architecture Decisions (Locked In)
| Component | Decision | Notes |
|-----------|----------|-------|
| Kernel | Monolithic | Everything in kernel space, Win3.1-style |
| Programs | PIE on disk | Loaded dynamically at runtime, kernel picks address |
| Memory | Flat (no MMU) | No virtual memory, shared address space |
| Multitasking | Cooperative | Programs call yield(), round-robin scheduler |
| Filesystem | FAT32 on virtio-blk | Persistent, mountable on host, read/write |
| Shell | POSIX-ish | Familiar syntax, basic redirects |
| RAM | Detected via DTB | Works with 256MB-4GB+, heap sized dynamically |
| Disk | 64MB FAT32 | Persistent storage via virtio-blk |
| Interrupts | GIC-400 | Keyboard & mouse via IRQ, boots at EL3 for full GIC access |
| Power | WFI idle | Scheduler sleeps CPU when no work, wakes on interrupt |

## Gotchas / Lessons Learned
- **aarch64 va_list**: Can't pass va_list to helper functions easily. Inline the va_arg handling.
- **QEMU virt machine**: Uses PL011 UART at 0x09000000, GIC at 0x08000000
- **Virtio legacy vs modern**: QEMU defaults to legacy virtio (version 1). Use `-global virtio-mmio.force-legacy=false` to get modern virtio (version 2).
- **Virtio memory barriers**: ARM needs `dsb sy` barriers around device register access.
- **strncpy hangs**: Our strncpy implementation causes hangs in some cases. Use manual loops instead.
- **Static array memset**: Don't memset large static arrays - they're already zero-initialized.
- **GIC Security Groups**: GIC interrupts require matching security configuration. If running in Secure EL1, use Group 0 interrupts. Group 1 interrupts in Secure state return IRQ 1022 (spurious). Boot with `-bios` and `secure=on` to start at EL3 with full GIC register access.
- **-mgeneral-regs-only**: Use this flag to prevent GCC from using SIMD registers.
- **Stack in BSS**: Boot hangs if stack is in .bss section - it gets zeroed while in use! Put stack in separate .stack section.
- **Embedded binaries**: objcopy binary embedding breaks with 6+ programs. Linker issue. Just use monolith kernel instead.
- **Console without framebuffer**: console_puts/putc fall back to UART if fb_base is NULL.
- **kapi colors**: Must use uint32_t for colors (RGB values like 0x00FF00), not uint8_t.
- **Packed structs on ARM**: Accessing fields in `__attribute__((packed))` structs causes unaligned access faults. Read bytes individually and assemble values manually.
- **FAT32 minimum size**: FAT32 requires at least ~33MB. Use 64MB disk image.
- **Virtio-blk polling**: Save `used->idx` before submitting request, then poll until it changes. Don't use a global `last_used_idx` that persists across requests.
- **Virtio-input device detection**: Both keyboard and tablet are virtio-input. Must check device name contains "Keyboard" specifically, not just starts with "Q".
- **Userspace has no stdint.h**: Use `unsigned long` instead of `uint64_t` in user programs, or define types in vibe.h.
- **PIE on AArch64**: Use `-fPIE` and `-pie` flags. ELF loader processes R_AARCH64_RELATIVE relocations at load time.
- **Context switch**: Only need to save callee-saved registers (x19-x30, sp). Caller-saved regs are already on stack.
- **PIE relocations (FIXED!)**: Use `-O0` for userspace to ensure GCC generates relocations for static pointer initializers. With `-O2`, GCC tries to be clever and compute addresses at runtime, but puts structs in BSS (zeroed) so pointers are NULL. The ELF loader now processes `.rela.dyn` section and fixes up `R_AARCH64_RELATIVE` entries. Normal C code with pointers now works!
- **strtok_r NULL rest**: After the last token, `strtok_r` sets `rest` to NULL (not empty string). Always check `rest && *rest` before dereferencing.
- **Flash/RAM linker split**: When booting via `-bios`, code lives in flash (0x0) but data/BSS must be in RAM (0x40000000). Use separate MEMORY regions in linker script with `AT>` for load addresses. Copy .data from flash to RAM at boot.
- **EL3EL1 direct**: Can skip EL2 entirely. Set `SCR_EL3` with NS=0 (stay Secure), RW=1 (AArch64), then eret to EL1.
- **WFI in scheduler**: When a process yields and it's the only runnable process, WFI before returning to it. This prevents busy-wait loops from cooking the CPU. The kernel handles idle, not individual apps.
- **Don't double-sleep**: If kernel WFIs on idle, apps shouldn't also sleep_ms() - that causes double delay and sluggish UI. Apps just yield(), kernel handles the rest.
- **FAT32 LFN + GCC -O2**: The LFN entry building code crashes with -O2 optimization. Use -O0 for fat32.c. Symptom: translation fault when writing to valid heap memory. Root cause unknown but likely optimizer generating bad code for the byte-by-byte LFN entry construction.
- **Stack must be above BSS**: As kernel grows, BSS section grows. Stack pointer must be well above BSS end. Originally at 0x40010000, but BSS grew to 0x400290d4 - stack was inside BSS and got zeroed during boot! Moved to 0x40100000 (1MB into RAM).
- **_data_load must be 8-byte aligned**: AArch64 `ldr x3, [x0]` instruction requires 8-byte alignment. If `_data_load` in linker script is not aligned, boot hangs during .data copy loop. Add `. = ALIGN(8);` before `_data_load = .;`.
- **Build with -O0 for safety**: GCC optimization causes subtle bugs in OS code - PIE relocations, LFN construction, possibly virtio drivers. Using -O0 everywhere avoids these issues at cost of larger/slower code.
- **FPU enable**: Set CPACR_EL1.FPEN = 0b11 in boot.S to enable FP/SIMD. Without this, any FP instruction causes an exception.
- **FP context switch**: When FPU is enabled, context_switch must save/restore q0-q31, fpcr, fpsr. The fp_regs array must be 16-byte aligned (stp/ldp q regs require this). Added padding to cpu_context_t to ensure fp_regs is at offset 0x80.
- **-mstrict-align required with FPU**: Without -mgeneral-regs-only, GCC uses SIMD for memcpy/struct copies. Some SIMD loads require aligned addresses. Use -mstrict-align to prevent unaligned SIMD access faults.
- **Kernel stack vs heap collision**: Heap runs from `_bss_end + 0x10000` to `0x41000000`. If kernel stack is inside this range, large allocations (like framebuffer backbuffer) will overwrite the stack. Symptom: local variables corrupted with data like `0x00ffffff` (COLOR_WHITE). Stack was at 0x40100000 (inside heap!). Moved to 0x4F000000 (well above heap and program area).
- **DTB at RAM start**: QEMU places the Device Tree Blob at 0x40000000 (start of RAM). Linker script must start .data/.bss after DTB area (we use 0x40200000, leaving 2MB for DTB).
- **DTB unaligned access**: Reading 32/64-bit values from DTB can cause alignment faults on ARM. Read bytes individually and assemble manually (see `read_be32`/`read_be64` in dtb.c).

## Session Log
### Session 1
- Created project structure
- Wrote bootloader, minimal kernel, linker script, Makefile
- Successfully booted in QEMU, UART output works
- Decided on retro Mac aesthetic
- Human confirmed: terminal-first approach, take it slow
- Added memory management (heap allocator) - working
- Added string functions and printf - working after fixing va_list issue

### Session 2
- Fixed virtio keyboard (was using legacy mode, switched to modern with force-legacy=false)
- Built framebuffer driver using ramfb
- Added bitmap font and text console with colors
- Built in-kernel shell with commands
- Attempted interrupts (GIC, timer, exception vectors) - breaks virtio keyboard
- Debugged extensively, even asked Gemini - couldn't find root cause
- Decided to skip interrupts (cooperative multitasking doesn't need them)
- Built in-memory VFS filesystem
- Added coreutils: ls, cd, pwd, mkdir, touch, cat
- Added echo with > redirect for writing files
- Added shift key support for keyboard (uppercase, symbols like >)
- Everything working! Shell, filesystem, keyboard all functional

### Session 3
- Attempted proper userspace with syscalls (SVC instruction)
- SVC never triggered exception handler - extensive debugging failed
- Pivoted to Win3.1 style: programs run in kernel space, call kapi directly
- Built ELF loader and process execution
- Created kapi (kernel API) - struct of function pointers
- Fixed multiple bugs: ELF load address (0x40200000), crt0 return address, color types
- Attempted to move shell commands to /bin as separate programs
- Hit weird linker bug: 5 embedded programs work, 6 breaks boot
- Extensive debugging: not size, not specific program, just "6th binary breaks it"
- Stack was in BSS and getting zeroed - fixed by putting in .stack section
- Still couldn't fix the 6-binary limit
- **DECISION**: Monolith kernel. All commands stay in shell. Fuck it, it's VibeOS.
- Final kernel: 28KB, all features working

### Session 6
- Revisited the external binaries problem - decided to use persistent FAT32 filesystem instead
- Built virtio-blk driver for block device access
- Implemented FAT32 filesystem driver (read-only)
- Integrated FAT32 with VFS - now `/` is backed by the disk image
- Updated Makefile to create and format 64MB FAT32 disk image
- Fixed multiple bugs:
  - Virtio-blk polling logic (was using stale `last_used_idx`)
  - Packed struct access on ARM (unaligned access faults) - read bytes manually
  - FAT32 minimum size requirement (increased from 32MB to 64MB)
- Disk image is mountable on macOS with `hdiutil attach disk.img`
- Can now put binaries on disk and load them at runtime (solves the 6-binary limit!)
- **Achievement**: Persistent filesystem working! Files survive reboots!

### Session 7
- Made FAT32 filesystem writable!
- Added FAT table write support (fat_set_cluster) - updates both FAT copies
- Added cluster allocation (fat_alloc_cluster) - finds free clusters
- Added cluster chain freeing (fat_free_chain)
- Implemented fat32_create_file() - create empty files
- Implemented fat32_mkdir() - create directories with . and .. entries
- Implemented fat32_write_file() - write data to files, handles cluster allocation
- Implemented fat32_delete() - delete files and free their clusters
- Updated VFS layer to use FAT32 write functions
- Now mkdir, touch, echo > file all persist to disk!
- Files created in VibeOS are visible when mounting disk.img on macOS
- **Achievement**: Full read/write persistent filesystem!

### Session 8
- Moved snake and tetris from kernel to userspace (/bin/snake, /bin/tetris)
- Extended kapi with framebuffer access (fb_base, width, height, drawing functions)
- Extended kapi with mouse input (position, buttons, poll)
- Added uart_puts to kapi for direct UART debug output
- Built virtio-tablet mouse driver (kernel/mouse.c)
- Fixed keyboard detection to not conflict with tablet (both are virtio-input)
- Created /bin/desktop - window manager with:
  - Classic Mac System 7 aesthetic (gray desktop, striped title bars)
  - Draggable windows by title bar
  - Close boxes that work
  - Menu bar (File, Edit, View, Special)
  - Mouse cursor with save/restore
  - Double buffering to reduce flicker
- Fixed heap/program memory overlap bug:
  - Backbuffer allocation (~2MB) was overlapping program load address
  - Moved program load address from 0x40200000 to 0x40400000
- **Achievement**: GUI desktop environment working!

### Session 9
- Implemented dynamic program loading - no more hardcoded addresses!
- Converted userspace programs to PIE (Position Independent Executables)
  - Updated user/linker.ld to base at 0x0
  - Added `-fPIE` and `-pie` compiler/linker flags
- Enhanced ELF loader:
  - elf_load_at() loads PIE binaries at any address
  - elf_calc_size() calculates memory requirements
  - Supports both ET_EXEC and ET_DYN types
- Built cooperative multitasking infrastructure:
  - Process table (MAX_PROCESSES = 16)
  - Process states: FREE, READY, RUNNING, BLOCKED, ZOMBIE
  - Round-robin scheduler
  - Context switching in assembly (kernel/context.S)
  - yield() and spawn() added to kapi
- Programs now load at 0x41000000+ with kernel picking addresses dynamically
- Tested: desktopsnaketetrisdesktop all load at different addresses
- **Achievement**: Dynamic loading and multitasking foundation complete!

### Session 10
- Added Apple menu with dropdown (About VibeOS..., Quit Desktop)
- Removed Q keyboard shortcut - quit only via Apple menu now
- Added font_data pointer to kapi for userspace text rendering
- Fixed window rendering - all drawing now goes to backbuffer:
  - Added bb_draw_char/bb_draw_string for backbuffer text
  - Windows properly occlude each other (no text bleed-through)
  - Title bars, content areas, and borders all render correctly
- Created LONGTERM.md with roadmap

### Session 11
- Added dock bar at bottom of screen with app icons
- Built Calculator app (first desktop app!):
  - Calculator icon in dock (32x32 pixel art)
  - Click dock icon to open calculator window
  - Working integer arithmetic (+, -, *, /)
  - 3D button styling with proper hit detection
  - Shows pending operation in display
  - Fixed PIE string literal issue (2D char* array  flat char[][] array)
- Improved menu bar layout and spacing
- Windows can't be dragged below the dock

### Session 12
- Built File Explorer app:
  - Folder icon in dock
  - Navigate directories (click to select, double-click to enter)
  - Path bar showing current location
  - ".." to go up a directory
  - Right-click context menu with: New File, New Folder, Rename, Delete
  - Inline rename with keyboard input (Enter to confirm, Escape to cancel)
- Added rm command to shell
- Added vfs_delete() and vfs_rename() to VFS layer
- Added fat32_rename() - modifies directory entry name in place
- Extended kapi with delete, rename, readdir, set_cwd, get_cwd
- Fixed macOS junk files (._, .DS_Store, .fseventsd) in Makefile:
  - Disk mounts with -nobrowse to prevent Finder indexing
  - Cleanup commands run after every mount/install

### Session 13
- Added snake and tetris game launchers to dock:
  - Snake icon (32x32 pixel art green snake)
  - Tetris icon (32x32 colorful blocks)
  - Click to launch games from desktop
- Fixed cooperative multitasking to actually work:
  - Added yield() calls to desktop, snake, and tetris main loops
  - Fixed process_yield() to work from kernel context (was returning early)
  - Made process_exec() create real process entries (was direct function call)
  - Added kernel_context to save/restore when switching between kernel and processes
- Games now use exec() instead of spawn():
  - Desktop blocks while game runs, resumes when game exits
  - Clean handoff - no screen fighting between processes
- **Achievement**: Can launch games from dock and return to desktop!

### Session 14
- Built userspace shell `/bin/vibesh`:
  - Boots directly into vibesh (kernel shell is now just a bootstrap)
  - Parses commands, handles builtins (cd, exit, help)
  - Executes external programs from /bin with argument passing
- Built userspace coreutils:
  - `/bin/echo` - with output redirection support (echo foo > file)
  - `/bin/ls` - uses proper readdir API
  - `/bin/cat` - supports multiple files
  - `/bin/pwd` - print working directory
  - `/bin/mkdir`, `/bin/touch`, `/bin/rm` - file operations
- Added `exec_args` to kapi for passing argc/argv to programs
- Added `console_rows`/`console_cols` to kapi
- Fixed process exit bug:
  - process_exit() was returning when no other processes existed
  - Now context switches directly back to kernel_context
- Attempted userspace vi but hit PIE/BSS issues:
  - Static variables in PIE binaries don't work reliably
  - Even heap-allocated state with function pointer calls hangs
  - Abandoned - will make GUI editor instead
- **Achievement**: Userspace shell and coreutils working!

### Session 15
- **MAJOR BREAKTHROUGH: Fixed PIE relocations!**
  - Userspace C code now works like normal C - pointers, string literals, everything
  - Problem: Static initializers with pointers (e.g., `const char *label = "hello"`) were broken
  - Root cause: With `-O2`, GCC generates PC-relative code but puts struct in BSS (zeroed), so pointers are NULL
  - Solution 1: Use `-O0` for userspace so GCC generates proper relocations
  - Solution 2: ELF loader now processes `.rela.dyn` section with `R_AARCH64_RELATIVE` entries
  - Added `Elf64_Dyn`, `Elf64_Rela` structs and `elf_process_relocations()` to kernel/elf.c
  - Formula: `*(load_base + offset) = load_base + addend`
- Rebuilt desktop from scratch (old one was a mess with everything embedded):
  - Clean window manager architecture
  - Desktop just manages windows, dock, menu bar, cursor
  - Apps are separate binaries that use window API via kapi
  - Fullscreen apps (snake, tetris) use exec() - desktop waits
  - Windowed apps (calc) use spawn() + window API
- Built Calculator app (`/bin/calc`):
  - First proper windowed app using the new window API
  - Creates window, gets buffer, draws buttons, receives events
  - Working integer arithmetic
- Window API in kapi:
  - `window_create()`, `window_destroy()`, `window_get_buffer()`
  - `window_poll_event()`, `window_invalidate()`, `window_set_title()`
  - Desktop registers these functions at startup
- **Achievement**: Can now write normal C code in userspace! This unlocks everything.

### Session 16
- **Visual refresh - True Mac System 7 aesthetic!**
  - Pure 1-bit black & white color scheme
  - Classic Mac diagonal checkerboard desktop pattern
  - Apple logo (16x16 bitmap) in menu bar
  - Beautiful 32x32 pixel art dock icons: Snake, Tetris, Calculator, Files, Terminal
  - System 7 window chrome: horizontal stripes on focused title bars, drop shadows, double-line borders
  - Close box with inner square when focused
  - Clock in menu bar (decorative)
- **Built Terminal Emulator (`/bin/term`)!**
  - 80x24 character window with monospace font
  - Spawns vibesh shell inside the window
  - Stdio hooks mechanism: `stdio_putc`, `stdio_puts`, `stdio_getc`, `stdio_has_key`
  - Shell and all coreutils use hooks when available, fall back to console otherwise
  - Keyboard input via window events  ring buffer  shell reads
  - Inverse block cursor
- **Updated all coreutils for terminal support:**
  - ls, cat, echo, pwd, mkdir, touch, rm all use `out_puts`/`out_putc` helpers
  - Check for stdio hooks, use them if set, otherwise use console I/O
  - Works in both kernel console AND terminal window
- **Achievement**: Shell running inside a GUI window! Can run commands, see output, everything works!

### Session 17
- **INTERRUPTS FINALLY WORKING!**
  - Root cause found: GIC security groups. Running in Non-Secure EL1 but trying to configure Group 0 registers was a no-op.
  - Solution: Boot at EL3 (Secure) using `-bios` instead of `-kernel`, stay in Secure world
  - Changed QEMU flags: `-M virt,secure=on -bios vibeos.bin`
  - Updated linker script: code at 0x0 (flash), data/BSS in RAM (0x40000000)
  - Updated boot.S: EL3EL1 transition (skip EL2), copy .data from flash to RAM
  - GIC configured for Group 0 (Secure) interrupts
- **New files:**
  - `kernel/irq.c` / `kernel/irq.h` - GIC-400 driver, timer support
  - `kernel/vectors.S` - Exception vector table for AArch64
- **Keyboard now interrupt-driven:**
  - Registered IRQ handler for virtio keyboard (IRQ 78)
  - No more polling needed for keyboard input
- **Fixed FAT32 bug:**
  - `resolve_path()` was dereferencing NULL `rest` pointer from `strtok_r`
  - Added NULL check: `if (rest && *rest && ...)`
- **Timer ready but disabled:**
  - Timer IRQ handler exists, can enable preemptive multitasking later
  - Currently disabled to keep cooperative model stable
- **Achievement**: Full interrupt support! GIC mystery finally solved after Sessions 2-3 failures!

### Session 18
- **Enabled timer for uptime tracking:**
  - Timer fires at 100Hz (10ms intervals)
  - `timer_get_ticks()` returns tick count since boot
  - Keeping cooperative multitasking (no preemption)
- **Added uptime command (`/bin/uptime`):**
  - Shows hours/minutes/seconds since boot
  - Also shows raw tick count
  - Fixed crash: uptime wasn't in USER_PROGS list, old binary had wrong kapi struct
- **Added memory stats to kapi:**
  - `get_mem_used()` and `get_mem_free()`
  - Heap is ~16MB (between BSS end and program load area at 0x41000000)
- **Built System Monitor GUI app (`/bin/sysmon`):**
  - Classic Mac-style windowed app
  - Shows uptime (updates live)
  - Shows memory usage with progress bar (diagonal stripes pattern)
  - Shows used/free memory in MB
  - Auto-refreshes every ~500ms
- **Gotcha: USER_PROGS list**
  - New userspace programs MUST be added to USER_PROGS in Makefile
  - Old binaries on disk with outdated kapi struct will crash!
- **Achievement**: Timer working! System monitoring! The vibes are immaculate.

- **Built TextEdit (`/bin/textedit`):**
  - Simple GUI text editor - no modes, just type
  - Arrow keys, Home, End, Delete all work
  - Ctrl+S to save
  - Save As modal dialog when no filename set
  - Status bar shows filename, line:col, modified indicator
  - Scrolling for long files
  - Usage: `textedit` or `textedit /path/to/file`
- **Enhanced keyboard driver:**
  - Arrow keys now return special codes (0x100-0x106)
  - Ctrl modifier support (Ctrl+A = 1, Ctrl+S = 19, etc.)
  - Key buffer changed from `char` to `int` to support extended codes
  - Added Home, End, Delete key support
- **TextEdit enhancements:**
  - Line numbers in gray gutter on the left
  - Tab key inserts 4 spaces
  - Auto-close brackets and quotes: `()`, `[]`, `{}`, `""`, `''`
  - C syntax highlighting (detects .c and .h files):
    - Keywords in dark blue (if, else, for, while, return, etc.)
    - Comments in dark green (// and /* */)
    - String literals in dark red
    - Numbers in purple
  - Colors only appear in apps where it makes sense (desktop stays 1-bit B&W)
- **Achievement**: Real text editor with IDE-lite features!

### Session 19
- **Built File Explorer (`/bin/files`):**
  - Windowed GUI file browser
  - Navigate directories (click to select, double-click to enter)
  - Path bar showing current location
  - ".." to go up a directory
  - Right-click context menu with:
    - New File / New Folder (with inline rename UI)
    - Rename (inline text editing)
    - Delete (recursive - works on non-empty directories!)
    - Open with TextEdit
    - Open Terminal Here
  - Keyboard navigation (arrow keys, Enter, Backspace)
- **Added right-click support to desktop:**
  - Desktop now detects right mouse button clicks
  - Passes button info to windowed apps via event data3
- **Implemented recursive directory deletion:**
  - `fat32_delete_recursive()` - deletes files and directories recursively
  - Walks directory tree, deletes children first, then parent
  - Exposed via `vfs_delete_recursive()` and kapi
- **Improved create file/folder UX:**
  - "New File" / "New Folder" now shows inline rename field immediately
  - Type the name and press Enter to actually create
  - Press Escape to cancel
  - No more "untitled" / "newfolder" placeholder names
- **Achievement**: Full-featured file explorer!

### Session 21
- **Power management overhaul - CPU no longer cooks the host!**
  - Problem: Desktop was redrawing at infinite FPS, QEMU using 150% CPU
  - Root cause: Busy-wait loops everywhere, no sleeping
- **Mouse now interrupt-driven:**
  - Added `mouse_get_irq()` and `mouse_irq_handler()` (like keyboard)
  - Registered mouse IRQ in kernel.c
- **Added sleep functions to kapi:**
  - `wfi()` - ARM Wait For Interrupt instruction
  - `sleep_ms(ms)` - Sleep for at least N milliseconds using timer ticks
- **Kernel-level idle via WFI:**
  - When process yields and it's the only runnable process, scheduler calls WFI
  - CPU sleeps until next interrupt (timer at 100Hz, keyboard, or mouse)
  - This is the RIGHT approach - kernel handles idle, not apps
- **Removed busy-wait delays from games:**
  - Snake and Tetris had `delay()` functions doing NOPs
  - Replaced with `sleep_ms()` for proper game tick timing
- **Fixed recovery shell:**
  - Was busy-looping on `keyboard_getc()` with no sleep
  - Now WFIs when no input available
- **UI apps just yield():**
  - Desktop, calc, files, textedit, term, sysmon - all just call `yield()`
  - Kernel WFIs if nothing else to do, wakes on interrupt
  - Effective frame rate: 100fps (timer is 100Hz)
- **Result:**
  - CPU usage dropped from 150% to ~10% idle
  - UI runs at smooth 100fps
  - Mouse and keyboard remain responsive (interrupt-driven)
- **Achievement**: Proper power management! VibeOS is now a good citizen.

### Session 22
- **FAT32 Long Filename (LFN) Writing - COMPLETE!**
  - Can now create files/directories with any name length (up to 255 chars)
  - Implemented `needs_lfn()` - detects when LFN is required (lowercase, length, special chars)
  - Implemented `generate_basis_name()` - creates 8.3 basis from long name
  - Implemented `generate_short_name()` - creates unique 8.3 name with ~1, ~2, etc. suffix
  - Implemented `build_lfn_entry()` - constructs LFN directory entries with UTF-16LE encoding
  - Implemented `find_free_dir_entries()` - finds N consecutive free slots for LFN + short entry
  - Updated `create_dir_entry()` - writes LFN entries in reverse order followed by 8.3 entry
  - Updated `fat32_rename()` - deletes old entries (including LFN), creates new with LFN support
  - Updated `fat32_delete()`, `fat32_delete_dir()`, `fat32_delete_recursive()` - properly deletes LFN entries
  - Added `delete_dir_entry_with_lfn()` - finds and marks all associated LFN entries as deleted
- **Build fix**: fat32.c requires -O0 (added to Makefile)
  - GCC -O2 generates bad code for LFN byte manipulation
  - Caused translation faults when writing to valid heap memory
- **Achievement**: Full LFN support! `touch "my long filename.txt"` works!

### Session 23
- **Virtio Sound Driver - Audio playback working!**
  - Built complete virtio-sound driver (kernel/virtio_sound.c, kernel/virtio_sound.h)
  - Device ID 25, virtqueues: controlq (0), eventq (1), txq (2), rxq (3)
  - PCM stream lifecycle: set_params  prepare  start  submit data  stop
  - WAV file parsing with format/rate detection
  - Supports 44100Hz, 48000Hz sample rates; 16-bit stereo/mono
- **New files:**
  - `kernel/virtio_sound.c` - Full virtio sound driver (~600 lines)
  - `kernel/virtio_sound.h` - Public API: play_wav, stop, is_playing
  - `user/bin/play.c` - Userspace play command
- **Added to kapi:**
  - `sound_play_wav(data, size)` - Play WAV from memory
  - `sound_stop()` - Stop playback
  - `sound_is_playing()` - Check if playing
- **QEMU flags updated:**
  - Added `-device virtio-sound-device,audiodev=audio0 -audiodev coreaudio,id=audio0`
- **Critical boot fixes:**
  - Stack was at 0x40010000, inside BSS (0x40001000-0x400290d4) - getting overwritten!
  - Moved stack to 0x40100000 (1MB into RAM) in boot.S
  - `_data_load` at 0x1a9bb was NOT 8-byte aligned - caused hang during data copy
  - Added `. = ALIGN(8);` before `_data_load = .;` in linker.ld
- **Build change:**
  - Changed to `-O0` everywhere (both kernel and userspace) to avoid optimization issues
- **Fixed slow file loading:**
  - `play.c` was reading file twice: once to get size, once to load data
  - Added `file_size()` to kapi - returns vfs_node->size directly
  - Now files load instantly instead of 7+ seconds
- **Achievement**: VibeOS can play audio! `play /beep.wav` works!

### Session 24
- **Floating Point Support - COMPLETE!**
  - Enabled FPU in boot.S: `mov x0, #(3 << 20); msr cpacr_el1, x0`
  - Removed `-mgeneral-regs-only` from CFLAGS (was blocking all FP)
  - Added `-mstrict-align` to prevent unaligned SIMD access faults
  - GCC now uses SIMD for memcpy/struct ops, which is fine with strict-align
- **Context switch updated for FP state:**
  - Extended cpu_context_t: added fpcr, fpsr, _pad, fp_regs[64]
  - _pad ensures fp_regs is at offset 0x80 (16-byte aligned for stp/ldp q regs)
  - context.S now saves/restores all 32 Q registers (q0-q31) plus fpcr/fpsr
- **Calculator now uses floating point:**
  - Changed display_value/pending_value from int to double
  - Added decimal point button (replaced C button)
  - Added float_to_str() for display (no printf %f available)
  - Clear via 'c'/'C' keyboard key
  - Can now do: 10 / 3 = 3.333333, 3.14159 * 2, etc.
- **MAJOR BUG FIX: Kernel stack vs heap collision**
  - Symptom: Process exit crashed with `0x00ffffff` in return address
  - Root cause: Kernel stack at 0x40100000 was INSIDE heap range (0x4003c0d4 - 0x41000000)
  - Large heap allocations (backbuffer) overwrote stack with framebuffer data
  - Debug showed local variable `old_pid` corrupted from -1 to 0x00ffffff (COLOR_WHITE)
  - Fix: Moved stack to 0x4F000000, well above heap and program load area
- **Memory layout clarified:**
  ```
  0x40000000 - 0x40200000: DTB (Device Tree Blob, placed by QEMU)
  0x40200000 - 0x40237000: Kernel .data/.bss
  0x40247000 - 0x4E000000: Heap (dynamic, up to stack - 1MB)
  0x4E000000+:             Program load area (after heap)
  0x4F000000:              Kernel stack (grows down, hardcoded)
  RAM end:                 Detected from DTB (256MB-4GB+)
  ```
- **Memory collision issue (MOSTLY FIXED in Session 26)**
  - Was: hardcoded magic numbers everywhere that collided as kernel grew
  - Now: heap and program areas are dynamic based on DTB-detected RAM
  - Stack is still hardcoded at 0x4F000000 (works for 256MB+ systems)
  - Heap is bounded by stack address, so can't overflow into stack anymore
- **Achievement**: Floating point works! Calculator does decimals! Processes exit cleanly!

- **Enabled -O3 optimization!**
  - Changed CFLAGS and USER_CFLAGS from -O0 to -O3
  - Everything works except kernel's `fat32_delete_recursive()` which breaks with -O3
  - Solution: Moved recursive delete logic to userspace (rm.c and files.c)
  - Kernel only needs to delete single files and empty directories
  - Userspace iterates with `readdir()` and deletes children before parent
- **Userspace recursive delete:**
  - `rm -r` now implements recursion in userspace
  - Files app delete action uses same userspace implementation
  - Works correctly with -O3 optimization
- **Achievement**: Full -O3 optimization across kernel and userspace!

### Session 25
- **Desktop modularization - code cleanup!**
  - Extracted icon bitmaps to `user/lib/icons.h` (~500 lines of bitmap data)
  - Created VibeOS logo (stylized "V") to replace Apple logo
  - Created shared graphics library `user/lib/gfx.h` (header-only, ~130 lines)
  - Updated all GUI apps to use gfx.h instead of duplicated drawing code:
    - desktop.c, calc.c, sysmon.c, files.c, textedit.c
  - Removed ~250 lines of duplicated buf_*/bb_* drawing functions across apps
  - desktop.c reduced from ~1500 to ~1200 lines
- **New files:**
  - `user/lib/icons.h` - All 32x32 dock icons + 16x16 VibeOS logo
  - `user/lib/gfx.h` - gfx_ctx_t context, put_pixel, fill_rect, draw_char, draw_string, draw_rect, patterns
- **Architecture note:**
  - gfx.h is header-only with static inline functions - no Makefile changes needed
  - Apps use macros to alias old function names (buf_*, bb_*) to new gfx_* calls
  - Zero runtime overhead, compiler inlines everything
- **Achievement**: Cleaner codebase! Shared graphics primitives!

### Session 26
- **Device Tree Blob (DTB) parsing - RAM detection at runtime!**
  - Built DTB parser (`kernel/dtb.c`, `kernel/dtb.h`)
  - Parses QEMU's device tree to find memory node with base/size
  - Tested with 256MB, 1GB, 4GB - all detected correctly
- **Dynamic memory layout - no more hardcoded heap size!**
  - Linker script now starts RAM at 0x40200000 (preserves DTB at 0x40000000)
  - Heap size computed at runtime: from BSS end to (stack - 1MB buffer)
  - Program load area follows heap_end dynamically
  - Framebuffer now allocated via malloc instead of hardcoded address
- **Memory layout now:**
  - DTB preserved at 0x40000000 (up to 2MB reserved)
  - Kernel .data/.bss at 0x40200000+
  - Heap from BSS end to 0x4E000000 (~238MB on 256MB system)
  - Programs load after heap
  - Stack still hardcoded at 0x4F000000 (works for 256MB+ systems)
- **Key insight:** One shared address space (Win3.1 model)
  - Heap is shared by kernel + all apps
  - App static variables (`int x = 3`) live in ELF's .data section, loaded into program area
  - Only explicit `malloc()` uses the heap
- **Gotcha: DTB unaligned access**
  - Direct pointer casts to read 32/64-bit values cause alignment faults
  - Must read bytes individually and assemble (see `read_be32`/`read_be64`)
- **Achievement**: RAM detected dynamically! No more arbitrary 256MB cap!

### Session 27
- **MP3 Playback - minimp3 ported!**
  - Integrated minimp3 single-header decoder into userspace
  - Created stub headers `user/lib/stdlib.h` and `user/lib/string.h` for freestanding build
  - Added `memcmp`, `memmove` to string.h stub
  - `#define MINIMP3_NO_SIMD` to avoid NEON complexity (can enable later for perf)
- **Refactored sound API:**
  - Moved WAV parsing from kernel to userspace (kernel shouldn't parse file formats)
  - Added `sound_play_pcm(data, samples, channels, rate)` to kapi - flexible raw PCM playback
  - Kernel's `hz_to_rate_index()` converts Hz to virtio rate constants
- **Mono to stereo conversion:**
  - virtio-sound doesn't support mono playback
  - play.c converts mono MP3s to stereo by duplicating samples
- **Async (non-blocking) playback!**
  - Added `sound_play_pcm_async()` - starts playback and returns immediately
  - Added `virtio_sound_pump()` - called from timer interrupt (100Hz) to feed audio chunks
  - Audio plays in background while user continues using the system
  - PCM buffer must stay allocated during playback (memory is "orphaned" but OK for CLI)
- **play command upgraded:**
  - `play /file.wav` - plays WAV files
  - `play /file.mp3` - decodes and plays MP3 files
  - Auto-detects format by extension or magic bytes (RIFF, ID3, MP3 sync)
  - Shows format info: sample rate, channels, duration, bitrate
- **New/modified files:**
  - `vendor/minimp3.h` - Single-header MP3 decoder (already existed)
  - `user/lib/stdlib.h` - Empty stub for minimp3
  - `user/lib/string.h` - memcmp, memmove for minimp3
  - `user/bin/play.c` - WAV/MP3 player with async playback
  - `kernel/virtio_sound.c` - Added async playback, pump function
  - `kernel/irq.c` - Timer calls virtio_sound_pump()
- **Achievement**: MP3 playback with non-blocking audio! Music plays while you work!

### Session 28
- **Built GUI Music Player (`/bin/music`)!**
  - Classic Mac System 7 1-bit B&W aesthetic
  - Two-panel layout: album sidebar (160px) + track list
  - Scans `/home/user/Music/` for album folders containing MP3s
  - Click album to load tracks, double-click track to play
  - Playback controls: |< (back), Play/Pause, >| (next)
  - Progress bar with elapsed/total time display
  - Volume slider (visual only for now)
  - Keyboard shortcuts: Space (play/pause), N/P (next/prev), arrows (select), Enter (play)
  - Auto-advances to next track when song ends
- **Implemented pause/resume in kernel:**
  - Added `virtio_sound_pause()` - stops stream but keeps playback state
  - Added `virtio_sound_resume()` - reconfigures and restarts from paused position
  - Added `virtio_sound_is_paused()` - check pause state
  - New kapi functions: `sound_pause`, `sound_resume`, `sound_is_paused`
  - Pause saves offset, resume continues from where it left off
- **Fixed progress bar duration bug:**
  - `pcm_samples * 1000` was overflowing uint32_t for songs > 71 seconds
  - Changed to `(uint64_t)pcm_samples * 1000` for 64-bit multiplication
  - Added `uint64_t` typedef to `user/lib/vibe.h`
- **Music player icon added to dock:**
  - 32x32 musical note icon in `user/lib/icons.h`
  - Click dock icon to launch music player
- **New/modified files:**
  - `user/bin/music.c` - Full music player application (~800 lines)
  - `user/lib/icons.h` - Added music_icon bitmap
  - `user/bin/desktop.c` - Added Music app to dock
  - `kernel/virtio_sound.c` - Pause/resume support, state tracking
  - `kernel/virtio_sound.h` - New function declarations
  - `kernel/kapi.c`, `kernel/kapi.h` - Exposed pause/resume to userspace
  - `user/lib/vibe.h` - Added uint64_t, pause/resume kapi functions
- **Achievement**: Full-featured music player! Pause, resume, progress tracking all work!

### Session 29
- **Improved Terminal Emulator (`/bin/term`):**
  - 500-line scrollback buffer (ring buffer implementation)
  - Mouse drag scrolling - click and drag to scroll through history
  - Scroll indicator `[N]` in top-right when scrolled back
  - Auto-scroll to bottom on keystroke
  - Input buffer now uses `int` to preserve special keys (0x100+)
  - Form feed (\f) support for clear screen
- **Improved Shell (`/bin/vibesh`) with readline-like editing:**
  - Command history (50 commands) with Up/Down arrow navigation
  - `!!` to repeat last command
  - Ctrl+C - clear current line (prints ^C)
  - Ctrl+U - clear line before cursor
  - Ctrl+D - exit shell (EOF) when line empty
  - Ctrl+L - clear screen
  - Ctrl+R - reverse incremental search through history
  - Tab completion for commands (/bin) and file paths
  - `clear` builtin command
  - Left/Right arrows for cursor movement
  - Home/End to jump to start/end of line
  - Delete key support
- **Added special key constants to vibe.h:**
  - KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_HOME, KEY_END, KEY_DELETE
- **Achievement**: Proper terminal with scrollback and readline-style shell!

### Session 30
- **NETWORKING - VibeOS is on the internet!**
- **Virtio-net driver (`kernel/virtio_net.c`):**
  - Device ID 1, virtqueues: 0=receiveq, 1=transmitq
  - Reads MAC address from config space
  - Pre-populates RX buffers for async receive
  - Interrupt-driven packet notification (IRQ handler just acks, doesn't consume)
- **Network stack (`kernel/net.c`, `kernel/net.h`):**
  - Ethernet frame send/receive
  - ARP table (16 entries) with request/reply handling
  - IP layer with checksum calculation and routing
  - ICMP echo request/reply (ping)
  - Automatic gateway ARP resolution
- **Network configuration (QEMU user-mode NAT):**
  - Our IP: 10.0.2.15
  - Gateway: 10.0.2.2
  - DNS: 10.0.2.3
- **Ping command (`/bin/ping`):**
  - Parses IP addresses from command line
  - Sends 4 ICMP echo requests with 1 second timeout
  - Shows reply/timeout for each, plus statistics
- **QEMU flags updated:**
  - Added `-device virtio-net-device,netdev=net0 -netdev user,id=net0`
- **kapi additions:**
  - `net_ping(ip, seq, timeout_ms)` - Blocking ping
  - `net_poll()` - Process incoming packets
  - `net_get_ip()`, `net_get_mac()` - Get our addresses
- **New files:**
  - `kernel/virtio_net.c` (~400 lines) - Virtio network driver
  - `kernel/virtio_net.h` - Driver header
  - `kernel/net.c` (~450 lines) - Network stack
  - `kernel/net.h` - Network stack header
  - `user/bin/ping.c` - Ping command
- **Bug fixed: main() argument order**
  - crt0.S passes: `main(kapi_t*, argc, argv)`
  - ping.c had wrong order, caused crash on kapi access
- **Achievement**: Can ping 1.1.1.1 (Cloudflare) from VibeOS! Packets traverse the real internet!

### Session 31
- **UDP, DNS, TCP, and HTTP - Full network stack complete!**
- **UDP implementation (`kernel/net.c`):**
  - UDP listener table with callback system (8 ports)
  - `udp_bind(port, callback)` / `udp_unbind(port)` - register listeners
  - `udp_send(ip, src_port, dst_port, data, len)` - send packets
  - Checksum optional (set to 0, valid for IPv4)
- **DNS resolver (`kernel/net.c`):**
  - `dns_resolve(hostname)` - returns IP address or 0
  - Builds DNS query packets with proper QNAME encoding
  - Parses A records from response
  - Uses QEMU's built-in DNS at 10.0.2.3
- **Ping updated:**
  - `ping google.com` now works (resolves hostname first)
  - Auto-detects IP vs hostname input
- **TCP implementation (`kernel/net.c`, ~430 lines):**
  - Full TCP state machine: CLOSED  SYN_SENT  ESTABLISHED  FIN_WAIT  etc.
  - TCP pseudo-header checksum calculation
  - 3-way handshake in `tcp_connect()`
  - 8KB receive ring buffer per socket
  - Proper FIN/ACK handling for graceful close
  - 8 concurrent sockets supported
  - MSS-aware segmentation (1400 byte chunks)
- **TCP API:**
  - `tcp_connect(ip, port)` - connect to server, returns socket handle
  - `tcp_send(sock, data, len)` - send data, returns bytes sent
  - `tcp_recv(sock, buf, maxlen)` - receive data (non-blocking)
  - `tcp_close(sock)` - graceful close with FIN
  - `tcp_is_connected(sock)` - check connection state
- **Fetch command (`/bin/fetch`):**
  - Usage: `fetch <hostname> [path]`
  - Resolves hostname, opens TCP connection to port 80
  - Sends HTTP/1.0 GET request
  - Prints response body
  - Example: `fetch google.com /`  got 301 redirect!
- **kapi additions:**
  - `dns_resolve(hostname)` - DNS resolution
  - `tcp_connect`, `tcp_send`, `tcp_recv`, `tcp_close`, `tcp_is_connected`
- **Achievement**: Made an HTTP request to google.com and got a real response!

### Session 32
- **Web Browser (`/bin/browser`) - GUI web browser!**
- **Improved fetch command:**
  - URL parsing (host, port, path extraction)
  - HTTP header parsing (status code, Content-Length, Location, Content-Type)
  - Redirect following (301, 302, 307, 308) with max 5 redirects
  - Handles both absolute and relative redirect URLs
- **Browser features:**
  - GUI window with address bar
  - Click address bar to edit URL, Enter to navigate
  - HTML parser with tag handling:
    - Strips `<script>`, `<style>`, `<head>` content
    - Handles headings (h1-h6), bold, links, lists, paragraphs
    - Decodes HTML entities (&amp;, &lt;, &gt;, etc.)
  - Text rendering with word wrap
  - Scrolling with Up/Down arrows, j/k keys, Space for page down
  - Scrollbar indicator for long pages
  - Status bar showing loading/ready state
  - Keyboard shortcuts: G (go to URL), R (reload)
- **Browser icon added to dock** (globe icon)
- **HTTP quirks discovered:**
  - Many sites force HTTPS (Wikipedia, YouTube, Amazon, DuckDuckGo)
  - Some sites reject simple User-Agent strings
  - Changed User-Agent to Chrome on Windows for compatibility
  - Works well on: httpforever.com, stallman.org, info.cern.ch
  - HTTPS would require full TLS implementation (~thousands of lines of crypto)
- **Debugging network issues:**
  - `yield()` during HTTP receive caused timing issues with desktop
  - `sleep_ms()` works correctly for polling
  - Different sites have different response timing behaviors
- **New files:**
  - `user/bin/browser.c` (~730 lines) - Full GUI web browser
  - `user/lib/icons.h` - Added browser (globe) icon
- **Achievement**: VibeOS has a web browser! Can browse HTTP sites with HTML rendering!

**NEXT SESSION TODO:**
- HTTPS/TLS? (complex, needs crypto - BearSSL or mbedTLS port)
- Web server (listen for connections)
- Maybe DOOM?
</file>

</files>
